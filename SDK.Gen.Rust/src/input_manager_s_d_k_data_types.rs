// Autogenerated by Thrift Compiler (0.12.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use common_type_s_d_k_data_types;

/// @Key_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Key {
  Unknown = 0,
  Escape = 1,
  D1 = 2,
  D2 = 3,
  D3 = 4,
  D4 = 5,
  D5 = 6,
  D6 = 7,
  D7 = 8,
  D8 = 9,
  D9 = 10,
  D0 = 11,
  Minus = 12,
  Equals = 13,
  Back = 14,
  Tab = 15,
  Q = 16,
  W = 17,
  E = 18,
  R = 19,
  T = 20,
  Y = 21,
  U = 22,
  I = 23,
  O = 24,
  P = 25,
  LeftBracket = 26,
  RightBracket = 27,
  Return = 28,
  LeftControl = 29,
  A = 30,
  S = 31,
  D = 32,
  F = 33,
  G = 34,
  H = 35,
  J = 36,
  K = 37,
  L = 38,
  Semicolon = 39,
  Apostrophe = 40,
  Grave = 41,
  LeftShift = 42,
  Backslash = 43,
  Z = 44,
  X = 45,
  C = 46,
  V = 47,
  B = 48,
  N = 49,
  M = 50,
  Comma = 51,
  Period = 52,
  Slash = 53,
  RightShift = 54,
  Multiply = 55,
  LeftAlt = 56,
  Space = 57,
  Capital = 58,
  F1 = 59,
  F2 = 60,
  F3 = 61,
  F4 = 62,
  F5 = 63,
  F6 = 64,
  F7 = 65,
  F8 = 66,
  F9 = 67,
  F10 = 68,
  NumberLock = 69,
  ScrollLock = 70,
  NumberPad7 = 71,
  NumberPad8 = 72,
  NumberPad9 = 73,
  Subtract = 74,
  NumberPad4 = 75,
  NumberPad5 = 76,
  NumberPad6 = 77,
  Add = 78,
  NumberPad1 = 79,
  NumberPad2 = 80,
  NumberPad3 = 81,
  NumberPad0 = 82,
  Decimal = 83,
  Oem102 = 86,
  F11 = 87,
  F12 = 88,
  F13 = 100,
  F14 = 101,
  F15 = 102,
  Kana = 112,
  AbntC1 = 115,
  Convert = 121,
  NoConvert = 123,
  Yen = 125,
  AbntC2 = 126,
  NumberPadEquals = 141,
  PreviousTrack = 144,
  At = 145,
  Colon = 146,
  Underline = 147,
  Kanji = 148,
  Stop = 149,
  Ax = 150,
  Unlabeled = 151,
  NextTrack = 153,
  NumberPadEnter = 156,
  RightControl = 157,
  Mute = 160,
  Calculator = 161,
  PlayPause = 162,
  MediaStop = 164,
  VolumeDown = 174,
  VolumeUp = 176,
  WebHome = 178,
  NumberPadComma = 179,
  Divide = 181,
  PrintScreen = 183,
  RightAlt = 184,
  Pause = 197,
  Home = 199,
  Up = 200,
  PageUp = 201,
  Left = 203,
  Right = 205,
  End = 207,
  Down = 208,
  PageDown = 209,
  Insert = 210,
  Delete = 211,
  LeftWindowsKey = 219,
  RightWindowsKey = 220,
  Applications = 221,
  Power = 222,
  Sleep = 223,
  Wake = 227,
  WebSearch = 229,
  WebFavorites = 230,
  WebRefresh = 231,
  WebStop = 232,
  WebForward = 233,
  WebBack = 234,
  MyComputer = 235,
  Mail = 236,
  MediaSelect = 237,
}

impl Key {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Key> {
    let enum_value = i_prot.read_i32()?;
    Key::try_from(enum_value)  }
}

impl TryFrom<i32> for Key {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(Key::Unknown),
      1 => Ok(Key::Escape),
      2 => Ok(Key::D1),
      3 => Ok(Key::D2),
      4 => Ok(Key::D3),
      5 => Ok(Key::D4),
      6 => Ok(Key::D5),
      7 => Ok(Key::D6),
      8 => Ok(Key::D7),
      9 => Ok(Key::D8),
      10 => Ok(Key::D9),
      11 => Ok(Key::D0),
      12 => Ok(Key::Minus),
      13 => Ok(Key::Equals),
      14 => Ok(Key::Back),
      15 => Ok(Key::Tab),
      16 => Ok(Key::Q),
      17 => Ok(Key::W),
      18 => Ok(Key::E),
      19 => Ok(Key::R),
      20 => Ok(Key::T),
      21 => Ok(Key::Y),
      22 => Ok(Key::U),
      23 => Ok(Key::I),
      24 => Ok(Key::O),
      25 => Ok(Key::P),
      26 => Ok(Key::LeftBracket),
      27 => Ok(Key::RightBracket),
      28 => Ok(Key::Return),
      29 => Ok(Key::LeftControl),
      30 => Ok(Key::A),
      31 => Ok(Key::S),
      32 => Ok(Key::D),
      33 => Ok(Key::F),
      34 => Ok(Key::G),
      35 => Ok(Key::H),
      36 => Ok(Key::J),
      37 => Ok(Key::K),
      38 => Ok(Key::L),
      39 => Ok(Key::Semicolon),
      40 => Ok(Key::Apostrophe),
      41 => Ok(Key::Grave),
      42 => Ok(Key::LeftShift),
      43 => Ok(Key::Backslash),
      44 => Ok(Key::Z),
      45 => Ok(Key::X),
      46 => Ok(Key::C),
      47 => Ok(Key::V),
      48 => Ok(Key::B),
      49 => Ok(Key::N),
      50 => Ok(Key::M),
      51 => Ok(Key::Comma),
      52 => Ok(Key::Period),
      53 => Ok(Key::Slash),
      54 => Ok(Key::RightShift),
      55 => Ok(Key::Multiply),
      56 => Ok(Key::LeftAlt),
      57 => Ok(Key::Space),
      58 => Ok(Key::Capital),
      59 => Ok(Key::F1),
      60 => Ok(Key::F2),
      61 => Ok(Key::F3),
      62 => Ok(Key::F4),
      63 => Ok(Key::F5),
      64 => Ok(Key::F6),
      65 => Ok(Key::F7),
      66 => Ok(Key::F8),
      67 => Ok(Key::F9),
      68 => Ok(Key::F10),
      69 => Ok(Key::NumberLock),
      70 => Ok(Key::ScrollLock),
      71 => Ok(Key::NumberPad7),
      72 => Ok(Key::NumberPad8),
      73 => Ok(Key::NumberPad9),
      74 => Ok(Key::Subtract),
      75 => Ok(Key::NumberPad4),
      76 => Ok(Key::NumberPad5),
      77 => Ok(Key::NumberPad6),
      78 => Ok(Key::Add),
      79 => Ok(Key::NumberPad1),
      80 => Ok(Key::NumberPad2),
      81 => Ok(Key::NumberPad3),
      82 => Ok(Key::NumberPad0),
      83 => Ok(Key::Decimal),
      86 => Ok(Key::Oem102),
      87 => Ok(Key::F11),
      88 => Ok(Key::F12),
      100 => Ok(Key::F13),
      101 => Ok(Key::F14),
      102 => Ok(Key::F15),
      112 => Ok(Key::Kana),
      115 => Ok(Key::AbntC1),
      121 => Ok(Key::Convert),
      123 => Ok(Key::NoConvert),
      125 => Ok(Key::Yen),
      126 => Ok(Key::AbntC2),
      141 => Ok(Key::NumberPadEquals),
      144 => Ok(Key::PreviousTrack),
      145 => Ok(Key::At),
      146 => Ok(Key::Colon),
      147 => Ok(Key::Underline),
      148 => Ok(Key::Kanji),
      149 => Ok(Key::Stop),
      150 => Ok(Key::Ax),
      151 => Ok(Key::Unlabeled),
      153 => Ok(Key::NextTrack),
      156 => Ok(Key::NumberPadEnter),
      157 => Ok(Key::RightControl),
      160 => Ok(Key::Mute),
      161 => Ok(Key::Calculator),
      162 => Ok(Key::PlayPause),
      164 => Ok(Key::MediaStop),
      174 => Ok(Key::VolumeDown),
      176 => Ok(Key::VolumeUp),
      178 => Ok(Key::WebHome),
      179 => Ok(Key::NumberPadComma),
      181 => Ok(Key::Divide),
      183 => Ok(Key::PrintScreen),
      184 => Ok(Key::RightAlt),
      197 => Ok(Key::Pause),
      199 => Ok(Key::Home),
      200 => Ok(Key::Up),
      201 => Ok(Key::PageUp),
      203 => Ok(Key::Left),
      205 => Ok(Key::Right),
      207 => Ok(Key::End),
      208 => Ok(Key::Down),
      209 => Ok(Key::PageDown),
      210 => Ok(Key::Insert),
      211 => Ok(Key::Delete),
      219 => Ok(Key::LeftWindowsKey),
      220 => Ok(Key::RightWindowsKey),
      221 => Ok(Key::Applications),
      222 => Ok(Key::Power),
      223 => Ok(Key::Sleep),
      227 => Ok(Key::Wake),
      229 => Ok(Key::WebSearch),
      230 => Ok(Key::WebFavorites),
      231 => Ok(Key::WebRefresh),
      232 => Ok(Key::WebStop),
      233 => Ok(Key::WebForward),
      234 => Ok(Key::WebBack),
      235 => Ok(Key::MyComputer),
      236 => Ok(Key::Mail),
      237 => Ok(Key::MediaSelect),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Key", i)
            )
          )
        )
      },
    }
  }
}

/// @MouseOffset_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MouseOffset {
  X = 0,
  Y = 4,
  Z = 8,
  Buttons0 = 12,
  Buttons1 = 13,
  Buttons2 = 14,
  Buttons3 = 15,
  Buttons4 = 16,
  Buttons5 = 17,
  Buttons6 = 18,
  Buttons7 = 19,
}

impl MouseOffset {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MouseOffset> {
    let enum_value = i_prot.read_i32()?;
    MouseOffset::try_from(enum_value)  }
}

impl TryFrom<i32> for MouseOffset {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(MouseOffset::X),
      4 => Ok(MouseOffset::Y),
      8 => Ok(MouseOffset::Z),
      12 => Ok(MouseOffset::Buttons0),
      13 => Ok(MouseOffset::Buttons1),
      14 => Ok(MouseOffset::Buttons2),
      15 => Ok(MouseOffset::Buttons3),
      16 => Ok(MouseOffset::Buttons4),
      17 => Ok(MouseOffset::Buttons5),
      18 => Ok(MouseOffset::Buttons6),
      19 => Ok(MouseOffset::Buttons7),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to MouseOffset", i)
            )
          )
        )
      },
    }
  }
}

/// @JoystickOffset_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum JoystickOffset {
  X = 0,
  Y = 4,
  Z = 8,
  RotationX = 12,
  RotationY = 16,
  RotationZ = 20,
  Sliders0 = 24,
  Sliders1 = 28,
  PointOfViewControllers0 = 32,
  PointOfViewControllers1 = 36,
  PointOfViewControllers2 = 40,
  PointOfViewControllers3 = 44,
  Buttons0 = 48,
  Buttons1 = 49,
  Buttons2 = 50,
  Buttons3 = 51,
  Buttons4 = 52,
  Buttons5 = 53,
  Buttons6 = 54,
  Buttons7 = 55,
  Buttons8 = 56,
  Buttons9 = 57,
  Buttons10 = 58,
  Buttons11 = 59,
  Buttons12 = 60,
  Buttons13 = 61,
  Buttons14 = 62,
  Buttons15 = 63,
  Buttons16 = 64,
  Buttons17 = 65,
  Buttons18 = 66,
  Buttons19 = 67,
  Buttons20 = 68,
  Buttons21 = 69,
  Buttons22 = 70,
  Buttons23 = 71,
  Buttons24 = 72,
  Buttons25 = 73,
  Buttons26 = 74,
  Buttons27 = 75,
  Buttons28 = 76,
  Buttons29 = 77,
  Buttons30 = 78,
  Buttons31 = 79,
  Buttons32 = 80,
  Buttons33 = 81,
  Buttons34 = 82,
  Buttons35 = 83,
  Buttons36 = 84,
  Buttons37 = 85,
  Buttons38 = 86,
  Buttons39 = 87,
  Buttons40 = 88,
  Buttons41 = 89,
  Buttons42 = 90,
  Buttons43 = 91,
  Buttons44 = 92,
  Buttons45 = 93,
  Buttons46 = 94,
  Buttons47 = 95,
  Buttons48 = 96,
  Buttons49 = 97,
  Buttons50 = 98,
  Buttons51 = 99,
  Buttons52 = 100,
  Buttons53 = 101,
  Buttons54 = 102,
  Buttons55 = 103,
  Buttons56 = 104,
  Buttons57 = 105,
  Buttons58 = 106,
  Buttons59 = 107,
  Buttons60 = 108,
  Buttons61 = 109,
  Buttons62 = 110,
  Buttons63 = 111,
  Buttons64 = 112,
  Buttons65 = 113,
  Buttons66 = 114,
  Buttons67 = 115,
  Buttons68 = 116,
  Buttons69 = 117,
  Buttons70 = 118,
  Buttons71 = 119,
  Buttons72 = 120,
  Buttons73 = 121,
  Buttons74 = 122,
  Buttons75 = 123,
  Buttons76 = 124,
  Buttons77 = 125,
  Buttons78 = 126,
  Buttons79 = 127,
  Buttons80 = 128,
  Buttons81 = 129,
  Buttons82 = 130,
  Buttons83 = 131,
  Buttons84 = 132,
  Buttons85 = 133,
  Buttons86 = 134,
  Buttons87 = 135,
  Buttons88 = 136,
  Buttons89 = 137,
  Buttons90 = 138,
  Buttons91 = 139,
  Buttons92 = 140,
  Buttons93 = 141,
  Buttons94 = 142,
  Buttons95 = 143,
  Buttons96 = 144,
  Buttons97 = 145,
  Buttons98 = 146,
  Buttons99 = 147,
  Buttons100 = 148,
  Buttons101 = 149,
  Buttons102 = 150,
  Buttons103 = 151,
  Buttons104 = 152,
  Buttons105 = 153,
  Buttons106 = 154,
  Buttons107 = 155,
  Buttons108 = 156,
  Buttons109 = 157,
  Buttons110 = 158,
  Buttons111 = 159,
  Buttons112 = 160,
  Buttons113 = 161,
  Buttons114 = 162,
  Buttons115 = 163,
  Buttons116 = 164,
  Buttons117 = 165,
  Buttons118 = 166,
  Buttons119 = 167,
  Buttons120 = 168,
  Buttons121 = 169,
  Buttons122 = 170,
  Buttons123 = 171,
  Buttons124 = 172,
  Buttons125 = 173,
  Buttons126 = 174,
  Buttons127 = 175,
  VelocityX = 176,
  VelocityY = 180,
  VelocityZ = 184,
  AngularVelocityX = 188,
  AngularVelocityY = 192,
  AngularVelocityZ = 196,
  VelocitySliders0 = 200,
  VelocitySliders1 = 204,
  AccelerationX = 208,
  AccelerationY = 212,
  AccelerationZ = 216,
  AngularAccelerationX = 220,
  AngularAccelerationY = 224,
  AngularAccelerationZ = 228,
  AccelerationSliders0 = 232,
  AccelerationSliders1 = 236,
  ForceX = 240,
  ForceY = 244,
  ForceZ = 248,
  TorqueX = 252,
  TorqueY = 256,
  TorqueZ = 260,
  ForceSliders0 = 264,
  ForceSliders1 = 268,
}

impl JoystickOffset {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<JoystickOffset> {
    let enum_value = i_prot.read_i32()?;
    JoystickOffset::try_from(enum_value)  }
}

impl TryFrom<i32> for JoystickOffset {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(JoystickOffset::X),
      4 => Ok(JoystickOffset::Y),
      8 => Ok(JoystickOffset::Z),
      12 => Ok(JoystickOffset::RotationX),
      16 => Ok(JoystickOffset::RotationY),
      20 => Ok(JoystickOffset::RotationZ),
      24 => Ok(JoystickOffset::Sliders0),
      28 => Ok(JoystickOffset::Sliders1),
      32 => Ok(JoystickOffset::PointOfViewControllers0),
      36 => Ok(JoystickOffset::PointOfViewControllers1),
      40 => Ok(JoystickOffset::PointOfViewControllers2),
      44 => Ok(JoystickOffset::PointOfViewControllers3),
      48 => Ok(JoystickOffset::Buttons0),
      49 => Ok(JoystickOffset::Buttons1),
      50 => Ok(JoystickOffset::Buttons2),
      51 => Ok(JoystickOffset::Buttons3),
      52 => Ok(JoystickOffset::Buttons4),
      53 => Ok(JoystickOffset::Buttons5),
      54 => Ok(JoystickOffset::Buttons6),
      55 => Ok(JoystickOffset::Buttons7),
      56 => Ok(JoystickOffset::Buttons8),
      57 => Ok(JoystickOffset::Buttons9),
      58 => Ok(JoystickOffset::Buttons10),
      59 => Ok(JoystickOffset::Buttons11),
      60 => Ok(JoystickOffset::Buttons12),
      61 => Ok(JoystickOffset::Buttons13),
      62 => Ok(JoystickOffset::Buttons14),
      63 => Ok(JoystickOffset::Buttons15),
      64 => Ok(JoystickOffset::Buttons16),
      65 => Ok(JoystickOffset::Buttons17),
      66 => Ok(JoystickOffset::Buttons18),
      67 => Ok(JoystickOffset::Buttons19),
      68 => Ok(JoystickOffset::Buttons20),
      69 => Ok(JoystickOffset::Buttons21),
      70 => Ok(JoystickOffset::Buttons22),
      71 => Ok(JoystickOffset::Buttons23),
      72 => Ok(JoystickOffset::Buttons24),
      73 => Ok(JoystickOffset::Buttons25),
      74 => Ok(JoystickOffset::Buttons26),
      75 => Ok(JoystickOffset::Buttons27),
      76 => Ok(JoystickOffset::Buttons28),
      77 => Ok(JoystickOffset::Buttons29),
      78 => Ok(JoystickOffset::Buttons30),
      79 => Ok(JoystickOffset::Buttons31),
      80 => Ok(JoystickOffset::Buttons32),
      81 => Ok(JoystickOffset::Buttons33),
      82 => Ok(JoystickOffset::Buttons34),
      83 => Ok(JoystickOffset::Buttons35),
      84 => Ok(JoystickOffset::Buttons36),
      85 => Ok(JoystickOffset::Buttons37),
      86 => Ok(JoystickOffset::Buttons38),
      87 => Ok(JoystickOffset::Buttons39),
      88 => Ok(JoystickOffset::Buttons40),
      89 => Ok(JoystickOffset::Buttons41),
      90 => Ok(JoystickOffset::Buttons42),
      91 => Ok(JoystickOffset::Buttons43),
      92 => Ok(JoystickOffset::Buttons44),
      93 => Ok(JoystickOffset::Buttons45),
      94 => Ok(JoystickOffset::Buttons46),
      95 => Ok(JoystickOffset::Buttons47),
      96 => Ok(JoystickOffset::Buttons48),
      97 => Ok(JoystickOffset::Buttons49),
      98 => Ok(JoystickOffset::Buttons50),
      99 => Ok(JoystickOffset::Buttons51),
      100 => Ok(JoystickOffset::Buttons52),
      101 => Ok(JoystickOffset::Buttons53),
      102 => Ok(JoystickOffset::Buttons54),
      103 => Ok(JoystickOffset::Buttons55),
      104 => Ok(JoystickOffset::Buttons56),
      105 => Ok(JoystickOffset::Buttons57),
      106 => Ok(JoystickOffset::Buttons58),
      107 => Ok(JoystickOffset::Buttons59),
      108 => Ok(JoystickOffset::Buttons60),
      109 => Ok(JoystickOffset::Buttons61),
      110 => Ok(JoystickOffset::Buttons62),
      111 => Ok(JoystickOffset::Buttons63),
      112 => Ok(JoystickOffset::Buttons64),
      113 => Ok(JoystickOffset::Buttons65),
      114 => Ok(JoystickOffset::Buttons66),
      115 => Ok(JoystickOffset::Buttons67),
      116 => Ok(JoystickOffset::Buttons68),
      117 => Ok(JoystickOffset::Buttons69),
      118 => Ok(JoystickOffset::Buttons70),
      119 => Ok(JoystickOffset::Buttons71),
      120 => Ok(JoystickOffset::Buttons72),
      121 => Ok(JoystickOffset::Buttons73),
      122 => Ok(JoystickOffset::Buttons74),
      123 => Ok(JoystickOffset::Buttons75),
      124 => Ok(JoystickOffset::Buttons76),
      125 => Ok(JoystickOffset::Buttons77),
      126 => Ok(JoystickOffset::Buttons78),
      127 => Ok(JoystickOffset::Buttons79),
      128 => Ok(JoystickOffset::Buttons80),
      129 => Ok(JoystickOffset::Buttons81),
      130 => Ok(JoystickOffset::Buttons82),
      131 => Ok(JoystickOffset::Buttons83),
      132 => Ok(JoystickOffset::Buttons84),
      133 => Ok(JoystickOffset::Buttons85),
      134 => Ok(JoystickOffset::Buttons86),
      135 => Ok(JoystickOffset::Buttons87),
      136 => Ok(JoystickOffset::Buttons88),
      137 => Ok(JoystickOffset::Buttons89),
      138 => Ok(JoystickOffset::Buttons90),
      139 => Ok(JoystickOffset::Buttons91),
      140 => Ok(JoystickOffset::Buttons92),
      141 => Ok(JoystickOffset::Buttons93),
      142 => Ok(JoystickOffset::Buttons94),
      143 => Ok(JoystickOffset::Buttons95),
      144 => Ok(JoystickOffset::Buttons96),
      145 => Ok(JoystickOffset::Buttons97),
      146 => Ok(JoystickOffset::Buttons98),
      147 => Ok(JoystickOffset::Buttons99),
      148 => Ok(JoystickOffset::Buttons100),
      149 => Ok(JoystickOffset::Buttons101),
      150 => Ok(JoystickOffset::Buttons102),
      151 => Ok(JoystickOffset::Buttons103),
      152 => Ok(JoystickOffset::Buttons104),
      153 => Ok(JoystickOffset::Buttons105),
      154 => Ok(JoystickOffset::Buttons106),
      155 => Ok(JoystickOffset::Buttons107),
      156 => Ok(JoystickOffset::Buttons108),
      157 => Ok(JoystickOffset::Buttons109),
      158 => Ok(JoystickOffset::Buttons110),
      159 => Ok(JoystickOffset::Buttons111),
      160 => Ok(JoystickOffset::Buttons112),
      161 => Ok(JoystickOffset::Buttons113),
      162 => Ok(JoystickOffset::Buttons114),
      163 => Ok(JoystickOffset::Buttons115),
      164 => Ok(JoystickOffset::Buttons116),
      165 => Ok(JoystickOffset::Buttons117),
      166 => Ok(JoystickOffset::Buttons118),
      167 => Ok(JoystickOffset::Buttons119),
      168 => Ok(JoystickOffset::Buttons120),
      169 => Ok(JoystickOffset::Buttons121),
      170 => Ok(JoystickOffset::Buttons122),
      171 => Ok(JoystickOffset::Buttons123),
      172 => Ok(JoystickOffset::Buttons124),
      173 => Ok(JoystickOffset::Buttons125),
      174 => Ok(JoystickOffset::Buttons126),
      175 => Ok(JoystickOffset::Buttons127),
      176 => Ok(JoystickOffset::VelocityX),
      180 => Ok(JoystickOffset::VelocityY),
      184 => Ok(JoystickOffset::VelocityZ),
      188 => Ok(JoystickOffset::AngularVelocityX),
      192 => Ok(JoystickOffset::AngularVelocityY),
      196 => Ok(JoystickOffset::AngularVelocityZ),
      200 => Ok(JoystickOffset::VelocitySliders0),
      204 => Ok(JoystickOffset::VelocitySliders1),
      208 => Ok(JoystickOffset::AccelerationX),
      212 => Ok(JoystickOffset::AccelerationY),
      216 => Ok(JoystickOffset::AccelerationZ),
      220 => Ok(JoystickOffset::AngularAccelerationX),
      224 => Ok(JoystickOffset::AngularAccelerationY),
      228 => Ok(JoystickOffset::AngularAccelerationZ),
      232 => Ok(JoystickOffset::AccelerationSliders0),
      236 => Ok(JoystickOffset::AccelerationSliders1),
      240 => Ok(JoystickOffset::ForceX),
      244 => Ok(JoystickOffset::ForceY),
      248 => Ok(JoystickOffset::ForceZ),
      252 => Ok(JoystickOffset::TorqueX),
      256 => Ok(JoystickOffset::TorqueY),
      260 => Ok(JoystickOffset::TorqueZ),
      264 => Ok(JoystickOffset::ForceSliders0),
      268 => Ok(JoystickOffset::ForceSliders1),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to JoystickOffset", i)
            )
          )
        )
      },
    }
  }
}

pub type _float = OrderedFloat<f64>;

//
// RuyiGamePadInput
//

/// @RuyiGamePadInput_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiGamePadInput {
  /// @RuyiGamePadInput_DeviceId_desc
  pub device_id: Option<String>,
  /// @RuyiGamePadInput_UserId_desc
  pub user_id: Option<String>,
  /// Combination of RuyiGamePadButtonFlags
  pub button_flags: Option<i32>,
  /// @RuyiGamePadInput_LeftTrigger_desc
  pub left_trigger: Option<i8>,
  /// @RuyiGamePadInput_RightTrigger_desc
  pub right_trigger: Option<i8>,
  /// @RuyiGamePadInput_LeftThumbX_desc
  pub left_thumb_x: Option<i16>,
  /// @RuyiGamePadInput_LeftThumbY_desc
  pub left_thumb_y: Option<i16>,
  /// @RuyiGamePadInput_RightThumbX_desc
  pub right_thumb_x: Option<i16>,
  /// @RuyiGamePadInput_RightThumbY_desc
  pub right_thumb_y: Option<i16>,
}

impl RuyiGamePadInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(device_id: F1, user_id: F2, button_flags: F3, left_trigger: F4, right_trigger: F5, left_thumb_x: F6, left_thumb_y: F7, right_thumb_x: F8, right_thumb_y: F9) -> RuyiGamePadInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i8>>, F5: Into<Option<i8>>, F6: Into<Option<i16>>, F7: Into<Option<i16>>, F8: Into<Option<i16>>, F9: Into<Option<i16>> {
    RuyiGamePadInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      button_flags: button_flags.into(),
      left_trigger: left_trigger.into(),
      right_trigger: right_trigger.into(),
      left_thumb_x: left_thumb_x.into(),
      left_thumb_y: left_thumb_y.into(),
      right_thumb_x: right_thumb_x.into(),
      right_thumb_y: right_thumb_y.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiGamePadInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i8> = Some(0);
    let mut f_5: Option<i8> = Some(0);
    let mut f_6: Option<i16> = Some(0);
    let mut f_7: Option<i16> = Some(0);
    let mut f_8: Option<i16> = Some(0);
    let mut f_9: Option<i16> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i8()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i16()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i16()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i16()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i16()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiGamePadInput {
      device_id: f_1,
      user_id: f_2,
      button_flags: f_3,
      left_trigger: f_4,
      right_trigger: f_5,
      left_thumb_x: f_6,
      left_thumb_y: f_7,
      right_thumb_x: f_8,
      right_thumb_y: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiGamePadInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.button_flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("ButtonFlags", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.left_trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("LeftTrigger", TType::I08, 4))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.right_trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("RightTrigger", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.left_thumb_x {
      o_prot.write_field_begin(&TFieldIdentifier::new("LeftThumbX", TType::I16, 6))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.left_thumb_y {
      o_prot.write_field_begin(&TFieldIdentifier::new("LeftThumbY", TType::I16, 7))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.right_thumb_x {
      o_prot.write_field_begin(&TFieldIdentifier::new("RightThumbX", TType::I16, 8))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.right_thumb_y {
      o_prot.write_field_begin(&TFieldIdentifier::new("RightThumbY", TType::I16, 9))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiGamePadInput {
  fn default() -> Self {
    RuyiGamePadInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      button_flags: Some(0),
      left_trigger: Some(0),
      right_trigger: Some(0),
      left_thumb_x: Some(0),
      left_thumb_y: Some(0),
      right_thumb_x: Some(0),
      right_thumb_y: Some(0),
    }
  }
}

//
// RuyiKeyboardInput
//

/// @RuyiKeyboardInput_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiKeyboardInput {
  /// @RuyiKeyboardInput_DeviceId_desc
  pub device_id: Option<String>,
  /// @RuyiKeyboardInput_UserId_desc
  pub user_id: Option<String>,
  /// @RuyiKeyboardInput_RawOffset_desc
  pub raw_offset: Option<i32>,
  /// @RuyiKeyboardInput_Value_desc
  pub value: Option<i32>,
  /// @RuyiKeyboardInput_Timestamp_desc
  pub timestamp: Option<i32>,
  /// @RuyiKeyboardInput_Sequence_desc
  pub sequence: Option<i32>,
  /// @RuyiKeyboardInput_Key_desc
  pub key: Option<Key>,
  /// @RuyiKeyboardInput_IsPressed_desc
  pub is_pressed: Option<bool>,
  /// @RuyiKeyboardInput_IsReleased_desc
  pub is_released: Option<bool>,
}

impl RuyiKeyboardInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(device_id: F1, user_id: F2, raw_offset: F3, value: F4, timestamp: F5, sequence: F6, key: F7, is_pressed: F8, is_released: F9) -> RuyiKeyboardInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<Key>>, F8: Into<Option<bool>>, F9: Into<Option<bool>> {
    RuyiKeyboardInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      raw_offset: raw_offset.into(),
      value: value.into(),
      timestamp: timestamp.into(),
      sequence: sequence.into(),
      key: key.into(),
      is_pressed: is_pressed.into(),
      is_released: is_released.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiKeyboardInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<Key> = None;
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = Key::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiKeyboardInput {
      device_id: f_1,
      user_id: f_2,
      raw_offset: f_3,
      value: f_4,
      timestamp: f_5,
      sequence: f_6,
      key: f_7,
      is_pressed: f_8,
      is_released: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiKeyboardInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.raw_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("RawOffset", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("Timestamp", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("Sequence", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("Key", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_pressed {
      o_prot.write_field_begin(&TFieldIdentifier::new("IsPressed", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_released {
      o_prot.write_field_begin(&TFieldIdentifier::new("IsReleased", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiKeyboardInput {
  fn default() -> Self {
    RuyiKeyboardInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      raw_offset: Some(0),
      value: Some(0),
      timestamp: Some(0),
      sequence: Some(0),
      key: None,
      is_pressed: Some(false),
      is_released: Some(false),
    }
  }
}

//
// RuyiMouseInput
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiMouseInput {
  /// @RuyiMouseInput_DeviceId_desc
  pub device_id: Option<String>,
  /// @RuyiMouseInput_UserId_desc
  pub user_id: Option<String>,
  /// @RuyiMouseInput_RawOffset_desc
  pub raw_offset: Option<i32>,
  /// @RuyiMouseInput_Value_desc
  pub value: Option<i32>,
  /// @RuyiMouseInput_Timestamp_desc
  pub timestamp: Option<i32>,
  /// @RuyiMouseInput_Sequence_desc
  pub sequence: Option<i32>,
  /// @RuyiMouseInput_Offset_desc
  pub offset: Option<MouseOffset>,
  /// @RuyiMouseInput_IsButton_desc
  pub is_button: Option<bool>,
}

impl RuyiMouseInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(device_id: F1, user_id: F2, raw_offset: F3, value: F4, timestamp: F5, sequence: F6, offset: F7, is_button: F8) -> RuyiMouseInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<MouseOffset>>, F8: Into<Option<bool>> {
    RuyiMouseInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      raw_offset: raw_offset.into(),
      value: value.into(),
      timestamp: timestamp.into(),
      sequence: sequence.into(),
      offset: offset.into(),
      is_button: is_button.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiMouseInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<MouseOffset> = None;
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = MouseOffset::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiMouseInput {
      device_id: f_1,
      user_id: f_2,
      raw_offset: f_3,
      value: f_4,
      timestamp: f_5,
      sequence: f_6,
      offset: f_7,
      is_button: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiMouseInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.raw_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("RawOffset", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("Timestamp", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("Sequence", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("Offset", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_button {
      o_prot.write_field_begin(&TFieldIdentifier::new("IsButton", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiMouseInput {
  fn default() -> Self {
    RuyiMouseInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      raw_offset: Some(0),
      value: Some(0),
      timestamp: Some(0),
      sequence: Some(0),
      offset: None,
      is_button: Some(false),
    }
  }
}

//
// RuyiJoystickInput
//

/// @RuyiJoystickInput_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiJoystickInput {
  /// @RuyiJoystickInput_DeviceId_desc
  pub device_id: Option<String>,
  /// @RuyiJoystickInput_UserId_desc
  pub user_id: Option<String>,
  /// @RuyiJoystickInput_RawOffset_desc
  pub raw_offset: Option<i32>,
  /// @RuyiJoystickInput_Value_desc
  pub value: Option<i32>,
  /// @RuyiJoystickInput_Timestamp_desc
  pub timestamp: Option<i32>,
  /// @RuyiJoystickInput_Sequence_desc
  pub sequence: Option<i32>,
  /// @RuyiJoystickInput_Offset_desc
  pub offset: Option<JoystickOffset>,
}

impl RuyiJoystickInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(device_id: F1, user_id: F2, raw_offset: F3, value: F4, timestamp: F5, sequence: F6, offset: F7) -> RuyiJoystickInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<JoystickOffset>> {
    RuyiJoystickInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      raw_offset: raw_offset.into(),
      value: value.into(),
      timestamp: timestamp.into(),
      sequence: sequence.into(),
      offset: offset.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiJoystickInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<JoystickOffset> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = JoystickOffset::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiJoystickInput {
      device_id: f_1,
      user_id: f_2,
      raw_offset: f_3,
      value: f_4,
      timestamp: f_5,
      sequence: f_6,
      offset: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiJoystickInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.raw_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("RawOffset", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("Timestamp", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("Sequence", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("Offset", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiJoystickInput {
  fn default() -> Self {
    RuyiJoystickInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      raw_offset: Some(0),
      value: Some(0),
      timestamp: Some(0),
      sequence: Some(0),
      offset: None,
    }
  }
}

//
// InputActionTriggered
//

/// Action triggered by digital input device ( buttons on gamepad or key on key board )
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InputActionTriggered {
  /// The device id
  pub device_id: Option<String>,
  /// The id of user whome is bound to the device
  pub user_id: Option<String>,
  /// The name of the action
  pub name: Option<String>,
  /// The time the action is triggered
  pub timestamp: Option<i64>,
  /// The device's state when trggering the action
  pub trigger: Option<common_type_s_d_k_data_types::ActionTrigger>,
  /// Whether or not the action is triggered by auto trigger
  pub by_auto_trigger: Option<bool>,
}

impl InputActionTriggered {
  pub fn new<F1, F2, F3, F4, F5, F6>(device_id: F1, user_id: F2, name: F3, timestamp: F4, trigger: F5, by_auto_trigger: F6) -> InputActionTriggered where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i64>>, F5: Into<Option<common_type_s_d_k_data_types::ActionTrigger>>, F6: Into<Option<bool>> {
    InputActionTriggered {
      device_id: device_id.into(),
      user_id: user_id.into(),
      name: name.into(),
      timestamp: timestamp.into(),
      trigger: trigger.into(),
      by_auto_trigger: by_auto_trigger.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputActionTriggered> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<common_type_s_d_k_data_types::ActionTrigger> = None;
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = common_type_s_d_k_data_types::ActionTrigger::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InputActionTriggered {
      device_id: f_1,
      user_id: f_2,
      name: f_3,
      timestamp: f_4,
      trigger: f_5,
      by_auto_trigger: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InputActionTriggered");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("trigger", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.by_auto_trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("byAutoTrigger", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InputActionTriggered {
  fn default() -> Self {
    InputActionTriggered{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      name: Some("".to_owned()),
      timestamp: Some(0),
      trigger: None,
      by_auto_trigger: Some(false),
    }
  }
}

//
// AxisActionTriggered
//

/// Action triggered by analog input device ( the thumbs or triggers on gamepad )
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AxisActionTriggered {
  /// The device id
  pub device_id: Option<String>,
  /// The id of user whome is bound to the device
  pub user_id: Option<String>,
  /// The name of the action
  pub name: Option<String>,
  /// The time the action is triggered
  pub timestamp: Option<i64>,
  /// The scale of the action
  pub scale: Option<_float>,
}

impl AxisActionTriggered {
  pub fn new<F1, F2, F3, F4, F5>(device_id: F1, user_id: F2, name: F3, timestamp: F4, scale: F5) -> AxisActionTriggered where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i64>>, F5: Into<Option<_float>> {
    AxisActionTriggered {
      device_id: device_id.into(),
      user_id: user_id.into(),
      name: name.into(),
      timestamp: timestamp.into(),
      scale: scale.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AxisActionTriggered> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<_float> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AxisActionTriggered {
      device_id: f_1,
      user_id: f_2,
      name: f_3,
      timestamp: f_4,
      scale: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AxisActionTriggered");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AxisActionTriggered {
  fn default() -> Self {
    AxisActionTriggered{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      name: Some("".to_owned()),
      timestamp: Some(0),
      scale: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// GamepadInfo
//

/// Gamepad's information
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GamepadInfo {
  /// The device id of the gamepad
  pub device_id: Option<String>,
  /// Whether the device is wirelessly connected
  pub is_wireless: Option<bool>,
}

impl GamepadInfo {
  pub fn new<F1, F2>(device_id: F1, is_wireless: F2) -> GamepadInfo where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    GamepadInfo {
      device_id: device_id.into(),
      is_wireless: is_wireless.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GamepadInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GamepadInfo {
      device_id: f_1,
      is_wireless: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GamepadInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_wireless {
      o_prot.write_field_begin(&TFieldIdentifier::new("isWireless", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GamepadInfo {
  fn default() -> Self {
    GamepadInfo{
      device_id: Some("".to_owned()),
      is_wireless: Some(false),
    }
  }
}

