// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use common_type_s_d_k_data_types;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Key {
  UNKNOWN = 0,
  ESCAPE = 1,
  D1 = 2,
  D2 = 3,
  D3 = 4,
  D4 = 5,
  D5 = 6,
  D6 = 7,
  D7 = 8,
  D8 = 9,
  D9 = 10,
  D0 = 11,
  MINUS = 12,
  EQUALS = 13,
  BACK = 14,
  TAB = 15,
  Q = 16,
  W = 17,
  E = 18,
  R = 19,
  T = 20,
  Y = 21,
  U = 22,
  I = 23,
  O = 24,
  P = 25,
  LEFTBRACKET = 26,
  RIGHTBRACKET = 27,
  RETURN = 28,
  LEFTCONTROL = 29,
  A = 30,
  S = 31,
  D = 32,
  F = 33,
  G = 34,
  H = 35,
  J = 36,
  K = 37,
  L = 38,
  SEMICOLON = 39,
  APOSTROPHE = 40,
  GRAVE = 41,
  LEFTSHIFT = 42,
  BACKSLASH = 43,
  Z = 44,
  X = 45,
  C = 46,
  V = 47,
  B = 48,
  N = 49,
  M = 50,
  COMMA = 51,
  PERIOD = 52,
  SLASH = 53,
  RIGHTSHIFT = 54,
  MULTIPLY = 55,
  LEFTALT = 56,
  SPACE = 57,
  CAPITAL = 58,
  F1 = 59,
  F2 = 60,
  F3 = 61,
  F4 = 62,
  F5 = 63,
  F6 = 64,
  F7 = 65,
  F8 = 66,
  F9 = 67,
  F10 = 68,
  NUMBERLOCK = 69,
  SCROLLLOCK = 70,
  NUMBERPAD7 = 71,
  NUMBERPAD8 = 72,
  NUMBERPAD9 = 73,
  SUBTRACT = 74,
  NUMBERPAD4 = 75,
  NUMBERPAD5 = 76,
  NUMBERPAD6 = 77,
  ADD = 78,
  NUMBERPAD1 = 79,
  NUMBERPAD2 = 80,
  NUMBERPAD3 = 81,
  NUMBERPAD0 = 82,
  DECIMAL = 83,
  OEM102 = 86,
  F11 = 87,
  F12 = 88,
  F13 = 100,
  F14 = 101,
  F15 = 102,
  KANA = 112,
  ABNTC1 = 115,
  CONVERT = 121,
  NOCONVERT = 123,
  YEN = 125,
  ABNTC2 = 126,
  NUMBERPADEQUALS = 141,
  PREVIOUSTRACK = 144,
  AT = 145,
  COLON = 146,
  UNDERLINE = 147,
  KANJI = 148,
  STOP = 149,
  AX = 150,
  UNLABELED = 151,
  NEXTTRACK = 153,
  NUMBERPADENTER = 156,
  RIGHTCONTROL = 157,
  MUTE = 160,
  CALCULATOR = 161,
  PLAYPAUSE = 162,
  MEDIASTOP = 164,
  VOLUMEDOWN = 174,
  VOLUMEUP = 176,
  WEBHOME = 178,
  NUMBERPADCOMMA = 179,
  DIVIDE = 181,
  PRINTSCREEN = 183,
  RIGHTALT = 184,
  PAUSE = 197,
  HOME = 199,
  UP = 200,
  PAGEUP = 201,
  LEFT = 203,
  RIGHT = 205,
  END = 207,
  DOWN = 208,
  PAGEDOWN = 209,
  INSERT = 210,
  DELETE = 211,
  LEFTWINDOWSKEY = 219,
  RIGHTWINDOWSKEY = 220,
  APPLICATIONS = 221,
  POWER = 222,
  SLEEP = 223,
  WAKE = 227,
  WEBSEARCH = 229,
  WEBFAVORITES = 230,
  WEBREFRESH = 231,
  WEBSTOP = 232,
  WEBFORWARD = 233,
  WEBBACK = 234,
  MYCOMPUTER = 235,
  MAIL = 236,
  MEDIASELECT = 237,
}

impl Key {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Key> {
    let enum_value = i_prot.read_i32()?;
    Key::try_from(enum_value)  }
}

impl TryFrom<i32> for Key {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(Key::UNKNOWN),
      1 => Ok(Key::ESCAPE),
      2 => Ok(Key::D1),
      3 => Ok(Key::D2),
      4 => Ok(Key::D3),
      5 => Ok(Key::D4),
      6 => Ok(Key::D5),
      7 => Ok(Key::D6),
      8 => Ok(Key::D7),
      9 => Ok(Key::D8),
      10 => Ok(Key::D9),
      11 => Ok(Key::D0),
      12 => Ok(Key::MINUS),
      13 => Ok(Key::EQUALS),
      14 => Ok(Key::BACK),
      15 => Ok(Key::TAB),
      16 => Ok(Key::Q),
      17 => Ok(Key::W),
      18 => Ok(Key::E),
      19 => Ok(Key::R),
      20 => Ok(Key::T),
      21 => Ok(Key::Y),
      22 => Ok(Key::U),
      23 => Ok(Key::I),
      24 => Ok(Key::O),
      25 => Ok(Key::P),
      26 => Ok(Key::LEFTBRACKET),
      27 => Ok(Key::RIGHTBRACKET),
      28 => Ok(Key::RETURN),
      29 => Ok(Key::LEFTCONTROL),
      30 => Ok(Key::A),
      31 => Ok(Key::S),
      32 => Ok(Key::D),
      33 => Ok(Key::F),
      34 => Ok(Key::G),
      35 => Ok(Key::H),
      36 => Ok(Key::J),
      37 => Ok(Key::K),
      38 => Ok(Key::L),
      39 => Ok(Key::SEMICOLON),
      40 => Ok(Key::APOSTROPHE),
      41 => Ok(Key::GRAVE),
      42 => Ok(Key::LEFTSHIFT),
      43 => Ok(Key::BACKSLASH),
      44 => Ok(Key::Z),
      45 => Ok(Key::X),
      46 => Ok(Key::C),
      47 => Ok(Key::V),
      48 => Ok(Key::B),
      49 => Ok(Key::N),
      50 => Ok(Key::M),
      51 => Ok(Key::COMMA),
      52 => Ok(Key::PERIOD),
      53 => Ok(Key::SLASH),
      54 => Ok(Key::RIGHTSHIFT),
      55 => Ok(Key::MULTIPLY),
      56 => Ok(Key::LEFTALT),
      57 => Ok(Key::SPACE),
      58 => Ok(Key::CAPITAL),
      59 => Ok(Key::F1),
      60 => Ok(Key::F2),
      61 => Ok(Key::F3),
      62 => Ok(Key::F4),
      63 => Ok(Key::F5),
      64 => Ok(Key::F6),
      65 => Ok(Key::F7),
      66 => Ok(Key::F8),
      67 => Ok(Key::F9),
      68 => Ok(Key::F10),
      69 => Ok(Key::NUMBERLOCK),
      70 => Ok(Key::SCROLLLOCK),
      71 => Ok(Key::NUMBERPAD7),
      72 => Ok(Key::NUMBERPAD8),
      73 => Ok(Key::NUMBERPAD9),
      74 => Ok(Key::SUBTRACT),
      75 => Ok(Key::NUMBERPAD4),
      76 => Ok(Key::NUMBERPAD5),
      77 => Ok(Key::NUMBERPAD6),
      78 => Ok(Key::ADD),
      79 => Ok(Key::NUMBERPAD1),
      80 => Ok(Key::NUMBERPAD2),
      81 => Ok(Key::NUMBERPAD3),
      82 => Ok(Key::NUMBERPAD0),
      83 => Ok(Key::DECIMAL),
      86 => Ok(Key::OEM102),
      87 => Ok(Key::F11),
      88 => Ok(Key::F12),
      100 => Ok(Key::F13),
      101 => Ok(Key::F14),
      102 => Ok(Key::F15),
      112 => Ok(Key::KANA),
      115 => Ok(Key::ABNTC1),
      121 => Ok(Key::CONVERT),
      123 => Ok(Key::NOCONVERT),
      125 => Ok(Key::YEN),
      126 => Ok(Key::ABNTC2),
      141 => Ok(Key::NUMBERPADEQUALS),
      144 => Ok(Key::PREVIOUSTRACK),
      145 => Ok(Key::AT),
      146 => Ok(Key::COLON),
      147 => Ok(Key::UNDERLINE),
      148 => Ok(Key::KANJI),
      149 => Ok(Key::STOP),
      150 => Ok(Key::AX),
      151 => Ok(Key::UNLABELED),
      153 => Ok(Key::NEXTTRACK),
      156 => Ok(Key::NUMBERPADENTER),
      157 => Ok(Key::RIGHTCONTROL),
      160 => Ok(Key::MUTE),
      161 => Ok(Key::CALCULATOR),
      162 => Ok(Key::PLAYPAUSE),
      164 => Ok(Key::MEDIASTOP),
      174 => Ok(Key::VOLUMEDOWN),
      176 => Ok(Key::VOLUMEUP),
      178 => Ok(Key::WEBHOME),
      179 => Ok(Key::NUMBERPADCOMMA),
      181 => Ok(Key::DIVIDE),
      183 => Ok(Key::PRINTSCREEN),
      184 => Ok(Key::RIGHTALT),
      197 => Ok(Key::PAUSE),
      199 => Ok(Key::HOME),
      200 => Ok(Key::UP),
      201 => Ok(Key::PAGEUP),
      203 => Ok(Key::LEFT),
      205 => Ok(Key::RIGHT),
      207 => Ok(Key::END),
      208 => Ok(Key::DOWN),
      209 => Ok(Key::PAGEDOWN),
      210 => Ok(Key::INSERT),
      211 => Ok(Key::DELETE),
      219 => Ok(Key::LEFTWINDOWSKEY),
      220 => Ok(Key::RIGHTWINDOWSKEY),
      221 => Ok(Key::APPLICATIONS),
      222 => Ok(Key::POWER),
      223 => Ok(Key::SLEEP),
      227 => Ok(Key::WAKE),
      229 => Ok(Key::WEBSEARCH),
      230 => Ok(Key::WEBFAVORITES),
      231 => Ok(Key::WEBREFRESH),
      232 => Ok(Key::WEBSTOP),
      233 => Ok(Key::WEBFORWARD),
      234 => Ok(Key::WEBBACK),
      235 => Ok(Key::MYCOMPUTER),
      236 => Ok(Key::MAIL),
      237 => Ok(Key::MEDIASELECT),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Key", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum MouseOffset {
  X = 0,
  Y = 4,
  Z = 8,
  BUTTONS0 = 12,
  BUTTONS1 = 13,
  BUTTONS2 = 14,
  BUTTONS3 = 15,
  BUTTONS4 = 16,
  BUTTONS5 = 17,
  BUTTONS6 = 18,
  BUTTONS7 = 19,
}

impl MouseOffset {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<MouseOffset> {
    let enum_value = i_prot.read_i32()?;
    MouseOffset::try_from(enum_value)  }
}

impl TryFrom<i32> for MouseOffset {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(MouseOffset::X),
      4 => Ok(MouseOffset::Y),
      8 => Ok(MouseOffset::Z),
      12 => Ok(MouseOffset::BUTTONS0),
      13 => Ok(MouseOffset::BUTTONS1),
      14 => Ok(MouseOffset::BUTTONS2),
      15 => Ok(MouseOffset::BUTTONS3),
      16 => Ok(MouseOffset::BUTTONS4),
      17 => Ok(MouseOffset::BUTTONS5),
      18 => Ok(MouseOffset::BUTTONS6),
      19 => Ok(MouseOffset::BUTTONS7),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to MouseOffset", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum JoystickOffset {
  X = 0,
  Y = 4,
  Z = 8,
  ROTATIONX = 12,
  ROTATIONY = 16,
  ROTATIONZ = 20,
  SLIDERS0 = 24,
  SLIDERS1 = 28,
  POINTOFVIEWCONTROLLERS0 = 32,
  POINTOFVIEWCONTROLLERS1 = 36,
  POINTOFVIEWCONTROLLERS2 = 40,
  POINTOFVIEWCONTROLLERS3 = 44,
  BUTTONS0 = 48,
  BUTTONS1 = 49,
  BUTTONS2 = 50,
  BUTTONS3 = 51,
  BUTTONS4 = 52,
  BUTTONS5 = 53,
  BUTTONS6 = 54,
  BUTTONS7 = 55,
  BUTTONS8 = 56,
  BUTTONS9 = 57,
  BUTTONS10 = 58,
  BUTTONS11 = 59,
  BUTTONS12 = 60,
  BUTTONS13 = 61,
  BUTTONS14 = 62,
  BUTTONS15 = 63,
  BUTTONS16 = 64,
  BUTTONS17 = 65,
  BUTTONS18 = 66,
  BUTTONS19 = 67,
  BUTTONS20 = 68,
  BUTTONS21 = 69,
  BUTTONS22 = 70,
  BUTTONS23 = 71,
  BUTTONS24 = 72,
  BUTTONS25 = 73,
  BUTTONS26 = 74,
  BUTTONS27 = 75,
  BUTTONS28 = 76,
  BUTTONS29 = 77,
  BUTTONS30 = 78,
  BUTTONS31 = 79,
  BUTTONS32 = 80,
  BUTTONS33 = 81,
  BUTTONS34 = 82,
  BUTTONS35 = 83,
  BUTTONS36 = 84,
  BUTTONS37 = 85,
  BUTTONS38 = 86,
  BUTTONS39 = 87,
  BUTTONS40 = 88,
  BUTTONS41 = 89,
  BUTTONS42 = 90,
  BUTTONS43 = 91,
  BUTTONS44 = 92,
  BUTTONS45 = 93,
  BUTTONS46 = 94,
  BUTTONS47 = 95,
  BUTTONS48 = 96,
  BUTTONS49 = 97,
  BUTTONS50 = 98,
  BUTTONS51 = 99,
  BUTTONS52 = 100,
  BUTTONS53 = 101,
  BUTTONS54 = 102,
  BUTTONS55 = 103,
  BUTTONS56 = 104,
  BUTTONS57 = 105,
  BUTTONS58 = 106,
  BUTTONS59 = 107,
  BUTTONS60 = 108,
  BUTTONS61 = 109,
  BUTTONS62 = 110,
  BUTTONS63 = 111,
  BUTTONS64 = 112,
  BUTTONS65 = 113,
  BUTTONS66 = 114,
  BUTTONS67 = 115,
  BUTTONS68 = 116,
  BUTTONS69 = 117,
  BUTTONS70 = 118,
  BUTTONS71 = 119,
  BUTTONS72 = 120,
  BUTTONS73 = 121,
  BUTTONS74 = 122,
  BUTTONS75 = 123,
  BUTTONS76 = 124,
  BUTTONS77 = 125,
  BUTTONS78 = 126,
  BUTTONS79 = 127,
  BUTTONS80 = 128,
  BUTTONS81 = 129,
  BUTTONS82 = 130,
  BUTTONS83 = 131,
  BUTTONS84 = 132,
  BUTTONS85 = 133,
  BUTTONS86 = 134,
  BUTTONS87 = 135,
  BUTTONS88 = 136,
  BUTTONS89 = 137,
  BUTTONS90 = 138,
  BUTTONS91 = 139,
  BUTTONS92 = 140,
  BUTTONS93 = 141,
  BUTTONS94 = 142,
  BUTTONS95 = 143,
  BUTTONS96 = 144,
  BUTTONS97 = 145,
  BUTTONS98 = 146,
  BUTTONS99 = 147,
  BUTTONS100 = 148,
  BUTTONS101 = 149,
  BUTTONS102 = 150,
  BUTTONS103 = 151,
  BUTTONS104 = 152,
  BUTTONS105 = 153,
  BUTTONS106 = 154,
  BUTTONS107 = 155,
  BUTTONS108 = 156,
  BUTTONS109 = 157,
  BUTTONS110 = 158,
  BUTTONS111 = 159,
  BUTTONS112 = 160,
  BUTTONS113 = 161,
  BUTTONS114 = 162,
  BUTTONS115 = 163,
  BUTTONS116 = 164,
  BUTTONS117 = 165,
  BUTTONS118 = 166,
  BUTTONS119 = 167,
  BUTTONS120 = 168,
  BUTTONS121 = 169,
  BUTTONS122 = 170,
  BUTTONS123 = 171,
  BUTTONS124 = 172,
  BUTTONS125 = 173,
  BUTTONS126 = 174,
  BUTTONS127 = 175,
  VELOCITYX = 176,
  VELOCITYY = 180,
  VELOCITYZ = 184,
  ANGULARVELOCITYX = 188,
  ANGULARVELOCITYY = 192,
  ANGULARVELOCITYZ = 196,
  VELOCITYSLIDERS0 = 200,
  VELOCITYSLIDERS1 = 204,
  ACCELERATIONX = 208,
  ACCELERATIONY = 212,
  ACCELERATIONZ = 216,
  ANGULARACCELERATIONX = 220,
  ANGULARACCELERATIONY = 224,
  ANGULARACCELERATIONZ = 228,
  ACCELERATIONSLIDERS0 = 232,
  ACCELERATIONSLIDERS1 = 236,
  FORCEX = 240,
  FORCEY = 244,
  FORCEZ = 248,
  TORQUEX = 252,
  TORQUEY = 256,
  TORQUEZ = 260,
  FORCESLIDERS0 = 264,
  FORCESLIDERS1 = 268,
}

impl JoystickOffset {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<JoystickOffset> {
    let enum_value = i_prot.read_i32()?;
    JoystickOffset::try_from(enum_value)  }
}

impl TryFrom<i32> for JoystickOffset {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(JoystickOffset::X),
      4 => Ok(JoystickOffset::Y),
      8 => Ok(JoystickOffset::Z),
      12 => Ok(JoystickOffset::ROTATIONX),
      16 => Ok(JoystickOffset::ROTATIONY),
      20 => Ok(JoystickOffset::ROTATIONZ),
      24 => Ok(JoystickOffset::SLIDERS0),
      28 => Ok(JoystickOffset::SLIDERS1),
      32 => Ok(JoystickOffset::POINTOFVIEWCONTROLLERS0),
      36 => Ok(JoystickOffset::POINTOFVIEWCONTROLLERS1),
      40 => Ok(JoystickOffset::POINTOFVIEWCONTROLLERS2),
      44 => Ok(JoystickOffset::POINTOFVIEWCONTROLLERS3),
      48 => Ok(JoystickOffset::BUTTONS0),
      49 => Ok(JoystickOffset::BUTTONS1),
      50 => Ok(JoystickOffset::BUTTONS2),
      51 => Ok(JoystickOffset::BUTTONS3),
      52 => Ok(JoystickOffset::BUTTONS4),
      53 => Ok(JoystickOffset::BUTTONS5),
      54 => Ok(JoystickOffset::BUTTONS6),
      55 => Ok(JoystickOffset::BUTTONS7),
      56 => Ok(JoystickOffset::BUTTONS8),
      57 => Ok(JoystickOffset::BUTTONS9),
      58 => Ok(JoystickOffset::BUTTONS10),
      59 => Ok(JoystickOffset::BUTTONS11),
      60 => Ok(JoystickOffset::BUTTONS12),
      61 => Ok(JoystickOffset::BUTTONS13),
      62 => Ok(JoystickOffset::BUTTONS14),
      63 => Ok(JoystickOffset::BUTTONS15),
      64 => Ok(JoystickOffset::BUTTONS16),
      65 => Ok(JoystickOffset::BUTTONS17),
      66 => Ok(JoystickOffset::BUTTONS18),
      67 => Ok(JoystickOffset::BUTTONS19),
      68 => Ok(JoystickOffset::BUTTONS20),
      69 => Ok(JoystickOffset::BUTTONS21),
      70 => Ok(JoystickOffset::BUTTONS22),
      71 => Ok(JoystickOffset::BUTTONS23),
      72 => Ok(JoystickOffset::BUTTONS24),
      73 => Ok(JoystickOffset::BUTTONS25),
      74 => Ok(JoystickOffset::BUTTONS26),
      75 => Ok(JoystickOffset::BUTTONS27),
      76 => Ok(JoystickOffset::BUTTONS28),
      77 => Ok(JoystickOffset::BUTTONS29),
      78 => Ok(JoystickOffset::BUTTONS30),
      79 => Ok(JoystickOffset::BUTTONS31),
      80 => Ok(JoystickOffset::BUTTONS32),
      81 => Ok(JoystickOffset::BUTTONS33),
      82 => Ok(JoystickOffset::BUTTONS34),
      83 => Ok(JoystickOffset::BUTTONS35),
      84 => Ok(JoystickOffset::BUTTONS36),
      85 => Ok(JoystickOffset::BUTTONS37),
      86 => Ok(JoystickOffset::BUTTONS38),
      87 => Ok(JoystickOffset::BUTTONS39),
      88 => Ok(JoystickOffset::BUTTONS40),
      89 => Ok(JoystickOffset::BUTTONS41),
      90 => Ok(JoystickOffset::BUTTONS42),
      91 => Ok(JoystickOffset::BUTTONS43),
      92 => Ok(JoystickOffset::BUTTONS44),
      93 => Ok(JoystickOffset::BUTTONS45),
      94 => Ok(JoystickOffset::BUTTONS46),
      95 => Ok(JoystickOffset::BUTTONS47),
      96 => Ok(JoystickOffset::BUTTONS48),
      97 => Ok(JoystickOffset::BUTTONS49),
      98 => Ok(JoystickOffset::BUTTONS50),
      99 => Ok(JoystickOffset::BUTTONS51),
      100 => Ok(JoystickOffset::BUTTONS52),
      101 => Ok(JoystickOffset::BUTTONS53),
      102 => Ok(JoystickOffset::BUTTONS54),
      103 => Ok(JoystickOffset::BUTTONS55),
      104 => Ok(JoystickOffset::BUTTONS56),
      105 => Ok(JoystickOffset::BUTTONS57),
      106 => Ok(JoystickOffset::BUTTONS58),
      107 => Ok(JoystickOffset::BUTTONS59),
      108 => Ok(JoystickOffset::BUTTONS60),
      109 => Ok(JoystickOffset::BUTTONS61),
      110 => Ok(JoystickOffset::BUTTONS62),
      111 => Ok(JoystickOffset::BUTTONS63),
      112 => Ok(JoystickOffset::BUTTONS64),
      113 => Ok(JoystickOffset::BUTTONS65),
      114 => Ok(JoystickOffset::BUTTONS66),
      115 => Ok(JoystickOffset::BUTTONS67),
      116 => Ok(JoystickOffset::BUTTONS68),
      117 => Ok(JoystickOffset::BUTTONS69),
      118 => Ok(JoystickOffset::BUTTONS70),
      119 => Ok(JoystickOffset::BUTTONS71),
      120 => Ok(JoystickOffset::BUTTONS72),
      121 => Ok(JoystickOffset::BUTTONS73),
      122 => Ok(JoystickOffset::BUTTONS74),
      123 => Ok(JoystickOffset::BUTTONS75),
      124 => Ok(JoystickOffset::BUTTONS76),
      125 => Ok(JoystickOffset::BUTTONS77),
      126 => Ok(JoystickOffset::BUTTONS78),
      127 => Ok(JoystickOffset::BUTTONS79),
      128 => Ok(JoystickOffset::BUTTONS80),
      129 => Ok(JoystickOffset::BUTTONS81),
      130 => Ok(JoystickOffset::BUTTONS82),
      131 => Ok(JoystickOffset::BUTTONS83),
      132 => Ok(JoystickOffset::BUTTONS84),
      133 => Ok(JoystickOffset::BUTTONS85),
      134 => Ok(JoystickOffset::BUTTONS86),
      135 => Ok(JoystickOffset::BUTTONS87),
      136 => Ok(JoystickOffset::BUTTONS88),
      137 => Ok(JoystickOffset::BUTTONS89),
      138 => Ok(JoystickOffset::BUTTONS90),
      139 => Ok(JoystickOffset::BUTTONS91),
      140 => Ok(JoystickOffset::BUTTONS92),
      141 => Ok(JoystickOffset::BUTTONS93),
      142 => Ok(JoystickOffset::BUTTONS94),
      143 => Ok(JoystickOffset::BUTTONS95),
      144 => Ok(JoystickOffset::BUTTONS96),
      145 => Ok(JoystickOffset::BUTTONS97),
      146 => Ok(JoystickOffset::BUTTONS98),
      147 => Ok(JoystickOffset::BUTTONS99),
      148 => Ok(JoystickOffset::BUTTONS100),
      149 => Ok(JoystickOffset::BUTTONS101),
      150 => Ok(JoystickOffset::BUTTONS102),
      151 => Ok(JoystickOffset::BUTTONS103),
      152 => Ok(JoystickOffset::BUTTONS104),
      153 => Ok(JoystickOffset::BUTTONS105),
      154 => Ok(JoystickOffset::BUTTONS106),
      155 => Ok(JoystickOffset::BUTTONS107),
      156 => Ok(JoystickOffset::BUTTONS108),
      157 => Ok(JoystickOffset::BUTTONS109),
      158 => Ok(JoystickOffset::BUTTONS110),
      159 => Ok(JoystickOffset::BUTTONS111),
      160 => Ok(JoystickOffset::BUTTONS112),
      161 => Ok(JoystickOffset::BUTTONS113),
      162 => Ok(JoystickOffset::BUTTONS114),
      163 => Ok(JoystickOffset::BUTTONS115),
      164 => Ok(JoystickOffset::BUTTONS116),
      165 => Ok(JoystickOffset::BUTTONS117),
      166 => Ok(JoystickOffset::BUTTONS118),
      167 => Ok(JoystickOffset::BUTTONS119),
      168 => Ok(JoystickOffset::BUTTONS120),
      169 => Ok(JoystickOffset::BUTTONS121),
      170 => Ok(JoystickOffset::BUTTONS122),
      171 => Ok(JoystickOffset::BUTTONS123),
      172 => Ok(JoystickOffset::BUTTONS124),
      173 => Ok(JoystickOffset::BUTTONS125),
      174 => Ok(JoystickOffset::BUTTONS126),
      175 => Ok(JoystickOffset::BUTTONS127),
      176 => Ok(JoystickOffset::VELOCITYX),
      180 => Ok(JoystickOffset::VELOCITYY),
      184 => Ok(JoystickOffset::VELOCITYZ),
      188 => Ok(JoystickOffset::ANGULARVELOCITYX),
      192 => Ok(JoystickOffset::ANGULARVELOCITYY),
      196 => Ok(JoystickOffset::ANGULARVELOCITYZ),
      200 => Ok(JoystickOffset::VELOCITYSLIDERS0),
      204 => Ok(JoystickOffset::VELOCITYSLIDERS1),
      208 => Ok(JoystickOffset::ACCELERATIONX),
      212 => Ok(JoystickOffset::ACCELERATIONY),
      216 => Ok(JoystickOffset::ACCELERATIONZ),
      220 => Ok(JoystickOffset::ANGULARACCELERATIONX),
      224 => Ok(JoystickOffset::ANGULARACCELERATIONY),
      228 => Ok(JoystickOffset::ANGULARACCELERATIONZ),
      232 => Ok(JoystickOffset::ACCELERATIONSLIDERS0),
      236 => Ok(JoystickOffset::ACCELERATIONSLIDERS1),
      240 => Ok(JoystickOffset::FORCEX),
      244 => Ok(JoystickOffset::FORCEY),
      248 => Ok(JoystickOffset::FORCEZ),
      252 => Ok(JoystickOffset::TORQUEX),
      256 => Ok(JoystickOffset::TORQUEY),
      260 => Ok(JoystickOffset::TORQUEZ),
      264 => Ok(JoystickOffset::FORCESLIDERS0),
      268 => Ok(JoystickOffset::FORCESLIDERS1),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to JoystickOffset", i)
            )
          )
        )
      },
    }
  }
}

pub type _float = OrderedFloat<f64>;

//
// RuyiGamePadInput
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiGamePadInput {
  pub device_id: Option<String>,
  pub user_id: Option<String>,
  /// Combination of RuyiGamePadButtonFlags
  pub button_flags: Option<i32>,
  pub left_trigger: Option<i8>,
  pub right_trigger: Option<i8>,
  pub left_thumb_x: Option<i16>,
  pub left_thumb_y: Option<i16>,
  pub right_thumb_x: Option<i16>,
  pub right_thumb_y: Option<i16>,
}

impl RuyiGamePadInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(device_id: F1, user_id: F2, button_flags: F3, left_trigger: F4, right_trigger: F5, left_thumb_x: F6, left_thumb_y: F7, right_thumb_x: F8, right_thumb_y: F9) -> RuyiGamePadInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i8>>, F5: Into<Option<i8>>, F6: Into<Option<i16>>, F7: Into<Option<i16>>, F8: Into<Option<i16>>, F9: Into<Option<i16>> {
    RuyiGamePadInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      button_flags: button_flags.into(),
      left_trigger: left_trigger.into(),
      right_trigger: right_trigger.into(),
      left_thumb_x: left_thumb_x.into(),
      left_thumb_y: left_thumb_y.into(),
      right_thumb_x: right_thumb_x.into(),
      right_thumb_y: right_thumb_y.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiGamePadInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i8> = Some(0);
    let mut f_5: Option<i8> = Some(0);
    let mut f_6: Option<i16> = Some(0);
    let mut f_7: Option<i16> = Some(0);
    let mut f_8: Option<i16> = Some(0);
    let mut f_9: Option<i16> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i8()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i8()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i16()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i16()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i16()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i16()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiGamePadInput {
      device_id: f_1,
      user_id: f_2,
      button_flags: f_3,
      left_trigger: f_4,
      right_trigger: f_5,
      left_thumb_x: f_6,
      left_thumb_y: f_7,
      right_thumb_x: f_8,
      right_thumb_y: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiGamePadInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.button_flags {
      o_prot.write_field_begin(&TFieldIdentifier::new("ButtonFlags", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.left_trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("LeftTrigger", TType::I08, 4))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.right_trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("RightTrigger", TType::I08, 5))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.left_thumb_x {
      o_prot.write_field_begin(&TFieldIdentifier::new("LeftThumbX", TType::I16, 6))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.left_thumb_y {
      o_prot.write_field_begin(&TFieldIdentifier::new("LeftThumbY", TType::I16, 7))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.right_thumb_x {
      o_prot.write_field_begin(&TFieldIdentifier::new("RightThumbX", TType::I16, 8))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.right_thumb_y {
      o_prot.write_field_begin(&TFieldIdentifier::new("RightThumbY", TType::I16, 9))?;
      o_prot.write_i16(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiGamePadInput {
  fn default() -> Self {
    RuyiGamePadInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      button_flags: Some(0),
      left_trigger: Some(0),
      right_trigger: Some(0),
      left_thumb_x: Some(0),
      left_thumb_y: Some(0),
      right_thumb_x: Some(0),
      right_thumb_y: Some(0),
    }
  }
}

//
// RuyiKeyboardInput
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiKeyboardInput {
  pub device_id: Option<String>,
  pub user_id: Option<String>,
  pub raw_offset: Option<i32>,
  pub value: Option<i32>,
  pub timestamp: Option<i32>,
  pub sequence: Option<i32>,
  pub key: Option<Key>,
  pub is_pressed: Option<bool>,
  pub is_released: Option<bool>,
}

impl RuyiKeyboardInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(device_id: F1, user_id: F2, raw_offset: F3, value: F4, timestamp: F5, sequence: F6, key: F7, is_pressed: F8, is_released: F9) -> RuyiKeyboardInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<Key>>, F8: Into<Option<bool>>, F9: Into<Option<bool>> {
    RuyiKeyboardInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      raw_offset: raw_offset.into(),
      value: value.into(),
      timestamp: timestamp.into(),
      sequence: sequence.into(),
      key: key.into(),
      is_pressed: is_pressed.into(),
      is_released: is_released.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiKeyboardInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<Key> = None;
    let mut f_8: Option<bool> = Some(false);
    let mut f_9: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = Key::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiKeyboardInput {
      device_id: f_1,
      user_id: f_2,
      raw_offset: f_3,
      value: f_4,
      timestamp: f_5,
      sequence: f_6,
      key: f_7,
      is_pressed: f_8,
      is_released: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiKeyboardInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.raw_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("RawOffset", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("Timestamp", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("Sequence", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("Key", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_pressed {
      o_prot.write_field_begin(&TFieldIdentifier::new("IsPressed", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_released {
      o_prot.write_field_begin(&TFieldIdentifier::new("IsReleased", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiKeyboardInput {
  fn default() -> Self {
    RuyiKeyboardInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      raw_offset: Some(0),
      value: Some(0),
      timestamp: Some(0),
      sequence: Some(0),
      key: None,
      is_pressed: Some(false),
      is_released: Some(false),
    }
  }
}

//
// RuyiMouseInput
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiMouseInput {
  pub device_id: Option<String>,
  pub user_id: Option<String>,
  pub raw_offset: Option<i32>,
  pub value: Option<i32>,
  pub timestamp: Option<i32>,
  pub sequence: Option<i32>,
  pub offset: Option<MouseOffset>,
  pub is_button: Option<bool>,
}

impl RuyiMouseInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(device_id: F1, user_id: F2, raw_offset: F3, value: F4, timestamp: F5, sequence: F6, offset: F7, is_button: F8) -> RuyiMouseInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<MouseOffset>>, F8: Into<Option<bool>> {
    RuyiMouseInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      raw_offset: raw_offset.into(),
      value: value.into(),
      timestamp: timestamp.into(),
      sequence: sequence.into(),
      offset: offset.into(),
      is_button: is_button.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiMouseInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<MouseOffset> = None;
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = MouseOffset::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiMouseInput {
      device_id: f_1,
      user_id: f_2,
      raw_offset: f_3,
      value: f_4,
      timestamp: f_5,
      sequence: f_6,
      offset: f_7,
      is_button: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiMouseInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.raw_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("RawOffset", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("Timestamp", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("Sequence", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("Offset", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_button {
      o_prot.write_field_begin(&TFieldIdentifier::new("IsButton", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiMouseInput {
  fn default() -> Self {
    RuyiMouseInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      raw_offset: Some(0),
      value: Some(0),
      timestamp: Some(0),
      sequence: Some(0),
      offset: None,
      is_button: Some(false),
    }
  }
}

//
// RuyiJoystickInput
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiJoystickInput {
  pub device_id: Option<String>,
  pub user_id: Option<String>,
  pub raw_offset: Option<i32>,
  pub value: Option<i32>,
  pub timestamp: Option<i32>,
  pub sequence: Option<i32>,
  pub offset: Option<JoystickOffset>,
}

impl RuyiJoystickInput {
  pub fn new<F1, F2, F3, F4, F5, F6, F7>(device_id: F1, user_id: F2, raw_offset: F3, value: F4, timestamp: F5, sequence: F6, offset: F7) -> RuyiJoystickInput where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<i32>>, F5: Into<Option<i32>>, F6: Into<Option<i32>>, F7: Into<Option<JoystickOffset>> {
    RuyiJoystickInput {
      device_id: device_id.into(),
      user_id: user_id.into(),
      raw_offset: raw_offset.into(),
      value: value.into(),
      timestamp: timestamp.into(),
      sequence: sequence.into(),
      offset: offset.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiJoystickInput> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<i32> = Some(0);
    let mut f_5: Option<i32> = Some(0);
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<JoystickOffset> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = JoystickOffset::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiJoystickInput {
      device_id: f_1,
      user_id: f_2,
      raw_offset: f_3,
      value: f_4,
      timestamp: f_5,
      sequence: f_6,
      offset: f_7,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiJoystickInput");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("UserId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.raw_offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("RawOffset", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("Value", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("Timestamp", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sequence {
      o_prot.write_field_begin(&TFieldIdentifier::new("Sequence", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.offset {
      o_prot.write_field_begin(&TFieldIdentifier::new("Offset", TType::I32, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiJoystickInput {
  fn default() -> Self {
    RuyiJoystickInput{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      raw_offset: Some(0),
      value: Some(0),
      timestamp: Some(0),
      sequence: Some(0),
      offset: None,
    }
  }
}

//
// InputActionTriggered
//

/// Action triggered by digital input device ( buttons on gamepad or key on key board )
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InputActionTriggered {
  /// The device id
  pub device_id: Option<String>,
  /// The id of user whome is bound to the device
  pub user_id: Option<String>,
  /// The name of the action
  pub name: Option<String>,
  /// The time the action is triggered
  pub timestamp: Option<i64>,
  /// The device's state when trggering the action
  pub trigger: Option<common_type_s_d_k_data_types::ActionTrigger>,
}

impl InputActionTriggered {
  pub fn new<F1, F2, F3, F4, F5>(device_id: F1, user_id: F2, name: F3, timestamp: F4, trigger: F5) -> InputActionTriggered where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i64>>, F5: Into<Option<common_type_s_d_k_data_types::ActionTrigger>> {
    InputActionTriggered {
      device_id: device_id.into(),
      user_id: user_id.into(),
      name: name.into(),
      timestamp: timestamp.into(),
      trigger: trigger.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputActionTriggered> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<common_type_s_d_k_data_types::ActionTrigger> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = common_type_s_d_k_data_types::ActionTrigger::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InputActionTriggered {
      device_id: f_1,
      user_id: f_2,
      name: f_3,
      timestamp: f_4,
      trigger: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InputActionTriggered");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.trigger {
      o_prot.write_field_begin(&TFieldIdentifier::new("trigger", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InputActionTriggered {
  fn default() -> Self {
    InputActionTriggered{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      name: Some("".to_owned()),
      timestamp: Some(0),
      trigger: None,
    }
  }
}

//
// AxisActionTriggered
//

/// Action triggered by analog input device ( the thumbs or triggers on gamepad )
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AxisActionTriggered {
  /// The device id
  pub device_id: Option<String>,
  /// The id of user whome is bound to the device
  pub user_id: Option<String>,
  /// The name of the action
  pub name: Option<String>,
  /// The time the action is triggered
  pub timestamp: Option<i64>,
  /// The scale of the action
  pub scale: Option<_float>,
}

impl AxisActionTriggered {
  pub fn new<F1, F2, F3, F4, F5>(device_id: F1, user_id: F2, name: F3, timestamp: F4, scale: F5) -> AxisActionTriggered where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<i64>>, F5: Into<Option<_float>> {
    AxisActionTriggered {
      device_id: device_id.into(),
      user_id: user_id.into(),
      name: name.into(),
      timestamp: timestamp.into(),
      scale: scale.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AxisActionTriggered> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<i64> = Some(0);
    let mut f_5: Option<_float> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AxisActionTriggered {
      device_id: f_1,
      user_id: f_2,
      name: f_3,
      timestamp: f_4,
      scale: f_5,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AxisActionTriggered");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 4))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("scale", TType::Double, 5))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AxisActionTriggered {
  fn default() -> Self {
    AxisActionTriggered{
      device_id: Some("".to_owned()),
      user_id: Some("".to_owned()),
      name: Some("".to_owned()),
      timestamp: Some(0),
      scale: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// GamepadInfo
//

/// Gamepad's information
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct GamepadInfo {
  /// The device id of the gamepad
  pub device_id: Option<String>,
  /// Whether the device is wirelessly connected
  pub is_wireless: Option<bool>,
}

impl GamepadInfo {
  pub fn new<F1, F2>(device_id: F1, is_wireless: F2) -> GamepadInfo where F1: Into<Option<String>>, F2: Into<Option<bool>> {
    GamepadInfo {
      device_id: device_id.into(),
      is_wireless: is_wireless.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GamepadInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GamepadInfo {
      device_id: f_1,
      is_wireless: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GamepadInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.device_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("deviceId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_wireless {
      o_prot.write_field_begin(&TFieldIdentifier::new("isWireless", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for GamepadInfo {
  fn default() -> Self {
    GamepadInfo{
      device_id: Some("".to_owned()),
      is_wireless: Some(false),
    }
  }
}

