// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use common_type_s_d_k_data_types;
use setting_system_s_d_k_data_types;

//
// SettingSystemService service client
//

pub trait TSettingSystemServiceSyncClient {
  /// Get a setting data of the module.
  fn get_setting_item(&mut self, id: String) -> thrift::Result<common_type_s_d_k_data_types::SettingItem>;
  /// Get a list of setting data of the module.
  fn get_setting_items(&mut self, category: String, include_children: bool) -> thrift::Result<Vec<common_type_s_d_k_data_types::SettingItem>>;
  /// Search a set of settings using a json format string.
  /// According to the format of json string your write, searching can be separated to 3 types: simple search, lambda search and complicated search. And each of they can be combined with the other.
  fn search_setting_items(&mut self, filter_json: String) -> thrift::Result<BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult>>;
  /// Get settings and categories in a tree
  fn get_category_node(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::SettingTree>;
  /// Get child nodes of specified setting item or setting category
  fn get_child_node(&mut self, parent: String, node_type: setting_system_s_d_k_data_types::NodeType, param: String) -> thrift::Result<setting_system_s_d_k_data_types::NodeList>;
  /// Set the specified setting's "dataValue" with the new value
  fn set_setting_item(&mut self, key: String, val: String) -> thrift::Result<bool>;
  /// Set a set of settings' "dataValue"
  fn set_setting_items(&mut self, key_values: BTreeMap<String, String>) -> thrift::Result<i32>;
  /// Restore a module setting to default
  fn restore_default(&mut self, module_name: String, category: String) -> thrift::Result<bool>;
  fn restore_user_default(&mut self, user_id: String, module_name: String, category: String) -> thrift::Result<bool>;
  /// Update the module settings from an older version to the latest one
  fn update_module_version(&mut self, module_name: String) -> thrift::Result<bool>;
  fn set_user_app_data(&mut self, user_id: String, category: String, setting_items: BTreeMap<String, common_type_s_d_k_data_types::SettingValue>) -> thrift::Result<i32>;
  fn get_user_app_data(&mut self, user_id: String, category: String, setting_keys: Vec<String>) -> thrift::Result<common_type_s_d_k_data_types::AppData>;
  fn remove_user_app_data(&mut self, user_id: String, category: String, setting_keys: Vec<String>) -> thrift::Result<i32>;
  /// Notify layer0 that a setting item has specific event
  fn setting_item_notify(&mut self, key: String, contents: setting_system_s_d_k_data_types::JSON) -> thrift::Result<bool>;
  fn get_network_adapter_settings(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::NetworkSettings>;
  fn get_lan_network_name(&mut self) -> thrift::Result<String>;
  fn set_network_settings(&mut self, is_w_lan: bool, enable_d_h_c_p: bool, ip_address: String, sub_mask: String, gateway: String, main_d_n_s: String, sub_d_n_s: String) -> thrift::Result<bool>;
  fn set_network_proxy(&mut self, proxy_server: String, proxy_port: String) -> thrift::Result<bool>;
  fn connect_to_wifi(&mut self, profile_name: String, key: String) -> thrift::Result<bool>;
  fn connect_to_appointed_wifi(&mut self, profile_name: String, auth: String, ciper: String, key_type: String, key: String) -> thrift::Result<bool>;
  fn get_network_settings(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkSettings>;
  fn get_network_status(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkStatus>;
  fn ruyi_test_network(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkTestResult>;
  fn ruyi_start_network_speed_test(&mut self, userindex: i32) -> thrift::Result<bool>;
  fn ruyi_stop_network_speed_test(&mut self, userindex: i32) -> thrift::Result<bool>;
  fn get_available_wifi(&mut self) -> thrift::Result<Vec<setting_system_s_d_k_data_types::WifiEntity>>;
  fn disconnect_wifi(&mut self) -> thrift::Result<bool>;
  fn discover_bluetooth_device(&mut self) -> thrift::Result<bool>;
  fn connect_bluetooth_device(&mut self, device_name: String, device_address: String) -> thrift::Result<bool>;
  fn disconnect_bluetooth_device(&mut self, device_name: String, device_address: String) -> thrift::Result<bool>;
  fn remove_bluetooth_device(&mut self, device_name: String, device_address: String) -> thrift::Result<bool>;
}

pub trait TSettingSystemServiceSyncClientMarker {}

pub struct SettingSystemServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> SettingSystemServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> SettingSystemServiceSyncClient<IP, OP> {
    SettingSystemServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for SettingSystemServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TSettingSystemServiceSyncClientMarker for SettingSystemServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TSettingSystemServiceSyncClientMarker> TSettingSystemServiceSyncClient for C {
  fn get_setting_item(&mut self, id: String) -> thrift::Result<common_type_s_d_k_data_types::SettingItem> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetSettingItem", TMessageType::Call, self.sequence_number());
        let call_args = GetSettingItemArgs { id: id };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetSettingItem", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetSettingItemResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_setting_items(&mut self, category: String, include_children: bool) -> thrift::Result<Vec<common_type_s_d_k_data_types::SettingItem>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetSettingItems", TMessageType::Call, self.sequence_number());
        let call_args = GetSettingItemsArgs { category: category, include_children: include_children };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetSettingItems", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetSettingItemsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn search_setting_items(&mut self, filter_json: String) -> thrift::Result<BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SearchSettingItems", TMessageType::Call, self.sequence_number());
        let call_args = SearchSettingItemsArgs { filter_json: filter_json };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SearchSettingItems", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SearchSettingItemsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_category_node(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::SettingTree> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetCategoryNode", TMessageType::Call, self.sequence_number());
        let call_args = GetCategoryNodeArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetCategoryNode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetCategoryNodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_child_node(&mut self, parent: String, node_type: setting_system_s_d_k_data_types::NodeType, param: String) -> thrift::Result<setting_system_s_d_k_data_types::NodeList> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetChildNode", TMessageType::Call, self.sequence_number());
        let call_args = GetChildNodeArgs { parent: parent, node_type: node_type, param: param };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetChildNode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetChildNodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_setting_item(&mut self, key: String, val: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SetSettingItem", TMessageType::Call, self.sequence_number());
        let call_args = SetSettingItemArgs { key: key, val: val };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SetSettingItem", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SetSettingItemResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_setting_items(&mut self, key_values: BTreeMap<String, String>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SetSettingItems", TMessageType::Call, self.sequence_number());
        let call_args = SetSettingItemsArgs { key_values: key_values };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SetSettingItems", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SetSettingItemsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn restore_default(&mut self, module_name: String, category: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RestoreDefault", TMessageType::Call, self.sequence_number());
        let call_args = RestoreDefaultArgs { module_name: module_name, category: category };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RestoreDefault", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RestoreDefaultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn restore_user_default(&mut self, user_id: String, module_name: String, category: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RestoreUserDefault", TMessageType::Call, self.sequence_number());
        let call_args = RestoreUserDefaultArgs { user_id: user_id, module_name: module_name, category: category };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RestoreUserDefault", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RestoreUserDefaultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn update_module_version(&mut self, module_name: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("UpdateModuleVersion", TMessageType::Call, self.sequence_number());
        let call_args = UpdateModuleVersionArgs { module_name: module_name };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("UpdateModuleVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = UpdateModuleVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_user_app_data(&mut self, user_id: String, category: String, setting_items: BTreeMap<String, common_type_s_d_k_data_types::SettingValue>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SetUserAppData", TMessageType::Call, self.sequence_number());
        let call_args = SetUserAppDataArgs { user_id: user_id, category: category, setting_items: setting_items };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SetUserAppData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SetUserAppDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_user_app_data(&mut self, user_id: String, category: String, setting_keys: Vec<String>) -> thrift::Result<common_type_s_d_k_data_types::AppData> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetUserAppData", TMessageType::Call, self.sequence_number());
        let call_args = GetUserAppDataArgs { user_id: user_id, category: category, setting_keys: setting_keys };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetUserAppData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetUserAppDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_user_app_data(&mut self, user_id: String, category: String, setting_keys: Vec<String>) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RemoveUserAppData", TMessageType::Call, self.sequence_number());
        let call_args = RemoveUserAppDataArgs { user_id: user_id, category: category, setting_keys: setting_keys };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RemoveUserAppData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RemoveUserAppDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn setting_item_notify(&mut self, key: String, contents: setting_system_s_d_k_data_types::JSON) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SettingItemNotify", TMessageType::Call, self.sequence_number());
        let call_args = SettingItemNotifyArgs { key: key, contents: contents };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SettingItemNotify", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SettingItemNotifyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_network_adapter_settings(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::NetworkSettings> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetNetworkAdapterSettings", TMessageType::Call, self.sequence_number());
        let call_args = GetNetworkAdapterSettingsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetNetworkAdapterSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetNetworkAdapterSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_lan_network_name(&mut self) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetLanNetworkName", TMessageType::Call, self.sequence_number());
        let call_args = GetLanNetworkNameArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetLanNetworkName", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetLanNetworkNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_network_settings(&mut self, is_w_lan: bool, enable_d_h_c_p: bool, ip_address: String, sub_mask: String, gateway: String, main_d_n_s: String, sub_d_n_s: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SetNetworkSettings", TMessageType::Call, self.sequence_number());
        let call_args = SetNetworkSettingsArgs { is_w_lan: is_w_lan, enable_d_h_c_p: enable_d_h_c_p, ip_address: ip_address, sub_mask: sub_mask, gateway: gateway, main_d_n_s: main_d_n_s, sub_d_n_s: sub_d_n_s };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SetNetworkSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SetNetworkSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn set_network_proxy(&mut self, proxy_server: String, proxy_port: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SetNetworkProxy", TMessageType::Call, self.sequence_number());
        let call_args = SetNetworkProxyArgs { proxy_server: proxy_server, proxy_port: proxy_port };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SetNetworkProxy", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = SetNetworkProxyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connect_to_wifi(&mut self, profile_name: String, key: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ConnectToWifi", TMessageType::Call, self.sequence_number());
        let call_args = ConnectToWifiArgs { profile_name: profile_name, key: key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ConnectToWifi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ConnectToWifiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connect_to_appointed_wifi(&mut self, profile_name: String, auth: String, ciper: String, key_type: String, key: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ConnectToAppointedWifi", TMessageType::Call, self.sequence_number());
        let call_args = ConnectToAppointedWifiArgs { profile_name: profile_name, auth: auth, ciper: ciper, key_type: key_type, key: key };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ConnectToAppointedWifi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ConnectToAppointedWifiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_network_settings(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkSettings> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetNetworkSettings", TMessageType::Call, self.sequence_number());
        let call_args = GetNetworkSettingsArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetNetworkSettings", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetNetworkSettingsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_network_status(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkStatus> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetNetworkStatus", TMessageType::Call, self.sequence_number());
        let call_args = GetNetworkStatusArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetNetworkStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetNetworkStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn ruyi_test_network(&mut self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkTestResult> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RuyiTestNetwork", TMessageType::Call, self.sequence_number());
        let call_args = RuyiTestNetworkArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RuyiTestNetwork", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RuyiTestNetworkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn ruyi_start_network_speed_test(&mut self, userindex: i32) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RuyiStartNetworkSpeedTest", TMessageType::Call, self.sequence_number());
        let call_args = RuyiStartNetworkSpeedTestArgs { userindex: userindex };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RuyiStartNetworkSpeedTest", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RuyiStartNetworkSpeedTestResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn ruyi_stop_network_speed_test(&mut self, userindex: i32) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RuyiStopNetworkSpeedTest", TMessageType::Call, self.sequence_number());
        let call_args = RuyiStopNetworkSpeedTestArgs { userindex: userindex };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RuyiStopNetworkSpeedTest", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RuyiStopNetworkSpeedTestResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn get_available_wifi(&mut self) -> thrift::Result<Vec<setting_system_s_d_k_data_types::WifiEntity>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GetAvailableWifi", TMessageType::Call, self.sequence_number());
        let call_args = GetAvailableWifiArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GetAvailableWifi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = GetAvailableWifiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn disconnect_wifi(&mut self) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DisconnectWifi", TMessageType::Call, self.sequence_number());
        let call_args = DisconnectWifiArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DisconnectWifi", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DisconnectWifiResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn discover_bluetooth_device(&mut self) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DiscoverBluetoothDevice", TMessageType::Call, self.sequence_number());
        let call_args = DiscoverBluetoothDeviceArgs {  };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DiscoverBluetoothDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DiscoverBluetoothDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn connect_bluetooth_device(&mut self, device_name: String, device_address: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("ConnectBluetoothDevice", TMessageType::Call, self.sequence_number());
        let call_args = ConnectBluetoothDeviceArgs { device_name: device_name, device_address: device_address };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("ConnectBluetoothDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = ConnectBluetoothDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn disconnect_bluetooth_device(&mut self, device_name: String, device_address: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DisconnectBluetoothDevice", TMessageType::Call, self.sequence_number());
        let call_args = DisconnectBluetoothDeviceArgs { device_name: device_name, device_address: device_address };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DisconnectBluetoothDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = DisconnectBluetoothDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn remove_bluetooth_device(&mut self, device_name: String, device_address: String) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("RemoveBluetoothDevice", TMessageType::Call, self.sequence_number());
        let call_args = RemoveBluetoothDeviceArgs { device_name: device_name, device_address: device_address };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("RemoveBluetoothDevice", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = RemoveBluetoothDeviceResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// SettingSystemService service processor
//

pub trait SettingSystemServiceSyncHandler {
  /// Get a setting data of the module.
  fn handle_get_setting_item(&self, id: String) -> thrift::Result<common_type_s_d_k_data_types::SettingItem>;
  /// Get a list of setting data of the module.
  fn handle_get_setting_items(&self, category: String, include_children: bool) -> thrift::Result<Vec<common_type_s_d_k_data_types::SettingItem>>;
  /// Search a set of settings using a json format string.
  /// According to the format of json string your write, searching can be separated to 3 types: simple search, lambda search and complicated search. And each of they can be combined with the other.
  fn handle_search_setting_items(&self, filter_json: String) -> thrift::Result<BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult>>;
  /// Get settings and categories in a tree
  fn handle_get_category_node(&self) -> thrift::Result<setting_system_s_d_k_data_types::SettingTree>;
  /// Get child nodes of specified setting item or setting category
  fn handle_get_child_node(&self, parent: String, node_type: setting_system_s_d_k_data_types::NodeType, param: String) -> thrift::Result<setting_system_s_d_k_data_types::NodeList>;
  /// Set the specified setting's "dataValue" with the new value
  fn handle_set_setting_item(&self, key: String, val: String) -> thrift::Result<bool>;
  /// Set a set of settings' "dataValue"
  fn handle_set_setting_items(&self, key_values: BTreeMap<String, String>) -> thrift::Result<i32>;
  /// Restore a module setting to default
  fn handle_restore_default(&self, module_name: String, category: String) -> thrift::Result<bool>;
  fn handle_restore_user_default(&self, user_id: String, module_name: String, category: String) -> thrift::Result<bool>;
  /// Update the module settings from an older version to the latest one
  fn handle_update_module_version(&self, module_name: String) -> thrift::Result<bool>;
  fn handle_set_user_app_data(&self, user_id: String, category: String, setting_items: BTreeMap<String, common_type_s_d_k_data_types::SettingValue>) -> thrift::Result<i32>;
  fn handle_get_user_app_data(&self, user_id: String, category: String, setting_keys: Vec<String>) -> thrift::Result<common_type_s_d_k_data_types::AppData>;
  fn handle_remove_user_app_data(&self, user_id: String, category: String, setting_keys: Vec<String>) -> thrift::Result<i32>;
  /// Notify layer0 that a setting item has specific event
  fn handle_setting_item_notify(&self, key: String, contents: setting_system_s_d_k_data_types::JSON) -> thrift::Result<bool>;
  fn handle_get_network_adapter_settings(&self) -> thrift::Result<setting_system_s_d_k_data_types::NetworkSettings>;
  fn handle_get_lan_network_name(&self) -> thrift::Result<String>;
  fn handle_set_network_settings(&self, is_w_lan: bool, enable_d_h_c_p: bool, ip_address: String, sub_mask: String, gateway: String, main_d_n_s: String, sub_d_n_s: String) -> thrift::Result<bool>;
  fn handle_set_network_proxy(&self, proxy_server: String, proxy_port: String) -> thrift::Result<bool>;
  fn handle_connect_to_wifi(&self, profile_name: String, key: String) -> thrift::Result<bool>;
  fn handle_connect_to_appointed_wifi(&self, profile_name: String, auth: String, ciper: String, key_type: String, key: String) -> thrift::Result<bool>;
  fn handle_get_network_settings(&self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkSettings>;
  fn handle_get_network_status(&self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkStatus>;
  fn handle_ruyi_test_network(&self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkTestResult>;
  fn handle_ruyi_start_network_speed_test(&self, userindex: i32) -> thrift::Result<bool>;
  fn handle_ruyi_stop_network_speed_test(&self, userindex: i32) -> thrift::Result<bool>;
  fn handle_get_available_wifi(&self) -> thrift::Result<Vec<setting_system_s_d_k_data_types::WifiEntity>>;
  fn handle_disconnect_wifi(&self) -> thrift::Result<bool>;
  fn handle_discover_bluetooth_device(&self) -> thrift::Result<bool>;
  fn handle_connect_bluetooth_device(&self, device_name: String, device_address: String) -> thrift::Result<bool>;
  fn handle_disconnect_bluetooth_device(&self, device_name: String, device_address: String) -> thrift::Result<bool>;
  fn handle_remove_bluetooth_device(&self, device_name: String, device_address: String) -> thrift::Result<bool>;
}

pub struct SettingSystemServiceSyncProcessor<H: SettingSystemServiceSyncHandler> {
  handler: H,
}

impl <H: SettingSystemServiceSyncHandler> SettingSystemServiceSyncProcessor<H> {
  pub fn new(handler: H) -> SettingSystemServiceSyncProcessor<H> {
    SettingSystemServiceSyncProcessor {
      handler: handler,
    }
  }
  fn process_get_setting_item(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_setting_item(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_setting_items(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_setting_items(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_search_setting_items(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_search_setting_items(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_category_node(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_category_node(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_child_node(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_child_node(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_setting_item(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_set_setting_item(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_setting_items(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_set_setting_items(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_restore_default(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_restore_default(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_restore_user_default(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_restore_user_default(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_update_module_version(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_update_module_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_user_app_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_set_user_app_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_user_app_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_user_app_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_user_app_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_remove_user_app_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_setting_item_notify(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_setting_item_notify(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_network_adapter_settings(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_network_adapter_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_lan_network_name(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_lan_network_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_network_settings(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_set_network_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_set_network_proxy(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_set_network_proxy(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connect_to_wifi(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_connect_to_wifi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connect_to_appointed_wifi(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_connect_to_appointed_wifi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_network_settings(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_network_settings(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_network_status(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_network_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_ruyi_test_network(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_ruyi_test_network(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_ruyi_start_network_speed_test(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_ruyi_start_network_speed_test(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_ruyi_stop_network_speed_test(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_ruyi_stop_network_speed_test(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_get_available_wifi(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_get_available_wifi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_disconnect_wifi(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_disconnect_wifi(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_discover_bluetooth_device(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_discover_bluetooth_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_connect_bluetooth_device(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_connect_bluetooth_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_disconnect_bluetooth_device(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_disconnect_bluetooth_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_remove_bluetooth_device(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TSettingSystemServiceProcessFunctions::process_remove_bluetooth_device(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TSettingSystemServiceProcessFunctions;

impl TSettingSystemServiceProcessFunctions {
  pub fn process_get_setting_item<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = GetSettingItemArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_setting_item(args.id) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetSettingItem", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetSettingItemResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetSettingItemResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetSettingItem", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetSettingItem", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetSettingItem", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetSettingItem", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_setting_items<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = GetSettingItemsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_setting_items(args.category, args.include_children) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetSettingItems", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetSettingItemsResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetSettingItemsResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetSettingItems", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetSettingItems", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetSettingItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetSettingItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_search_setting_items<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SearchSettingItemsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_search_setting_items(args.filter_json) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SearchSettingItems", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SearchSettingItemsResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = SearchSettingItemsResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("SearchSettingItems", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("SearchSettingItems", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SearchSettingItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SearchSettingItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_category_node<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = GetCategoryNodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_category_node() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetCategoryNode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetCategoryNodeResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetCategoryNodeResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetCategoryNode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetCategoryNode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetCategoryNode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetCategoryNode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_child_node<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = GetChildNodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_child_node(args.parent, args.node_type, args.param) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetChildNode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetChildNodeResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetChildNodeResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetChildNode", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetChildNode", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetChildNode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetChildNode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_setting_item<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SetSettingItemArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_setting_item(args.key, args.val) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SetSettingItem", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SetSettingItemResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = SetSettingItemResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("SetSettingItem", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("SetSettingItem", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SetSettingItem", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SetSettingItem", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_setting_items<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SetSettingItemsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_setting_items(args.key_values) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SetSettingItems", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SetSettingItemsResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = SetSettingItemsResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("SetSettingItems", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("SetSettingItems", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SetSettingItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SetSettingItems", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_restore_default<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = RestoreDefaultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_restore_default(args.module_name, args.category) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RestoreDefault", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RestoreDefaultResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RestoreDefaultResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RestoreDefault", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RestoreDefault", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RestoreDefault", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RestoreDefault", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_restore_user_default<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = RestoreUserDefaultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_restore_user_default(args.user_id, args.module_name, args.category) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RestoreUserDefault", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RestoreUserDefaultResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RestoreUserDefaultResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RestoreUserDefault", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RestoreUserDefault", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RestoreUserDefault", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RestoreUserDefault", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_update_module_version<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = UpdateModuleVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_update_module_version(args.module_name) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("UpdateModuleVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = UpdateModuleVersionResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = UpdateModuleVersionResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("UpdateModuleVersion", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("UpdateModuleVersion", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("UpdateModuleVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("UpdateModuleVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_user_app_data<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SetUserAppDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_user_app_data(args.user_id, args.category, args.setting_items) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SetUserAppData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SetUserAppDataResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = SetUserAppDataResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("SetUserAppData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("SetUserAppData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SetUserAppData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SetUserAppData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_user_app_data<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = GetUserAppDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_user_app_data(args.user_id, args.category, args.setting_keys) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetUserAppData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetUserAppDataResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetUserAppDataResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetUserAppData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetUserAppData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetUserAppData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetUserAppData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_user_app_data<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = RemoveUserAppDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_user_app_data(args.user_id, args.category, args.setting_keys) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RemoveUserAppData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RemoveUserAppDataResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RemoveUserAppDataResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RemoveUserAppData", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RemoveUserAppData", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RemoveUserAppData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RemoveUserAppData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_setting_item_notify<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SettingItemNotifyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_setting_item_notify(args.key, args.contents) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SettingItemNotify", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SettingItemNotifyResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = SettingItemNotifyResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("SettingItemNotify", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("SettingItemNotify", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SettingItemNotify", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SettingItemNotify", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_network_adapter_settings<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = GetNetworkAdapterSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_network_adapter_settings() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetNetworkAdapterSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetNetworkAdapterSettingsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetNetworkAdapterSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetNetworkAdapterSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_lan_network_name<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = GetLanNetworkNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_lan_network_name() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetLanNetworkName", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetLanNetworkNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetLanNetworkName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetLanNetworkName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_network_settings<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SetNetworkSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_network_settings(args.is_w_lan, args.enable_d_h_c_p, args.ip_address, args.sub_mask, args.gateway, args.main_d_n_s, args.sub_d_n_s) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SetNetworkSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SetNetworkSettingsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SetNetworkSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SetNetworkSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_set_network_proxy<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = SetNetworkProxyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_set_network_proxy(args.proxy_server, args.proxy_port) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SetNetworkProxy", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = SetNetworkProxyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SetNetworkProxy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SetNetworkProxy", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connect_to_wifi<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = ConnectToWifiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connect_to_wifi(args.profile_name, args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ConnectToWifi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ConnectToWifiResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = ConnectToWifiResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("ConnectToWifi", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("ConnectToWifi", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ConnectToWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("ConnectToWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connect_to_appointed_wifi<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = ConnectToAppointedWifiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connect_to_appointed_wifi(args.profile_name, args.auth, args.ciper, args.key_type, args.key) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ConnectToAppointedWifi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ConnectToAppointedWifiResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = ConnectToAppointedWifiResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("ConnectToAppointedWifi", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("ConnectToAppointedWifi", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ConnectToAppointedWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("ConnectToAppointedWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_network_settings<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = GetNetworkSettingsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_network_settings() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetNetworkSettings", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetNetworkSettingsResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetNetworkSettingsResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetNetworkSettings", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetNetworkSettings", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetNetworkSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetNetworkSettings", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_network_status<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = GetNetworkStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_network_status() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetNetworkStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetNetworkStatusResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetNetworkStatusResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetNetworkStatus", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetNetworkStatus", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetNetworkStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetNetworkStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_ruyi_test_network<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = RuyiTestNetworkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_ruyi_test_network() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RuyiTestNetwork", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RuyiTestNetworkResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RuyiTestNetworkResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RuyiTestNetwork", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RuyiTestNetwork", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RuyiTestNetwork", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RuyiTestNetwork", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_ruyi_start_network_speed_test<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = RuyiStartNetworkSpeedTestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_ruyi_start_network_speed_test(args.userindex) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RuyiStartNetworkSpeedTest", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RuyiStartNetworkSpeedTestResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RuyiStartNetworkSpeedTestResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RuyiStartNetworkSpeedTest", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RuyiStartNetworkSpeedTest", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RuyiStartNetworkSpeedTest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RuyiStartNetworkSpeedTest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_ruyi_stop_network_speed_test<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = RuyiStopNetworkSpeedTestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_ruyi_stop_network_speed_test(args.userindex) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RuyiStopNetworkSpeedTest", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RuyiStopNetworkSpeedTestResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RuyiStopNetworkSpeedTestResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RuyiStopNetworkSpeedTest", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RuyiStopNetworkSpeedTest", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RuyiStopNetworkSpeedTest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RuyiStopNetworkSpeedTest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_get_available_wifi<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = GetAvailableWifiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_get_available_wifi() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GetAvailableWifi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = GetAvailableWifiResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = GetAvailableWifiResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("GetAvailableWifi", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("GetAvailableWifi", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GetAvailableWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GetAvailableWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_disconnect_wifi<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = DisconnectWifiArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_disconnect_wifi() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DisconnectWifi", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DisconnectWifiResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = DisconnectWifiResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("DisconnectWifi", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("DisconnectWifi", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DisconnectWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("DisconnectWifi", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_discover_bluetooth_device<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let _ = DiscoverBluetoothDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_discover_bluetooth_device() {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DiscoverBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DiscoverBluetoothDeviceResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = DiscoverBluetoothDeviceResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("DiscoverBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("DiscoverBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DiscoverBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("DiscoverBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_connect_bluetooth_device<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = ConnectBluetoothDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_connect_bluetooth_device(args.device_name, args.device_address) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("ConnectBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = ConnectBluetoothDeviceResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = ConnectBluetoothDeviceResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("ConnectBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("ConnectBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("ConnectBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("ConnectBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_disconnect_bluetooth_device<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = DisconnectBluetoothDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_disconnect_bluetooth_device(args.device_name, args.device_address) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DisconnectBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = DisconnectBluetoothDeviceResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = DisconnectBluetoothDeviceResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("DisconnectBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("DisconnectBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DisconnectBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("DisconnectBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_remove_bluetooth_device<H: SettingSystemServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = RemoveBluetoothDeviceArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_remove_bluetooth_device(args.device_name, args.device_address) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("RemoveBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = RemoveBluetoothDeviceResult { result_value: Some(handler_return), error1: None };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::User(usr_err) => {
            if usr_err.downcast_ref::<common_type_s_d_k_data_types::ErrorException>().is_some() {
              let err = usr_err.downcast::<common_type_s_d_k_data_types::ErrorException>().expect("downcast already checked");
              let ret_err = RemoveBluetoothDeviceResult{ result_value: None, error1: Some(*err) };
              let message_ident = TMessageIdentifier::new("RemoveBluetoothDevice", TMessageType::Reply, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              ret_err.write_to_out_protocol(o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            } else {
              let ret_err = {
                ApplicationError::new(
                  ApplicationErrorKind::Unknown,
                  usr_err.description()
                )
              };
              let message_ident = TMessageIdentifier::new("RemoveBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
              o_prot.write_message_begin(&message_ident)?;
              thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
              o_prot.write_message_end()?;
              o_prot.flush()
            }
          },
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("RemoveBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("RemoveBluetoothDevice", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: SettingSystemServiceSyncHandler> TProcessor for SettingSystemServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "GetSettingItem" => {
        self.process_get_setting_item(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetSettingItems" => {
        self.process_get_setting_items(message_ident.sequence_number, i_prot, o_prot)
      },
      "SearchSettingItems" => {
        self.process_search_setting_items(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetCategoryNode" => {
        self.process_get_category_node(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetChildNode" => {
        self.process_get_child_node(message_ident.sequence_number, i_prot, o_prot)
      },
      "SetSettingItem" => {
        self.process_set_setting_item(message_ident.sequence_number, i_prot, o_prot)
      },
      "SetSettingItems" => {
        self.process_set_setting_items(message_ident.sequence_number, i_prot, o_prot)
      },
      "RestoreDefault" => {
        self.process_restore_default(message_ident.sequence_number, i_prot, o_prot)
      },
      "RestoreUserDefault" => {
        self.process_restore_user_default(message_ident.sequence_number, i_prot, o_prot)
      },
      "UpdateModuleVersion" => {
        self.process_update_module_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "SetUserAppData" => {
        self.process_set_user_app_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetUserAppData" => {
        self.process_get_user_app_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "RemoveUserAppData" => {
        self.process_remove_user_app_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "SettingItemNotify" => {
        self.process_setting_item_notify(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetNetworkAdapterSettings" => {
        self.process_get_network_adapter_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetLanNetworkName" => {
        self.process_get_lan_network_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "SetNetworkSettings" => {
        self.process_set_network_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "SetNetworkProxy" => {
        self.process_set_network_proxy(message_ident.sequence_number, i_prot, o_prot)
      },
      "ConnectToWifi" => {
        self.process_connect_to_wifi(message_ident.sequence_number, i_prot, o_prot)
      },
      "ConnectToAppointedWifi" => {
        self.process_connect_to_appointed_wifi(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetNetworkSettings" => {
        self.process_get_network_settings(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetNetworkStatus" => {
        self.process_get_network_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "RuyiTestNetwork" => {
        self.process_ruyi_test_network(message_ident.sequence_number, i_prot, o_prot)
      },
      "RuyiStartNetworkSpeedTest" => {
        self.process_ruyi_start_network_speed_test(message_ident.sequence_number, i_prot, o_prot)
      },
      "RuyiStopNetworkSpeedTest" => {
        self.process_ruyi_stop_network_speed_test(message_ident.sequence_number, i_prot, o_prot)
      },
      "GetAvailableWifi" => {
        self.process_get_available_wifi(message_ident.sequence_number, i_prot, o_prot)
      },
      "DisconnectWifi" => {
        self.process_disconnect_wifi(message_ident.sequence_number, i_prot, o_prot)
      },
      "DiscoverBluetoothDevice" => {
        self.process_discover_bluetooth_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "ConnectBluetoothDevice" => {
        self.process_connect_bluetooth_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "DisconnectBluetoothDevice" => {
        self.process_disconnect_bluetooth_device(message_ident.sequence_number, i_prot, o_prot)
      },
      "RemoveBluetoothDevice" => {
        self.process_remove_bluetooth_device(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// GetSettingItemArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetSettingItemArgs {
  /// The setting's unique id in current module.
  id: String,
}

impl GetSettingItemArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetSettingItemArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetSettingItemArgs.id", &f_1)?;
    let ret = GetSettingItemArgs {
      id: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSettingItem_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
    o_prot.write_string(&self.id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetSettingItemResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetSettingItemResult {
  result_value: Option<common_type_s_d_k_data_types::SettingItem>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetSettingItemResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetSettingItemResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common_type_s_d_k_data_types::SettingItem> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common_type_s_d_k_data_types::SettingItem::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetSettingItemResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSettingItemResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common_type_s_d_k_data_types::SettingItem> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetSettingItem"
          )
        )
      )
    }
  }
}

//
// GetSettingItemsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetSettingItemsArgs {
  /// Category to filter the settings. Null indicates getting all settings of the module
  category: String,
  /// Whecher to get the settings of children cagegories.
  include_children: bool,
}

impl GetSettingItemsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetSettingItemsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetSettingItemsArgs.category", &f_1)?;
    verify_required_field_exists("GetSettingItemsArgs.include_children", &f_2)?;
    let ret = GetSettingItemsArgs {
      category: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_children: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSettingItems_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeChildren", TType::Bool, 2))?;
    o_prot.write_bool(self.include_children)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetSettingItemsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetSettingItemsResult {
  result_value: Option<Vec<common_type_s_d_k_data_types::SettingItem>>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetSettingItemsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetSettingItemsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<common_type_s_d_k_data_types::SettingItem>> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common_type_s_d_k_data_types::SettingItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = common_type_s_d_k_data_types::SettingItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetSettingItemsResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetSettingItemsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<common_type_s_d_k_data_types::SettingItem>> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetSettingItems"
          )
        )
      )
    }
  }
}

//
// SearchSettingItemsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SearchSettingItemsArgs {
  /// Json string used to search.
  filter_json: String,
}

impl SearchSettingItemsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SearchSettingItemsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SearchSettingItemsArgs.filter_json", &f_1)?;
    let ret = SearchSettingItemsArgs {
      filter_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SearchSettingItems_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("filterJson", TType::String, 1))?;
    o_prot.write_string(&self.filter_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SearchSettingItemsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SearchSettingItemsResult {
  result_value: Option<BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult>>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl SearchSettingItemsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SearchSettingItemsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult>> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_1 = i_prot.read_string()?;
            let map_val_2 = setting_system_s_d_k_data_types::SettingSearchResult::read_from_in_protocol(i_prot)?;
            val.insert(map_key_1, map_val_2);
          }
          i_prot.read_map_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SearchSettingItemsResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SearchSettingItemsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Map, 0))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<BTreeMap<String, setting_system_s_d_k_data_types::SettingSearchResult>> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SearchSettingItems"
          )
        )
      )
    }
  }
}

//
// GetCategoryNodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetCategoryNodeArgs {
}

impl GetCategoryNodeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetCategoryNodeArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCategoryNodeArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCategoryNode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetCategoryNodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetCategoryNodeResult {
  result_value: Option<setting_system_s_d_k_data_types::SettingTree>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetCategoryNodeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetCategoryNodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<setting_system_s_d_k_data_types::SettingTree> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = setting_system_s_d_k_data_types::SettingTree::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetCategoryNodeResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetCategoryNodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<setting_system_s_d_k_data_types::SettingTree> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetCategoryNode"
          )
        )
      )
    }
  }
}

//
// GetChildNodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetChildNodeArgs {
  /// The parent node
  parent: String,
  /// Specifies whether the child nodes containing setting item or setting category, or both
  node_type: setting_system_s_d_k_data_types::NodeType,
  /// The parameter passed to the function which will be called while getting the item value
  param: String,
}

impl GetChildNodeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetChildNodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<setting_system_s_d_k_data_types::NodeType> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = setting_system_s_d_k_data_types::NodeType::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetChildNodeArgs.parent", &f_1)?;
    verify_required_field_exists("GetChildNodeArgs.node_type", &f_2)?;
    verify_required_field_exists("GetChildNodeArgs.param", &f_3)?;
    let ret = GetChildNodeArgs {
      parent: f_1.expect("auto-generated code should have checked for presence of required fields"),
      node_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      param: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetChildNode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parent", TType::String, 1))?;
    o_prot.write_string(&self.parent)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nodeType", TType::I32, 2))?;
    self.node_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("param", TType::String, 3))?;
    o_prot.write_string(&self.param)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetChildNodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetChildNodeResult {
  result_value: Option<setting_system_s_d_k_data_types::NodeList>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetChildNodeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetChildNodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<setting_system_s_d_k_data_types::NodeList> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = setting_system_s_d_k_data_types::NodeList::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetChildNodeResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetChildNodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<setting_system_s_d_k_data_types::NodeList> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetChildNode"
          )
        )
      )
    }
  }
}

//
// SetSettingItemArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetSettingItemArgs {
  /// Identity of the setting
  key: String,
  /// Value to be set
  val: String,
}

impl SetSettingItemArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetSettingItemArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetSettingItemArgs.key", &f_1)?;
    verify_required_field_exists("SetSettingItemArgs.val", &f_2)?;
    let ret = SetSettingItemArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      val: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetSettingItem_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("val", TType::String, 2))?;
    o_prot.write_string(&self.val)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetSettingItemResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetSettingItemResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl SetSettingItemResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetSettingItemResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetSettingItemResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetSettingItemResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SetSettingItem"
          )
        )
      )
    }
  }
}

//
// SetSettingItemsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetSettingItemsArgs {
  /// The key-values to be set.
  key_values: BTreeMap<String, String>,
}

impl SetSettingItemsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetSettingItemsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, String> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_3 = i_prot.read_string()?;
            let map_val_4 = i_prot.read_string()?;
            val.insert(map_key_3, map_val_4);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetSettingItemsArgs.key_values", &f_1)?;
    let ret = SetSettingItemsArgs {
      key_values: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetSettingItems_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("keyValues", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.key_values.len() as i32))?;
    for (k, v) in &self.key_values {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetSettingItemsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetSettingItemsResult {
  result_value: Option<i32>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl SetSettingItemsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetSettingItemsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetSettingItemsResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetSettingItemsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SetSettingItems"
          )
        )
      )
    }
  }
}

//
// RestoreDefaultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RestoreDefaultArgs {
  /// Module name specifies the module to be restored.
  module_name: String,
  /// The category of which to restored. Null indicates all settings.
  category: String,
}

impl RestoreDefaultArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RestoreDefaultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RestoreDefaultArgs.module_name", &f_1)?;
    verify_required_field_exists("RestoreDefaultArgs.category", &f_2)?;
    let ret = RestoreDefaultArgs {
      module_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      category: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestoreDefault_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("moduleName", TType::String, 1))?;
    o_prot.write_string(&self.module_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 2))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RestoreDefaultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RestoreDefaultResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RestoreDefaultResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RestoreDefaultResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RestoreDefaultResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestoreDefaultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RestoreDefault"
          )
        )
      )
    }
  }
}

//
// RestoreUserDefaultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RestoreUserDefaultArgs {
  user_id: String,
  module_name: String,
  category: String,
}

impl RestoreUserDefaultArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RestoreUserDefaultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RestoreUserDefaultArgs.user_id", &f_1)?;
    verify_required_field_exists("RestoreUserDefaultArgs.module_name", &f_2)?;
    verify_required_field_exists("RestoreUserDefaultArgs.category", &f_3)?;
    let ret = RestoreUserDefaultArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      module_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      category: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestoreUserDefault_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("moduleName", TType::String, 2))?;
    o_prot.write_string(&self.module_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 3))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RestoreUserDefaultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RestoreUserDefaultResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RestoreUserDefaultResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RestoreUserDefaultResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RestoreUserDefaultResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RestoreUserDefaultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RestoreUserDefault"
          )
        )
      )
    }
  }
}

//
// UpdateModuleVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UpdateModuleVersionArgs {
  /// Module of the setting
  module_name: String,
}

impl UpdateModuleVersionArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<UpdateModuleVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("UpdateModuleVersionArgs.module_name", &f_1)?;
    let ret = UpdateModuleVersionArgs {
      module_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateModuleVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("moduleName", TType::String, 1))?;
    o_prot.write_string(&self.module_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// UpdateModuleVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct UpdateModuleVersionResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl UpdateModuleVersionResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<UpdateModuleVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UpdateModuleVersionResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UpdateModuleVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for UpdateModuleVersion"
          )
        )
      )
    }
  }
}

//
// SetUserAppDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetUserAppDataArgs {
  user_id: String,
  category: String,
  setting_items: BTreeMap<String, common_type_s_d_k_data_types::SettingValue>,
}

impl SetUserAppDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetUserAppDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<BTreeMap<String, common_type_s_d_k_data_types::SettingValue>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, common_type_s_d_k_data_types::SettingValue> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_string()?;
            let map_val_6 = common_type_s_d_k_data_types::SettingValue::read_from_in_protocol(i_prot)?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetUserAppDataArgs.user_id", &f_1)?;
    verify_required_field_exists("SetUserAppDataArgs.category", &f_2)?;
    verify_required_field_exists("SetUserAppDataArgs.setting_items", &f_3)?;
    let ret = SetUserAppDataArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      category: f_2.expect("auto-generated code should have checked for presence of required fields"),
      setting_items: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetUserAppData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 2))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settingItems", TType::Map, 3))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, self.setting_items.len() as i32))?;
    for (k, v) in &self.setting_items {
      o_prot.write_string(k)?;
      v.write_to_out_protocol(o_prot)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetUserAppDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetUserAppDataResult {
  result_value: Option<i32>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl SetUserAppDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetUserAppDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetUserAppDataResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetUserAppDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SetUserAppData"
          )
        )
      )
    }
  }
}

//
// GetUserAppDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetUserAppDataArgs {
  user_id: String,
  category: String,
  setting_keys: Vec<String>,
}

impl GetUserAppDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetUserAppDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("GetUserAppDataArgs.user_id", &f_1)?;
    verify_required_field_exists("GetUserAppDataArgs.category", &f_2)?;
    verify_required_field_exists("GetUserAppDataArgs.setting_keys", &f_3)?;
    let ret = GetUserAppDataArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      category: f_2.expect("auto-generated code should have checked for presence of required fields"),
      setting_keys: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetUserAppData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 2))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settingKeys", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.setting_keys.len() as i32))?;
    for e in &self.setting_keys {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetUserAppDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetUserAppDataResult {
  result_value: Option<common_type_s_d_k_data_types::AppData>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetUserAppDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetUserAppDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<common_type_s_d_k_data_types::AppData> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = common_type_s_d_k_data_types::AppData::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetUserAppDataResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetUserAppDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<common_type_s_d_k_data_types::AppData> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetUserAppData"
          )
        )
      )
    }
  }
}

//
// RemoveUserAppDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RemoveUserAppDataArgs {
  user_id: String,
  category: String,
  setting_keys: Vec<String>,
}

impl RemoveUserAppDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RemoveUserAppDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RemoveUserAppDataArgs.user_id", &f_1)?;
    verify_required_field_exists("RemoveUserAppDataArgs.category", &f_2)?;
    verify_required_field_exists("RemoveUserAppDataArgs.setting_keys", &f_3)?;
    let ret = RemoveUserAppDataArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      category: f_2.expect("auto-generated code should have checked for presence of required fields"),
      setting_keys: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemoveUserAppData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 2))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("settingKeys", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.setting_keys.len() as i32))?;
    for e in &self.setting_keys {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RemoveUserAppDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RemoveUserAppDataResult {
  result_value: Option<i32>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RemoveUserAppDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RemoveUserAppDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RemoveUserAppDataResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemoveUserAppDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RemoveUserAppData"
          )
        )
      )
    }
  }
}

//
// SettingItemNotifyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SettingItemNotifyArgs {
  /// The item's ID
  key: String,
  /// Optional. The arguments of the notification. In json string format
  contents: setting_system_s_d_k_data_types::JSON,
}

impl SettingItemNotifyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingItemNotifyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<setting_system_s_d_k_data_types::JSON> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SettingItemNotifyArgs.key", &f_1)?;
    verify_required_field_exists("SettingItemNotifyArgs.contents", &f_2)?;
    let ret = SettingItemNotifyArgs {
      key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      contents: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingItemNotify_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contents", TType::String, 2))?;
    o_prot.write_string(&self.contents)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SettingItemNotifyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SettingItemNotifyResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl SettingItemNotifyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingItemNotifyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingItemNotifyResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingItemNotifyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SettingItemNotify"
          )
        )
      )
    }
  }
}

//
// GetNetworkAdapterSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetNetworkAdapterSettingsArgs {
}

impl GetNetworkAdapterSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetNetworkAdapterSettingsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetNetworkAdapterSettingsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetNetworkAdapterSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetNetworkAdapterSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetNetworkAdapterSettingsResult {
  result_value: Option<setting_system_s_d_k_data_types::NetworkSettings>,
}

impl GetNetworkAdapterSettingsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetNetworkAdapterSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<setting_system_s_d_k_data_types::NetworkSettings> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = setting_system_s_d_k_data_types::NetworkSettings::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetNetworkAdapterSettingsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetNetworkAdapterSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<setting_system_s_d_k_data_types::NetworkSettings> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetNetworkAdapterSettings"
          )
        )
      )
    }
  }
}

//
// GetLanNetworkNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetLanNetworkNameArgs {
}

impl GetLanNetworkNameArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetLanNetworkNameArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetLanNetworkNameArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetLanNetworkName_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetLanNetworkNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetLanNetworkNameResult {
  result_value: Option<String>,
}

impl GetLanNetworkNameResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetLanNetworkNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetLanNetworkNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetLanNetworkNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetLanNetworkName"
          )
        )
      )
    }
  }
}

//
// SetNetworkSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetNetworkSettingsArgs {
  is_w_lan: bool,
  enable_d_h_c_p: bool,
  ip_address: String,
  sub_mask: String,
  gateway: String,
  main_d_n_s: String,
  sub_d_n_s: String,
}

impl SetNetworkSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetNetworkSettingsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetNetworkSettingsArgs.is_w_lan", &f_1)?;
    verify_required_field_exists("SetNetworkSettingsArgs.enable_d_h_c_p", &f_2)?;
    verify_required_field_exists("SetNetworkSettingsArgs.ip_address", &f_3)?;
    verify_required_field_exists("SetNetworkSettingsArgs.sub_mask", &f_4)?;
    verify_required_field_exists("SetNetworkSettingsArgs.gateway", &f_5)?;
    verify_required_field_exists("SetNetworkSettingsArgs.main_d_n_s", &f_6)?;
    verify_required_field_exists("SetNetworkSettingsArgs.sub_d_n_s", &f_7)?;
    let ret = SetNetworkSettingsArgs {
      is_w_lan: f_1.expect("auto-generated code should have checked for presence of required fields"),
      enable_d_h_c_p: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ip_address: f_3.expect("auto-generated code should have checked for presence of required fields"),
      sub_mask: f_4.expect("auto-generated code should have checked for presence of required fields"),
      gateway: f_5.expect("auto-generated code should have checked for presence of required fields"),
      main_d_n_s: f_6.expect("auto-generated code should have checked for presence of required fields"),
      sub_d_n_s: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetNetworkSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isWLan", TType::Bool, 1))?;
    o_prot.write_bool(self.is_w_lan)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("EnableDHCP", TType::Bool, 2))?;
    o_prot.write_bool(self.enable_d_h_c_p)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("IpAddress", TType::String, 3))?;
    o_prot.write_string(&self.ip_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("SubMask", TType::String, 4))?;
    o_prot.write_string(&self.sub_mask)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("Gateway", TType::String, 5))?;
    o_prot.write_string(&self.gateway)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("MainDNS", TType::String, 6))?;
    o_prot.write_string(&self.main_d_n_s)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("SubDNS", TType::String, 7))?;
    o_prot.write_string(&self.sub_d_n_s)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetNetworkSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetNetworkSettingsResult {
  result_value: Option<bool>,
}

impl SetNetworkSettingsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetNetworkSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetNetworkSettingsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetNetworkSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SetNetworkSettings"
          )
        )
      )
    }
  }
}

//
// SetNetworkProxyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetNetworkProxyArgs {
  proxy_server: String,
  proxy_port: String,
}

impl SetNetworkProxyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetNetworkProxyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("SetNetworkProxyArgs.proxy_server", &f_1)?;
    verify_required_field_exists("SetNetworkProxyArgs.proxy_port", &f_2)?;
    let ret = SetNetworkProxyArgs {
      proxy_server: f_1.expect("auto-generated code should have checked for presence of required fields"),
      proxy_port: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetNetworkProxy_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ProxyServer", TType::String, 1))?;
    o_prot.write_string(&self.proxy_server)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ProxyPort", TType::String, 2))?;
    o_prot.write_string(&self.proxy_port)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// SetNetworkProxyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct SetNetworkProxyResult {
  result_value: Option<bool>,
}

impl SetNetworkProxyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SetNetworkProxyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SetNetworkProxyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SetNetworkProxyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for SetNetworkProxy"
          )
        )
      )
    }
  }
}

//
// ConnectToWifiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ConnectToWifiArgs {
  profile_name: String,
  key: String,
}

impl ConnectToWifiArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConnectToWifiArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ConnectToWifiArgs.profile_name", &f_1)?;
    verify_required_field_exists("ConnectToWifiArgs.key", &f_2)?;
    let ret = ConnectToWifiArgs {
      profile_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      key: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectToWifi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileName", TType::String, 1))?;
    o_prot.write_string(&self.profile_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 2))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ConnectToWifiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ConnectToWifiResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl ConnectToWifiResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConnectToWifiResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ConnectToWifiResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectToWifiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ConnectToWifi"
          )
        )
      )
    }
  }
}

//
// ConnectToAppointedWifiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ConnectToAppointedWifiArgs {
  profile_name: String,
  auth: String,
  ciper: String,
  key_type: String,
  key: String,
}

impl ConnectToAppointedWifiArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConnectToAppointedWifiArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ConnectToAppointedWifiArgs.profile_name", &f_1)?;
    verify_required_field_exists("ConnectToAppointedWifiArgs.auth", &f_2)?;
    verify_required_field_exists("ConnectToAppointedWifiArgs.ciper", &f_3)?;
    verify_required_field_exists("ConnectToAppointedWifiArgs.key_type", &f_4)?;
    verify_required_field_exists("ConnectToAppointedWifiArgs.key", &f_5)?;
    let ret = ConnectToAppointedWifiArgs {
      profile_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      auth: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ciper: f_3.expect("auto-generated code should have checked for presence of required fields"),
      key_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      key: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectToAppointedWifi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileName", TType::String, 1))?;
    o_prot.write_string(&self.profile_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("Auth", TType::String, 2))?;
    o_prot.write_string(&self.auth)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("Ciper", TType::String, 3))?;
    o_prot.write_string(&self.ciper)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("KeyType", TType::String, 4))?;
    o_prot.write_string(&self.key_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 5))?;
    o_prot.write_string(&self.key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ConnectToAppointedWifiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ConnectToAppointedWifiResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl ConnectToAppointedWifiResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConnectToAppointedWifiResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ConnectToAppointedWifiResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectToAppointedWifiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ConnectToAppointedWifi"
          )
        )
      )
    }
  }
}

//
// GetNetworkSettingsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetNetworkSettingsArgs {
}

impl GetNetworkSettingsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetNetworkSettingsArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetNetworkSettingsArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetNetworkSettings_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetNetworkSettingsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetNetworkSettingsResult {
  result_value: Option<setting_system_s_d_k_data_types::RuyiNetworkSettings>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetNetworkSettingsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetNetworkSettingsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<setting_system_s_d_k_data_types::RuyiNetworkSettings> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = setting_system_s_d_k_data_types::RuyiNetworkSettings::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetNetworkSettingsResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetNetworkSettingsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkSettings> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetNetworkSettings"
          )
        )
      )
    }
  }
}

//
// GetNetworkStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetNetworkStatusArgs {
}

impl GetNetworkStatusArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetNetworkStatusArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetNetworkStatusArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetNetworkStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetNetworkStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetNetworkStatusResult {
  result_value: Option<setting_system_s_d_k_data_types::RuyiNetworkStatus>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetNetworkStatusResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetNetworkStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<setting_system_s_d_k_data_types::RuyiNetworkStatus> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = setting_system_s_d_k_data_types::RuyiNetworkStatus::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetNetworkStatusResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetNetworkStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkStatus> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetNetworkStatus"
          )
        )
      )
    }
  }
}

//
// RuyiTestNetworkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RuyiTestNetworkArgs {
}

impl RuyiTestNetworkArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiTestNetworkArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiTestNetworkArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiTestNetwork_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RuyiTestNetworkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RuyiTestNetworkResult {
  result_value: Option<setting_system_s_d_k_data_types::RuyiNetworkTestResult>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RuyiTestNetworkResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiTestNetworkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<setting_system_s_d_k_data_types::RuyiNetworkTestResult> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = setting_system_s_d_k_data_types::RuyiNetworkTestResult::read_from_in_protocol(i_prot)?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiTestNetworkResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiTestNetworkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Struct, 0))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<setting_system_s_d_k_data_types::RuyiNetworkTestResult> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RuyiTestNetwork"
          )
        )
      )
    }
  }
}

//
// RuyiStartNetworkSpeedTestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RuyiStartNetworkSpeedTestArgs {
  userindex: i32,
}

impl RuyiStartNetworkSpeedTestArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiStartNetworkSpeedTestArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RuyiStartNetworkSpeedTestArgs.userindex", &f_1)?;
    let ret = RuyiStartNetworkSpeedTestArgs {
      userindex: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiStartNetworkSpeedTest_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userindex", TType::I32, 1))?;
    o_prot.write_i32(self.userindex)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RuyiStartNetworkSpeedTestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RuyiStartNetworkSpeedTestResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RuyiStartNetworkSpeedTestResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiStartNetworkSpeedTestResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiStartNetworkSpeedTestResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiStartNetworkSpeedTestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RuyiStartNetworkSpeedTest"
          )
        )
      )
    }
  }
}

//
// RuyiStopNetworkSpeedTestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RuyiStopNetworkSpeedTestArgs {
  userindex: i32,
}

impl RuyiStopNetworkSpeedTestArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiStopNetworkSpeedTestArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RuyiStopNetworkSpeedTestArgs.userindex", &f_1)?;
    let ret = RuyiStopNetworkSpeedTestArgs {
      userindex: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiStopNetworkSpeedTest_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userindex", TType::I32, 1))?;
    o_prot.write_i32(self.userindex)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RuyiStopNetworkSpeedTestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RuyiStopNetworkSpeedTestResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RuyiStopNetworkSpeedTestResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiStopNetworkSpeedTestResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiStopNetworkSpeedTestResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiStopNetworkSpeedTestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RuyiStopNetworkSpeedTest"
          )
        )
      )
    }
  }
}

//
// GetAvailableWifiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetAvailableWifiArgs {
}

impl GetAvailableWifiArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetAvailableWifiArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetAvailableWifiArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetAvailableWifi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// GetAvailableWifiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct GetAvailableWifiResult {
  result_value: Option<Vec<setting_system_s_d_k_data_types::WifiEntity>>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl GetAvailableWifiResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<GetAvailableWifiResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<setting_system_s_d_k_data_types::WifiEntity>> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<setting_system_s_d_k_data_types::WifiEntity> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = setting_system_s_d_k_data_types::WifiEntity::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = GetAvailableWifiResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GetAvailableWifiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<setting_system_s_d_k_data_types::WifiEntity>> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for GetAvailableWifi"
          )
        )
      )
    }
  }
}

//
// DisconnectWifiArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DisconnectWifiArgs {
}

impl DisconnectWifiArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DisconnectWifiArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DisconnectWifiArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DisconnectWifi_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DisconnectWifiResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DisconnectWifiResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl DisconnectWifiResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DisconnectWifiResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DisconnectWifiResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DisconnectWifiResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DisconnectWifi"
          )
        )
      )
    }
  }
}

//
// DiscoverBluetoothDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DiscoverBluetoothDeviceArgs {
}

impl DiscoverBluetoothDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DiscoverBluetoothDeviceArgs> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DiscoverBluetoothDeviceArgs {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DiscoverBluetoothDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DiscoverBluetoothDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DiscoverBluetoothDeviceResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl DiscoverBluetoothDeviceResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DiscoverBluetoothDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DiscoverBluetoothDeviceResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DiscoverBluetoothDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DiscoverBluetoothDevice"
          )
        )
      )
    }
  }
}

//
// ConnectBluetoothDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ConnectBluetoothDeviceArgs {
  device_name: String,
  device_address: String,
}

impl ConnectBluetoothDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConnectBluetoothDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("ConnectBluetoothDeviceArgs.device_name", &f_1)?;
    verify_required_field_exists("ConnectBluetoothDeviceArgs.device_address", &f_2)?;
    let ret = ConnectBluetoothDeviceArgs {
      device_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      device_address: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectBluetoothDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("DeviceName", TType::String, 1))?;
    o_prot.write_string(&self.device_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("DeviceAddress", TType::String, 2))?;
    o_prot.write_string(&self.device_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// ConnectBluetoothDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct ConnectBluetoothDeviceResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl ConnectBluetoothDeviceResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ConnectBluetoothDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ConnectBluetoothDeviceResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ConnectBluetoothDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for ConnectBluetoothDevice"
          )
        )
      )
    }
  }
}

//
// DisconnectBluetoothDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DisconnectBluetoothDeviceArgs {
  device_name: String,
  device_address: String,
}

impl DisconnectBluetoothDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DisconnectBluetoothDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("DisconnectBluetoothDeviceArgs.device_name", &f_1)?;
    verify_required_field_exists("DisconnectBluetoothDeviceArgs.device_address", &f_2)?;
    let ret = DisconnectBluetoothDeviceArgs {
      device_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      device_address: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DisconnectBluetoothDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("DeviceName", TType::String, 1))?;
    o_prot.write_string(&self.device_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("DeviceAddress", TType::String, 2))?;
    o_prot.write_string(&self.device_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// DisconnectBluetoothDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct DisconnectBluetoothDeviceResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl DisconnectBluetoothDeviceResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DisconnectBluetoothDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DisconnectBluetoothDeviceResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DisconnectBluetoothDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for DisconnectBluetoothDevice"
          )
        )
      )
    }
  }
}

//
// RemoveBluetoothDeviceArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RemoveBluetoothDeviceArgs {
  device_name: String,
  device_address: String,
}

impl RemoveBluetoothDeviceArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RemoveBluetoothDeviceArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("RemoveBluetoothDeviceArgs.device_name", &f_1)?;
    verify_required_field_exists("RemoveBluetoothDeviceArgs.device_address", &f_2)?;
    let ret = RemoveBluetoothDeviceArgs {
      device_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      device_address: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemoveBluetoothDevice_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("DeviceName", TType::String, 1))?;
    o_prot.write_string(&self.device_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("DeviceAddress", TType::String, 2))?;
    o_prot.write_string(&self.device_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// RemoveBluetoothDeviceResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct RemoveBluetoothDeviceResult {
  result_value: Option<bool>,
  error1: Option<common_type_s_d_k_data_types::ErrorException>,
}

impl RemoveBluetoothDeviceResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RemoveBluetoothDeviceResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    let mut f_1: Option<common_type_s_d_k_data_types::ErrorException> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        1 => {
          let val = common_type_s_d_k_data_types::ErrorException::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RemoveBluetoothDeviceResult {
      result_value: f_0,
      error1: f_1,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RemoveBluetoothDeviceResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.error1 {
      o_prot.write_field_begin(&TFieldIdentifier::new("error1", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.error1.is_some() {
      Err(thrift::Error::User(Box::new(self.error1.unwrap())))
    } else if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for RemoveBluetoothDevice"
          )
        )
      )
    }
  }
}

