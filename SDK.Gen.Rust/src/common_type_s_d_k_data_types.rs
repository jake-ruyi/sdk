// Autogenerated by Thrift Compiler (0.12.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

/// @PowerOperations_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum PowerOperations {
  /// @PowerOperations_None
  None = 0,
  /// Restart the device's OS
  RestartDevice = 2,
  ShutdownDevice = 3,
  ShutdownLayer0 = 4,
  /// Restart layer0
  RestartLayer0 = 5,
  /// Switch to low-power mode
  SwitchToLowPower = 8,
  /// Switch to high-power mode
  SwitchToHighPower = 9,
  SleepDevice = 10,
  ShutdownLayer1 = 12,
  Cancel = 15,
  Ping = 16,
  FakeUserLogout = 17,
}

impl PowerOperations {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<PowerOperations> {
    let enum_value = i_prot.read_i32()?;
    PowerOperations::try_from(enum_value)  }
}

impl TryFrom<i32> for PowerOperations {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(PowerOperations::None),
      2 => Ok(PowerOperations::RestartDevice),
      3 => Ok(PowerOperations::ShutdownDevice),
      4 => Ok(PowerOperations::ShutdownLayer0),
      5 => Ok(PowerOperations::RestartLayer0),
      8 => Ok(PowerOperations::SwitchToLowPower),
      9 => Ok(PowerOperations::SwitchToHighPower),
      10 => Ok(PowerOperations::SleepDevice),
      12 => Ok(PowerOperations::ShutdownLayer1),
      15 => Ok(PowerOperations::Cancel),
      16 => Ok(PowerOperations::Ping),
      17 => Ok(PowerOperations::FakeUserLogout),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to PowerOperations", i)
            )
          )
        )
      },
    }
  }
}

/// @UserType_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum UserType {
  Guest = 0,
  RuyiUser = 1,
  Developer = 2,
}

impl UserType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<UserType> {
    let enum_value = i_prot.read_i32()?;
    UserType::try_from(enum_value)  }
}

impl TryFrom<i32> for UserType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(UserType::Guest),
      1 => Ok(UserType::RuyiUser),
      2 => Ok(UserType::Developer),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to UserType", i)
            )
          )
        )
      },
    }
  }
}

/// @LoginState_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum LoginState {
  /// @LoginState_Logout
  Logout = 0,
  /// @LoginState_Login
  Login = 1,
}

impl LoginState {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<LoginState> {
    let enum_value = i_prot.read_i32()?;
    LoginState::try_from(enum_value)  }
}

impl TryFrom<i32> for LoginState {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(LoginState::Logout),
      1 => Ok(LoginState::Login),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to LoginState", i)
            )
          )
        )
      },
    }
  }
}

/// @TitleMainIconNotificationType_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TitleMainIconNotificationType {
  FriendRequest = 0,
  FriendAccept = 1,
  BluetoothDeviceStatusChanged = 2,
  NetworkStatusChanged = 3,
  SMSCodeHasBeenSent = 4,
}

impl TitleMainIconNotificationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<TitleMainIconNotificationType> {
    let enum_value = i_prot.read_i32()?;
    TitleMainIconNotificationType::try_from(enum_value)  }
}

impl TryFrom<i32> for TitleMainIconNotificationType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(TitleMainIconNotificationType::FriendRequest),
      1 => Ok(TitleMainIconNotificationType::FriendAccept),
      2 => Ok(TitleMainIconNotificationType::BluetoothDeviceStatusChanged),
      3 => Ok(TitleMainIconNotificationType::NetworkStatusChanged),
      4 => Ok(TitleMainIconNotificationType::SMSCodeHasBeenSent),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TitleMainIconNotificationType", i)
            )
          )
        )
      },
    }
  }
}

/// @InputCategory_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum InputCategory {
  GamePad = 0,
  Keyboard = 1,
  Mouse = 2,
  JoyStick = 3,
  MaxCount = 4,
}

impl InputCategory {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputCategory> {
    let enum_value = i_prot.read_i32()?;
    InputCategory::try_from(enum_value)  }
}

impl TryFrom<i32> for InputCategory {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(InputCategory::GamePad),
      1 => Ok(InputCategory::Keyboard),
      2 => Ok(InputCategory::Mouse),
      3 => Ok(InputCategory::JoyStick),
      4 => Ok(InputCategory::MaxCount),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to InputCategory", i)
            )
          )
        )
      },
    }
  }
}

/// @RuyiGamePadButtonFlags_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RuyiGamePadButtonFlags {
  GamePadUp = 1,
  GamePadDown = 2,
  GamePadLeft = 4,
  GamePadRight = 8,
  GamePadStart = 16,
  GamePadBack = 32,
  GamePadL3 = 64,
  GamePadR3 = 128,
  GamePadLB = 256,
  GamePadRB = 512,
  GamePadA = 4096,
  GamePadB = 8192,
  GamePadX = 16384,
  GamePadY = 32768,
  GamePadLT = 131072,
  GamePadRT = 262144,
  GamePadLJoyX = 524288,
  GamePadLJoyY = 1048576,
  GamePadRJoyX = 2097152,
  GamePadRJoyY = 4194304,
}

impl RuyiGamePadButtonFlags {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiGamePadButtonFlags> {
    let enum_value = i_prot.read_i32()?;
    RuyiGamePadButtonFlags::try_from(enum_value)  }
}

impl TryFrom<i32> for RuyiGamePadButtonFlags {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      1 => Ok(RuyiGamePadButtonFlags::GamePadUp),
      2 => Ok(RuyiGamePadButtonFlags::GamePadDown),
      4 => Ok(RuyiGamePadButtonFlags::GamePadLeft),
      8 => Ok(RuyiGamePadButtonFlags::GamePadRight),
      16 => Ok(RuyiGamePadButtonFlags::GamePadStart),
      32 => Ok(RuyiGamePadButtonFlags::GamePadBack),
      64 => Ok(RuyiGamePadButtonFlags::GamePadL3),
      128 => Ok(RuyiGamePadButtonFlags::GamePadR3),
      256 => Ok(RuyiGamePadButtonFlags::GamePadLB),
      512 => Ok(RuyiGamePadButtonFlags::GamePadRB),
      4096 => Ok(RuyiGamePadButtonFlags::GamePadA),
      8192 => Ok(RuyiGamePadButtonFlags::GamePadB),
      16384 => Ok(RuyiGamePadButtonFlags::GamePadX),
      32768 => Ok(RuyiGamePadButtonFlags::GamePadY),
      131072 => Ok(RuyiGamePadButtonFlags::GamePadLT),
      262144 => Ok(RuyiGamePadButtonFlags::GamePadRT),
      524288 => Ok(RuyiGamePadButtonFlags::GamePadLJoyX),
      1048576 => Ok(RuyiGamePadButtonFlags::GamePadLJoyY),
      2097152 => Ok(RuyiGamePadButtonFlags::GamePadRJoyX),
      4194304 => Ok(RuyiGamePadButtonFlags::GamePadRJoyY),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to RuyiGamePadButtonFlags", i)
            )
          )
        )
      },
    }
  }
}

/// @ePlatform_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EPlatform {
  None = 0,
  Pc = 1,
  Console = 2,
  All = 3,
}

impl EPlatform {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<EPlatform> {
    let enum_value = i_prot.read_i32()?;
    EPlatform::try_from(enum_value)  }
}

impl TryFrom<i32> for EPlatform {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(EPlatform::None),
      1 => Ok(EPlatform::Pc),
      2 => Ok(EPlatform::Console),
      3 => Ok(EPlatform::All),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EPlatform", i)
            )
          )
        )
      },
    }
  }
}

/// @eUIType_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EUIType {
  None = 0,
  Toggle = 1,
  Text = 2,
  Slider = 3,
  CheckList = 4,
  OptionList = 5,
  DateTime = 6,
  InputTextWithLabel = 7,
  Button = 8,
  InputText = 9,
}

impl EUIType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<EUIType> {
    let enum_value = i_prot.read_i32()?;
    EUIType::try_from(enum_value)  }
}

impl TryFrom<i32> for EUIType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(EUIType::None),
      1 => Ok(EUIType::Toggle),
      2 => Ok(EUIType::Text),
      3 => Ok(EUIType::Slider),
      4 => Ok(EUIType::CheckList),
      5 => Ok(EUIType::OptionList),
      6 => Ok(EUIType::DateTime),
      7 => Ok(EUIType::InputTextWithLabel),
      8 => Ok(EUIType::Button),
      9 => Ok(EUIType::InputText),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EUIType", i)
            )
          )
        )
      },
    }
  }
}

pub type JSON = String;

//
// ErrorException
//

/// @ErrorException_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ErrorException {
  /// @ErrorException_errId_desc
  pub err_id: Option<i32>,
  /// @ErrorException_errMsg_desc
  pub err_msg: Option<String>,
}

impl ErrorException {
  pub fn new<F1, F2>(err_id: F1, err_msg: F2) -> ErrorException where F1: Into<Option<i32>>, F2: Into<Option<String>> {
    ErrorException {
      err_id: err_id.into(),
      err_msg: err_msg.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ErrorException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ErrorException {
      err_id: f_1,
      err_msg: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ErrorException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.err_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("errId", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.err_msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("errMsg", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ErrorException {
  fn default() -> Self {
    ErrorException{
      err_id: Some(0),
      err_msg: Some("".to_owned()),
    }
  }
}

impl Error for ErrorException {
  fn description(&self) -> &str {
    "remote service threw ErrorException"
  }
}

impl From<ErrorException> for thrift::Error {
  fn from(e: ErrorException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ErrorException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// Range
//

/// @range_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Range {
  /// @range_minimum_desc
  pub minimum: Option<OrderedFloat<f64>>,
  /// @range_maximum_desc
  pub maximum: Option<OrderedFloat<f64>>,
}

impl Range {
  pub fn new<F1, F2>(minimum: F1, maximum: F2) -> Range where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>> {
    Range {
      minimum: minimum.into(),
      maximum: maximum.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Range> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Range {
      minimum: f_1,
      maximum: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("range");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.minimum {
      o_prot.write_field_begin(&TFieldIdentifier::new("minimum", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.maximum {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximum", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Range {
  fn default() -> Self {
    Range{
      minimum: Some(OrderedFloat::from(0.0)),
      maximum: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// InputModifier
//

/// @InputModifier_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InputModifier {
  /// @InputModifier_DeadZone_desc
  pub dead_zone: Option<Range>,
  /// @InputModifier_Scale_desc
  pub scale: Option<OrderedFloat<f64>>,
}

impl InputModifier {
  pub fn new<F1, F2>(dead_zone: F1, scale: F2) -> InputModifier where F1: Into<Option<Range>>, F2: Into<Option<OrderedFloat<f64>>> {
    InputModifier {
      dead_zone: dead_zone.into(),
      scale: scale.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputModifier> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Range> = None;
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Range::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InputModifier {
      dead_zone: f_1,
      scale: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InputModifier");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dead_zone {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeadZone", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("Scale", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InputModifier {
  fn default() -> Self {
    InputModifier{
      dead_zone: None,
      scale: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// ActionTrigger
//

/// @ActionTrigger_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActionTrigger {
  /// @ActionTrigger_Id_desc
  pub id: Option<i32>,
  /// @ActionTrigger_InputCagetory_desc
  pub input_cagetory: Option<InputCategory>,
  /// @ActionTrigger_TriggerButtons_desc
  pub trigger_buttons: Option<Vec<i32>>,
  /// @ActionTrigger_TriggerValue_desc
  pub trigger_value: Option<Vec<i32>>,
}

impl ActionTrigger {
  pub fn new<F1, F2, F3, F4>(id: F1, input_cagetory: F2, trigger_buttons: F3, trigger_value: F4) -> ActionTrigger where F1: Into<Option<i32>>, F2: Into<Option<InputCategory>>, F3: Into<Option<Vec<i32>>>, F4: Into<Option<Vec<i32>>> {
    ActionTrigger {
      id: id.into(),
      input_cagetory: input_cagetory.into(),
      trigger_buttons: trigger_buttons.into(),
      trigger_value: trigger_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ActionTrigger> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<InputCategory> = None;
    let mut f_3: Option<Vec<i32>> = Some(Vec::new());
    let mut f_4: Option<Vec<i32>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = InputCategory::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_i32()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_i32()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActionTrigger {
      id: f_1,
      input_cagetory: f_2,
      trigger_buttons: f_3,
      trigger_value: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActionTrigger");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("Id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.input_cagetory {
      o_prot.write_field_begin(&TFieldIdentifier::new("InputCagetory", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.trigger_buttons {
      o_prot.write_field_begin(&TFieldIdentifier::new("TriggerButtons", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.trigger_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("TriggerValue", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ActionTrigger {
  fn default() -> Self {
    ActionTrigger{
      id: Some(0),
      input_cagetory: None,
      trigger_buttons: Some(Vec::new()),
      trigger_value: Some(Vec::new()),
    }
  }
}

//
// Notification
//

/// @notification_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Notification {
  /// @notification_title_desc
  pub title: Option<String>,
  /// @notification_detail_desc
  pub detail: Option<String>,
  /// @notification_option_desc
  pub option: Option<Vec<String>>,
}

impl Notification {
  pub fn new<F1, F2, F3>(title: F1, detail: F2, option: F3) -> Notification where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<Vec<String>>> {
    Notification {
      title: title.into(),
      detail: detail.into(),
      option: option.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Notification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Notification {
      title: f_1,
      detail: f_2,
      option: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.detail {
      o_prot.write_field_begin(&TFieldIdentifier::new("detail", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.option {
      o_prot.write_field_begin(&TFieldIdentifier::new("option", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Notification {
  fn default() -> Self {
    Notification{
      title: Some("".to_owned()),
      detail: Some("".to_owned()),
      option: Some(Vec::new()),
    }
  }
}

//
// DataListItem
//

/// @dataListItem_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataListItem {
  /// @dataListItem_elementType_desc
  pub element_type: Option<String>,
  /// @dataListItem_values_desc
  pub values: Option<Vec<String>>,
  /// @dataListItem_removeNotification_desc
  pub remove_notification: Option<Notification>,
}

impl DataListItem {
  pub fn new<F1, F2, F3>(element_type: F1, values: F2, remove_notification: F3) -> DataListItem where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<Notification>> {
    DataListItem {
      element_type: element_type.into(),
      values: values.into(),
      remove_notification: remove_notification.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DataListItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<String>> = Some(Vec::new());
    let mut f_3: Option<Notification> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_string()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Notification::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DataListItem {
      element_type: f_1,
      values: f_2,
      remove_notification: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("dataListItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.element_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("elementType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.remove_notification {
      o_prot.write_field_begin(&TFieldIdentifier::new("removeNotification", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for DataListItem {
  fn default() -> Self {
    DataListItem{
      element_type: Some("".to_owned()),
      values: Some(Vec::new()),
      remove_notification: None,
    }
  }
}

//
// ActiveDependency
//

/// @activeDependency_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActiveDependency {
  /// @activeDependency_name_desc
  pub name: Option<String>,
  /// @activeDependency_condition_desc
  pub condition: Option<String>,
}

impl ActiveDependency {
  pub fn new<F1, F2>(name: F1, condition: F2) -> ActiveDependency where F1: Into<Option<String>>, F2: Into<Option<String>> {
    ActiveDependency {
      name: name.into(),
      condition: condition.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ActiveDependency> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActiveDependency {
      name: f_1,
      condition: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("activeDependency");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.condition {
      o_prot.write_field_begin(&TFieldIdentifier::new("condition", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ActiveDependency {
  fn default() -> Self {
    ActiveDependency{
      name: Some("".to_owned()),
      condition: Some("".to_owned()),
    }
  }
}

//
// SettingValue
//

/// @SettingValue_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingValue {
  /// @SettingValue_dataType_desc
  pub data_type: Option<String>,
  /// @SettingValue_dataValue_desc
  pub data_value: Option<String>,
}

impl SettingValue {
  pub fn new<F1, F2>(data_type: F1, data_value: F2) -> SettingValue where F1: Into<Option<String>>, F2: Into<Option<String>> {
    SettingValue {
      data_type: data_type.into(),
      data_value: data_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingValue {
      data_type: f_1,
      data_value: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.data_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataValue", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingValue {
  fn default() -> Self {
    SettingValue{
      data_type: Some("".to_owned()),
      data_value: Some("".to_owned()),
    }
  }
}

//
// SettingItem
//

/// @SettingItem_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingItem {
  /// @SettingItem_id_desc
  pub id: Option<String>,
  /// @SettingItem_display_desc
  pub display: Option<String>,
  /// @SettingItem_dataType_desc
  pub data_type: Option<String>,
  /// @SettingItem_dataValue_desc
  pub data_value: Option<String>,
  /// @SettingItem_dataList_desc
  pub data_list: Option<DataListItem>,
  /// @SettingItem_platform_desc
  pub platform: Option<EPlatform>,
  /// @SettingItem_summary_desc
  pub summary: Option<String>,
  /// @SettingItem_description_desc
  pub description: Option<String>,
  /// @SettingItem_UIType_desc
  pub u_i_type: Option<EUIType>,
  /// @SettingItem_devModeOnly_desc
  pub dev_mode_only: Option<bool>,
  /// @SettingItem_internalOnly_desc
  pub internal_only: Option<bool>,
  /// @SettingItem_readOnly_desc
  pub read_only: Option<bool>,
  /// @SettingItem_isValid_desc
  pub is_valid: Option<bool>,
  /// @SettingItem_isActive_desc
  pub is_active: Option<bool>,
  /// @SettingItem_hasNew_desc
  pub has_new: Option<bool>,
  /// @SettingItem_validation_desc
  pub validation: Option<String>,
  /// @SettingItem_activeDependencies_desc
  pub active_dependencies: Option<Vec<ActiveDependency>>,
  /// @SettingItem_ActionName_desc
  pub action_name: Option<String>,
  /// @SettingItem_ActionObject_desc
  pub action_object: Option<String>,
  /// @SettingItem_ActionOnSetValue_desc
  pub action_on_set_value: Option<String>,
  /// @SettingItem_ActionOnGetValue_desc
  pub action_on_get_value: Option<String>,
  /// @SettingItem_Tags_desc
  pub tags: Option<Vec<String>>,
}

impl SettingItem {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21, F22>(id: F1, display: F2, data_type: F3, data_value: F4, data_list: F5, platform: F6, summary: F7, description: F8, u_i_type: F9, dev_mode_only: F10, internal_only: F11, read_only: F12, is_valid: F13, is_active: F14, has_new: F15, validation: F16, active_dependencies: F17, action_name: F18, action_object: F19, action_on_set_value: F20, action_on_get_value: F21, tags: F22) -> SettingItem where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<DataListItem>>, F6: Into<Option<EPlatform>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<EUIType>>, F10: Into<Option<bool>>, F11: Into<Option<bool>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<String>>, F17: Into<Option<Vec<ActiveDependency>>>, F18: Into<Option<String>>, F19: Into<Option<String>>, F20: Into<Option<String>>, F21: Into<Option<String>>, F22: Into<Option<Vec<String>>> {
    SettingItem {
      id: id.into(),
      display: display.into(),
      data_type: data_type.into(),
      data_value: data_value.into(),
      data_list: data_list.into(),
      platform: platform.into(),
      summary: summary.into(),
      description: description.into(),
      u_i_type: u_i_type.into(),
      dev_mode_only: dev_mode_only.into(),
      internal_only: internal_only.into(),
      read_only: read_only.into(),
      is_valid: is_valid.into(),
      is_active: is_active.into(),
      has_new: has_new.into(),
      validation: validation.into(),
      active_dependencies: active_dependencies.into(),
      action_name: action_name.into(),
      action_object: action_object.into(),
      action_on_set_value: action_on_set_value.into(),
      action_on_get_value: action_on_get_value.into(),
      tags: tags.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<DataListItem> = None;
    let mut f_6: Option<EPlatform> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<EUIType> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = Some(false);
    let mut f_14: Option<bool> = Some(false);
    let mut f_15: Option<bool> = Some(false);
    let mut f_16: Option<String> = None;
    let mut f_17: Option<Vec<ActiveDependency>> = None;
    let mut f_18: Option<String> = None;
    let mut f_19: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_21: Option<String> = None;
    let mut f_22: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = DataListItem::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = EPlatform::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = EUIType::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ActiveDependency> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = ActiveDependency::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_string()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_string()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        22 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = i_prot.read_string()?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_22 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingItem {
      id: f_1,
      display: f_2,
      data_type: f_3,
      data_value: f_4,
      data_list: f_5,
      platform: f_6,
      summary: f_7,
      description: f_8,
      u_i_type: f_9,
      dev_mode_only: f_10,
      internal_only: f_11,
      read_only: f_12,
      is_valid: f_13,
      is_active: f_14,
      has_new: f_15,
      validation: f_16,
      active_dependencies: f_17,
      action_name: f_18,
      action_object: f_19,
      action_on_set_value: f_20,
      action_on_get_value: f_21,
      tags: f_22,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display {
      o_prot.write_field_begin(&TFieldIdentifier::new("display", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataValue", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataList", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.platform {
      o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.summary {
      o_prot.write_field_begin(&TFieldIdentifier::new("summary", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.u_i_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("UIType", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.dev_mode_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("devModeOnly", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.internal_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("internalOnly", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("readOnly", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_valid {
      o_prot.write_field_begin(&TFieldIdentifier::new("isValid", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_active {
      o_prot.write_field_begin(&TFieldIdentifier::new("isActive", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_new {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasNew", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.validation {
      o_prot.write_field_begin(&TFieldIdentifier::new("validation", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.active_dependencies {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeDependencies", TType::List, 17))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionName", TType::String, 18))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_object {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionObject", TType::String, 19))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_on_set_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionOnSetValue", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_on_get_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionOnGetValue", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("Tags", TType::List, 22))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingItem {
  fn default() -> Self {
    SettingItem{
      id: Some("".to_owned()),
      display: Some("".to_owned()),
      data_type: Some("".to_owned()),
      data_value: Some("".to_owned()),
      data_list: None,
      platform: None,
      summary: Some("".to_owned()),
      description: Some("".to_owned()),
      u_i_type: None,
      dev_mode_only: Some(false),
      internal_only: Some(false),
      read_only: Some(false),
      is_valid: Some(false),
      is_active: Some(false),
      has_new: Some(false),
      validation: Some("".to_owned()),
      active_dependencies: Some(Vec::new()),
      action_name: Some("".to_owned()),
      action_object: Some("".to_owned()),
      action_on_set_value: Some("".to_owned()),
      action_on_get_value: Some("".to_owned()),
      tags: Some(Vec::new()),
    }
  }
}

//
// SettingCategory
//

/// @SettingCategory_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingCategory {
  /// @SettingCategory_id_desc
  pub id: Option<String>,
  /// @SettingCategory_display_desc
  pub display: Option<String>,
  /// @SettingCategory_summary_desc
  pub summary: Option<String>,
  /// @SettingCategory_description_desc
  pub description: Option<String>,
  /// @SettingCategory_icon_desc
  pub icon: Option<String>,
  /// @SettingCategory_sortingPriority_desc
  pub sorting_priority: Option<i32>,
  /// @SettingCategory_isSystemCategory_desc
  pub is_system_category: Option<bool>,
  /// @SettingCategory_items_desc
  pub items: Option<BTreeMap<String, i32>>,
  /// @SettingCategory_enable_desc
  pub enable: Option<bool>,
  /// @SettingCategory_showInUI_desc
  pub show_in_u_i: Option<bool>,
  /// @SettingCategory_script_desc
  pub script: Option<String>,
  /// @SettingCategory_Tags_desc
  pub tags: Option<Vec<String>>,
}

impl SettingCategory {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(id: F1, display: F2, summary: F3, description: F4, icon: F5, sorting_priority: F6, is_system_category: F7, items: F8, enable: F9, show_in_u_i: F10, script: F11, tags: F12) -> SettingCategory where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<bool>>, F8: Into<Option<BTreeMap<String, i32>>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<String>>, F12: Into<Option<Vec<String>>> {
    SettingCategory {
      id: id.into(),
      display: display.into(),
      summary: summary.into(),
      description: description.into(),
      icon: icon.into(),
      sorting_priority: sorting_priority.into(),
      is_system_category: is_system_category.into(),
      items: items.into(),
      enable: enable.into(),
      show_in_u_i: show_in_u_i.into(),
      script: script.into(),
      tags: tags.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingCategory> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<BTreeMap<String, i32>> = Some(BTreeMap::new());
    let mut f_9: Option<bool> = Some(false);
    let mut f_10: Option<bool> = Some(false);
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<Vec<String>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_6 = i_prot.read_string()?;
            let map_val_7 = i_prot.read_i32()?;
            val.insert(map_key_6, map_val_7);
          }
          i_prot.read_map_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingCategory {
      id: f_1,
      display: f_2,
      summary: f_3,
      description: f_4,
      icon: f_5,
      sorting_priority: f_6,
      is_system_category: f_7,
      items: f_8,
      enable: f_9,
      show_in_u_i: f_10,
      script: f_11,
      tags: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingCategory");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display {
      o_prot.write_field_begin(&TFieldIdentifier::new("display", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.summary {
      o_prot.write_field_begin(&TFieldIdentifier::new("summary", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.icon {
      o_prot.write_field_begin(&TFieldIdentifier::new("icon", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sorting_priority {
      o_prot.write_field_begin(&TFieldIdentifier::new("sortingPriority", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_system_category {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSystemCategory", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.items {
      o_prot.write_field_begin(&TFieldIdentifier::new("items", TType::Map, 8))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.enable {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.show_in_u_i {
      o_prot.write_field_begin(&TFieldIdentifier::new("showInUI", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.script {
      o_prot.write_field_begin(&TFieldIdentifier::new("script", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.tags {
      o_prot.write_field_begin(&TFieldIdentifier::new("Tags", TType::List, 12))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingCategory {
  fn default() -> Self {
    SettingCategory{
      id: Some("".to_owned()),
      display: Some("".to_owned()),
      summary: Some("".to_owned()),
      description: Some("".to_owned()),
      icon: Some("".to_owned()),
      sorting_priority: Some(0),
      is_system_category: Some(false),
      items: Some(BTreeMap::new()),
      enable: Some(false),
      show_in_u_i: Some(false),
      script: Some("".to_owned()),
      tags: Some(Vec::new()),
    }
  }
}

//
// ModuleBaseInfo
//

/// @ModuleBaseInfo_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ModuleBaseInfo {
  /// @ModuleBaseInfo_name_desc
  pub name: Option<String>,
  /// @ModuleBaseInfo_version_desc
  pub version: Option<String>,
  /// @ModuleBaseInfo_configHash_desc
  pub config_hash: Option<i32>,
}

impl ModuleBaseInfo {
  pub fn new<F1, F2, F3>(name: F1, version: F2, config_hash: F3) -> ModuleBaseInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>> {
    ModuleBaseInfo {
      name: name.into(),
      version: version.into(),
      config_hash: config_hash.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ModuleBaseInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ModuleBaseInfo {
      name: f_1,
      version: f_2,
      config_hash: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ModuleBaseInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.config_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("configHash", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ModuleBaseInfo {
  fn default() -> Self {
    ModuleBaseInfo{
      name: Some("".to_owned()),
      version: Some("".to_owned()),
      config_hash: Some(0),
    }
  }
}

//
// ModuleSetting
//

/// @ModuleSetting_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ModuleSetting {
  /// @ModuleSetting_baseInfo_desc
  pub base_info: Option<ModuleBaseInfo>,
  /// @ModuleSetting_settings_desc
  pub settings: Option<Vec<SettingItem>>,
  /// @ModuleSetting_categories_desc
  pub categories: Option<Vec<SettingCategory>>,
}

impl ModuleSetting {
  pub fn new<F1, F2, F3>(base_info: F1, settings: F2, categories: F3) -> ModuleSetting where F1: Into<Option<ModuleBaseInfo>>, F2: Into<Option<Vec<SettingItem>>>, F3: Into<Option<Vec<SettingCategory>>> {
    ModuleSetting {
      base_info: base_info.into(),
      settings: settings.into(),
      categories: categories.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ModuleSetting> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ModuleBaseInfo> = None;
    let mut f_2: Option<Vec<SettingItem>> = Some(Vec::new());
    let mut f_3: Option<Vec<SettingCategory>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ModuleBaseInfo::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SettingItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = SettingItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SettingCategory> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = SettingCategory::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ModuleSetting {
      base_info: f_1,
      settings: f_2,
      categories: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ModuleSetting");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.base_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("baseInfo", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.settings {
      o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.categories {
      o_prot.write_field_begin(&TFieldIdentifier::new("categories", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ModuleSetting {
  fn default() -> Self {
    ModuleSetting{
      base_info: None,
      settings: Some(Vec::new()),
      categories: Some(Vec::new()),
    }
  }
}

//
// AppDataRecord
//

/// @AppDataRecord_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppDataRecord {
  /// @AppDataRecord_id_desc
  pub id: Option<String>,
  /// @AppDataRecord_content_desc
  pub content: Option<SettingValue>,
}

impl AppDataRecord {
  pub fn new<F1, F2>(id: F1, content: F2) -> AppDataRecord where F1: Into<Option<String>>, F2: Into<Option<SettingValue>> {
    AppDataRecord {
      id: id.into(),
      content: content.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppDataRecord> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<SettingValue> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SettingValue::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppDataRecord {
      id: f_1,
      content: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppDataRecord");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppDataRecord {
  fn default() -> Self {
    AppDataRecord{
      id: Some("".to_owned()),
      content: None,
    }
  }
}

//
// AppDataCollection
//

/// @AppDataCollection_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppDataCollection {
  /// @AppDataCollection_category_desc
  pub category: Option<String>,
  /// @AppDataCollection_records_desc
  pub records: Option<Vec<AppDataRecord>>,
}

impl AppDataCollection {
  pub fn new<F1, F2>(category: F1, records: F2) -> AppDataCollection where F1: Into<Option<String>>, F2: Into<Option<Vec<AppDataRecord>>> {
    AppDataCollection {
      category: category.into(),
      records: records.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppDataCollection> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<AppDataRecord>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<AppDataRecord> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = AppDataRecord::read_from_in_protocol(i_prot)?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppDataCollection {
      category: f_1,
      records: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppDataCollection");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.category {
      o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.records {
      o_prot.write_field_begin(&TFieldIdentifier::new("records", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppDataCollection {
  fn default() -> Self {
    AppDataCollection{
      category: Some("".to_owned()),
      records: Some(Vec::new()),
    }
  }
}

//
// AppData
//

/// @AppData_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppData {
  /// @AppData_appId_desc
  pub app_id: Option<String>,
  /// @AppData_data_desc
  pub data: Option<Vec<AppDataCollection>>,
}

impl AppData {
  pub fn new<F1, F2>(app_id: F1, data: F2) -> AppData where F1: Into<Option<String>>, F2: Into<Option<Vec<AppDataCollection>>> {
    AppData {
      app_id: app_id.into(),
      data: data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<AppDataCollection>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<AppDataCollection> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = AppDataCollection::read_from_in_protocol(i_prot)?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppData {
      app_id: f_1,
      data: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.app_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("appId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppData {
  fn default() -> Self {
    AppData{
      app_id: Some("".to_owned()),
      data: Some(Vec::new()),
    }
  }
}

//
// TitleMainIconNotification
//

/// @TitleMainIconNotification_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TitleMainIconNotification {
  /// @TitleMainIconNotification_Title
  pub title: Option<String>,
  /// @TitleMainIconNotification_MainIcon
  pub main_icon: Option<String>,
  /// @enum.NotificationType_Desc
  pub notification_type: Option<TitleMainIconNotificationType>,
}

impl TitleMainIconNotification {
  pub fn new<F1, F2, F3>(title: F1, main_icon: F2, notification_type: F3) -> TitleMainIconNotification where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<TitleMainIconNotificationType>> {
    TitleMainIconNotification {
      title: title.into(),
      main_icon: main_icon.into(),
      notification_type: notification_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<TitleMainIconNotification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<TitleMainIconNotificationType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TitleMainIconNotificationType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TitleMainIconNotification {
      title: f_1,
      main_icon: f_2,
      notification_type: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TitleMainIconNotification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.main_icon {
      o_prot.write_field_begin(&TFieldIdentifier::new("mainIcon", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.notification_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("NotificationType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TitleMainIconNotification {
  fn default() -> Self {
    TitleMainIconNotification{
      title: Some("".to_owned()),
      main_icon: Some("".to_owned()),
      notification_type: None,
    }
  }
}

//
// AppBaseInfo
//

/// @AppBaseInfo_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppBaseInfo {
  /// @AppBaseInfo_appId_desc
  pub app_id: Option<String>,
  /// @AppBaseInfo_name_desc
  pub name: Option<String>,
  /// @AppBaseInfo_icon_hd_desc
  pub icon_hd: Option<String>,
  /// @AppBaseInfo_icon_ld_desc
  pub icon_ld: Option<String>,
  /// @AppBaseInfo_description_desc
  pub description: Option<String>,
  /// @AppBaseInfo_properties_desc
  pub properties: Option<Vec<String>>,
  /// @AppBaseInfo_platform_desc
  pub platform: Option<Vec<String>>,
  /// @AppBaseInfo_size_desc
  pub size: Option<i32>,
  /// @AppBaseInfo_languages_desc
  pub languages: Option<Vec<String>>,
}

impl AppBaseInfo {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9>(app_id: F1, name: F2, icon_hd: F3, icon_ld: F4, description: F5, properties: F6, platform: F7, size: F8, languages: F9) -> AppBaseInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<Vec<String>>>, F7: Into<Option<Vec<String>>>, F8: Into<Option<i32>>, F9: Into<Option<Vec<String>>> {
    AppBaseInfo {
      app_id: app_id.into(),
      name: name.into(),
      icon_hd: icon_hd.into(),
      icon_ld: icon_ld.into(),
      description: description.into(),
      properties: properties.into(),
      platform: platform.into(),
      size: size.into(),
      languages: languages.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppBaseInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<Vec<String>> = Some(Vec::new());
    let mut f_7: Option<Vec<String>> = Some(Vec::new());
    let mut f_8: Option<i32> = Some(0);
    let mut f_9: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_13 = i_prot.read_string()?;
            val.push(list_elem_13);
          }
          i_prot.read_list_end()?;
          f_6 = Some(val);
        },
        7 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_14 = i_prot.read_string()?;
            val.push(list_elem_14);
          }
          i_prot.read_list_end()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        9 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_15 = i_prot.read_string()?;
            val.push(list_elem_15);
          }
          i_prot.read_list_end()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppBaseInfo {
      app_id: f_1,
      name: f_2,
      icon_hd: f_3,
      icon_ld: f_4,
      description: f_5,
      properties: f_6,
      platform: f_7,
      size: f_8,
      languages: f_9,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppBaseInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.app_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("appId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.icon_hd {
      o_prot.write_field_begin(&TFieldIdentifier::new("icon_hd", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.icon_ld {
      o_prot.write_field_begin(&TFieldIdentifier::new("icon_ld", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.properties {
      o_prot.write_field_begin(&TFieldIdentifier::new("properties", TType::List, 6))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.platform {
      o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::List, 7))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.size {
      o_prot.write_field_begin(&TFieldIdentifier::new("size", TType::I32, 8))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.languages {
      o_prot.write_field_begin(&TFieldIdentifier::new("languages", TType::List, 9))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppBaseInfo {
  fn default() -> Self {
    AppBaseInfo{
      app_id: Some("".to_owned()),
      name: Some("".to_owned()),
      icon_hd: Some("".to_owned()),
      icon_ld: Some("".to_owned()),
      description: Some("".to_owned()),
      properties: Some(Vec::new()),
      platform: Some(Vec::new()),
      size: Some(0),
      languages: Some(Vec::new()),
    }
  }
}

//
// EventNotification
//

/// @EventNotification_Summary
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EventNotification {
  /// @EventNotification_key_desc
  pub key: Option<String>,
  /// @EventNotification_contents_desc
  pub contents: Option<JSON>,
}

impl EventNotification {
  pub fn new<F1, F2>(key: F1, contents: F2) -> EventNotification where F1: Into<Option<String>>, F2: Into<Option<JSON>> {
    EventNotification {
      key: key.into(),
      contents: contents.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<EventNotification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<JSON> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EventNotification {
      key: f_1,
      contents: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EventNotification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contents {
      o_prot.write_field_begin(&TFieldIdentifier::new("contents", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for EventNotification {
  fn default() -> Self {
    EventNotification{
      key: Some("".to_owned()),
      contents: Some("".to_owned()),
    }
  }
}

