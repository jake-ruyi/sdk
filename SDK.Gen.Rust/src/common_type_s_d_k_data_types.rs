// Autogenerated by Thrift Compiler (0.11.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum LoginState {
  /// Logout state
  LOGOUT = 0,
  /// Login state
  LOGIN = 1,
}

impl LoginState {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<LoginState> {
    let enum_value = i_prot.read_i32()?;
    LoginState::try_from(enum_value)  }
}

impl TryFrom<i32> for LoginState {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(LoginState::LOGOUT),
      1 => Ok(LoginState::LOGIN),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to LoginState", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum TitleMainIconNotificationType {
  FRIENDREQUEST = 0,
  FRIENDACCEPT = 1,
  BLUETOOTHDEVICESTATUSCHANGED = 2,
  NETWORKSTATUSCHANGED = 3,
}

impl TitleMainIconNotificationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<TitleMainIconNotificationType> {
    let enum_value = i_prot.read_i32()?;
    TitleMainIconNotificationType::try_from(enum_value)  }
}

impl TryFrom<i32> for TitleMainIconNotificationType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(TitleMainIconNotificationType::FRIENDREQUEST),
      1 => Ok(TitleMainIconNotificationType::FRIENDACCEPT),
      2 => Ok(TitleMainIconNotificationType::BLUETOOTHDEVICESTATUSCHANGED),
      3 => Ok(TitleMainIconNotificationType::NETWORKSTATUSCHANGED),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to TitleMainIconNotificationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum InputCategory {
  GAMEPAD = 0,
  KEYBOARD = 1,
  MOUSE = 2,
  JOYSTICK = 3,
  MAXCOUNT = 4,
}

impl InputCategory {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputCategory> {
    let enum_value = i_prot.read_i32()?;
    InputCategory::try_from(enum_value)  }
}

impl TryFrom<i32> for InputCategory {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(InputCategory::GAMEPAD),
      1 => Ok(InputCategory::KEYBOARD),
      2 => Ok(InputCategory::MOUSE),
      3 => Ok(InputCategory::JOYSTICK),
      4 => Ok(InputCategory::MAXCOUNT),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to InputCategory", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RuyiGamePadButtonFlags {
  GAMEPAD_UP = 1,
  GAMEPAD_DOWN = 2,
  GAMEPAD_LEFT = 4,
  GAMEPAD_RIGHT = 8,
  GAMEPAD_START = 16,
  GAMEPAD_BACK = 32,
  GAMEPAD_L3 = 64,
  GAMEPAD_R3 = 128,
  GAMEPAD_LB = 256,
  GAMEPAD_RB = 512,
  GAMEPAD_A = 4096,
  GAMEPAD_B = 8192,
  GAMEPAD_X = 16384,
  GAMEPAD_Y = 32768,
  GAMEPAD_LT = 131072,
  GAMEPAD_RT = 262144,
  GAMEPAD_LJOYX = 524288,
  GAMEPAD_LJOYY = 1048576,
  GAMEPAD_RJOYX = 2097152,
  GAMEPAD_RJOYY = 4194304,
}

impl RuyiGamePadButtonFlags {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiGamePadButtonFlags> {
    let enum_value = i_prot.read_i32()?;
    RuyiGamePadButtonFlags::try_from(enum_value)  }
}

impl TryFrom<i32> for RuyiGamePadButtonFlags {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      1 => Ok(RuyiGamePadButtonFlags::GAMEPAD_UP),
      2 => Ok(RuyiGamePadButtonFlags::GAMEPAD_DOWN),
      4 => Ok(RuyiGamePadButtonFlags::GAMEPAD_LEFT),
      8 => Ok(RuyiGamePadButtonFlags::GAMEPAD_RIGHT),
      16 => Ok(RuyiGamePadButtonFlags::GAMEPAD_START),
      32 => Ok(RuyiGamePadButtonFlags::GAMEPAD_BACK),
      64 => Ok(RuyiGamePadButtonFlags::GAMEPAD_L3),
      128 => Ok(RuyiGamePadButtonFlags::GAMEPAD_R3),
      256 => Ok(RuyiGamePadButtonFlags::GAMEPAD_LB),
      512 => Ok(RuyiGamePadButtonFlags::GAMEPAD_RB),
      4096 => Ok(RuyiGamePadButtonFlags::GAMEPAD_A),
      8192 => Ok(RuyiGamePadButtonFlags::GAMEPAD_B),
      16384 => Ok(RuyiGamePadButtonFlags::GAMEPAD_X),
      32768 => Ok(RuyiGamePadButtonFlags::GAMEPAD_Y),
      131072 => Ok(RuyiGamePadButtonFlags::GAMEPAD_LT),
      262144 => Ok(RuyiGamePadButtonFlags::GAMEPAD_RT),
      524288 => Ok(RuyiGamePadButtonFlags::GAMEPAD_LJOYX),
      1048576 => Ok(RuyiGamePadButtonFlags::GAMEPAD_LJOYY),
      2097152 => Ok(RuyiGamePadButtonFlags::GAMEPAD_RJOYX),
      4194304 => Ok(RuyiGamePadButtonFlags::GAMEPAD_RJOYY),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to RuyiGamePadButtonFlags", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EPlatform {
  NONE = 0,
  PC = 1,
  CONSOLE = 2,
  ALL = 3,
}

impl EPlatform {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<EPlatform> {
    let enum_value = i_prot.read_i32()?;
    EPlatform::try_from(enum_value)  }
}

impl TryFrom<i32> for EPlatform {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(EPlatform::NONE),
      1 => Ok(EPlatform::PC),
      2 => Ok(EPlatform::CONSOLE),
      3 => Ok(EPlatform::ALL),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EPlatform", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum EUIType {
  NONE = 0,
  TOGGLE = 1,
  TEXT = 2,
  SLIDER = 3,
  CHECKLIST = 4,
  OPTIONLIST = 5,
  DATETIME = 6,
  INPUTTEXTWITHLABEL = 7,
  BUTTON = 8,
  INPUTTEXT = 9,
}

impl EUIType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<EUIType> {
    let enum_value = i_prot.read_i32()?;
    EUIType::try_from(enum_value)  }
}

impl TryFrom<i32> for EUIType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(EUIType::NONE),
      1 => Ok(EUIType::TOGGLE),
      2 => Ok(EUIType::TEXT),
      3 => Ok(EUIType::SLIDER),
      4 => Ok(EUIType::CHECKLIST),
      5 => Ok(EUIType::OPTIONLIST),
      6 => Ok(EUIType::DATETIME),
      7 => Ok(EUIType::INPUTTEXTWITHLABEL),
      8 => Ok(EUIType::BUTTON),
      9 => Ok(EUIType::INPUTTEXT),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to EUIType", i)
            )
          )
        )
      },
    }
  }
}

pub type JSON = String;

//
// ErrorException
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ErrorException {
  pub err_id: Option<i32>,
  pub err_msg: Option<String>,
}

impl ErrorException {
  pub fn new<F1, F2>(err_id: F1, err_msg: F2) -> ErrorException where F1: Into<Option<i32>>, F2: Into<Option<String>> {
    ErrorException {
      err_id: err_id.into(),
      err_msg: err_msg.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ErrorException> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ErrorException {
      err_id: f_1,
      err_msg: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ErrorException");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.err_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("errId", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.err_msg {
      o_prot.write_field_begin(&TFieldIdentifier::new("errMsg", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ErrorException {
  fn default() -> Self {
    ErrorException{
      err_id: Some(0),
      err_msg: Some("".to_owned()),
    }
  }
}

impl Error for ErrorException {
  fn description(&self) -> &str {
    "remote service threw ErrorException"
  }
}

impl From<ErrorException> for thrift::Error {
  fn from(e: ErrorException) -> Self {
    thrift::Error::User(Box::new(e))
  }
}

impl Display for ErrorException {
  fn fmt(&self, f: &mut Formatter) -> fmt::Result {
    self.description().fmt(f)
  }
}

//
// Range
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Range {
  pub minimum: Option<OrderedFloat<f64>>,
  pub maximum: Option<OrderedFloat<f64>>,
}

impl Range {
  pub fn new<F1, F2>(minimum: F1, maximum: F2) -> Range where F1: Into<Option<OrderedFloat<f64>>>, F2: Into<Option<OrderedFloat<f64>>> {
    Range {
      minimum: minimum.into(),
      maximum: maximum.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Range> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Range {
      minimum: f_1,
      maximum: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("range");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.minimum {
      o_prot.write_field_begin(&TFieldIdentifier::new("minimum", TType::Double, 1))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.maximum {
      o_prot.write_field_begin(&TFieldIdentifier::new("maximum", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Range {
  fn default() -> Self {
    Range{
      minimum: Some(OrderedFloat::from(0.0)),
      maximum: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// InputModifier
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InputModifier {
  pub dead_zone: Option<Range>,
  pub scale: Option<OrderedFloat<f64>>,
}

impl InputModifier {
  pub fn new<F1, F2>(dead_zone: F1, scale: F2) -> InputModifier where F1: Into<Option<Range>>, F2: Into<Option<OrderedFloat<f64>>> {
    InputModifier {
      dead_zone: dead_zone.into(),
      scale: scale.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputModifier> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Range> = None;
    let mut f_2: Option<OrderedFloat<f64>> = Some(OrderedFloat::from(0.0));
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = Range::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InputModifier {
      dead_zone: f_1,
      scale: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InputModifier");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.dead_zone {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeadZone", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.scale {
      o_prot.write_field_begin(&TFieldIdentifier::new("Scale", TType::Double, 2))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InputModifier {
  fn default() -> Self {
    InputModifier{
      dead_zone: None,
      scale: Some(OrderedFloat::from(0.0)),
    }
  }
}

//
// ActionTrigger
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActionTrigger {
  pub id: Option<i32>,
  pub input_cagetory: Option<InputCategory>,
  pub trigger_buttons: Option<Vec<i32>>,
  pub trigger_value: Option<Vec<i32>>,
}

impl ActionTrigger {
  pub fn new<F1, F2, F3, F4>(id: F1, input_cagetory: F2, trigger_buttons: F3, trigger_value: F4) -> ActionTrigger where F1: Into<Option<i32>>, F2: Into<Option<InputCategory>>, F3: Into<Option<Vec<i32>>>, F4: Into<Option<Vec<i32>>> {
    ActionTrigger {
      id: id.into(),
      input_cagetory: input_cagetory.into(),
      trigger_buttons: trigger_buttons.into(),
      trigger_value: trigger_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ActionTrigger> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = Some(0);
    let mut f_2: Option<InputCategory> = None;
    let mut f_3: Option<Vec<i32>> = Some(Vec::new());
    let mut f_4: Option<Vec<i32>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = InputCategory::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_i32()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_i32()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActionTrigger {
      id: f_1,
      input_cagetory: f_2,
      trigger_buttons: f_3,
      trigger_value: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ActionTrigger");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("Id", TType::I32, 1))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.input_cagetory {
      o_prot.write_field_begin(&TFieldIdentifier::new("InputCagetory", TType::I32, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.trigger_buttons {
      o_prot.write_field_begin(&TFieldIdentifier::new("TriggerButtons", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.trigger_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("TriggerValue", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ActionTrigger {
  fn default() -> Self {
    ActionTrigger{
      id: Some(0),
      input_cagetory: None,
      trigger_buttons: Some(Vec::new()),
      trigger_value: Some(Vec::new()),
    }
  }
}

//
// Notification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Notification {
  pub title: Option<String>,
  pub detail: Option<String>,
  pub option: Option<Vec<String>>,
}

impl Notification {
  pub fn new<F1, F2, F3>(title: F1, detail: F2, option: F3) -> Notification where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<Vec<String>>> {
    Notification {
      title: title.into(),
      detail: detail.into(),
      option: option.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Notification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<Vec<String>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = Notification {
      title: f_1,
      detail: f_2,
      option: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("notification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.detail {
      o_prot.write_field_begin(&TFieldIdentifier::new("detail", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.option {
      o_prot.write_field_begin(&TFieldIdentifier::new("option", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for Notification {
  fn default() -> Self {
    Notification{
      title: Some("".to_owned()),
      detail: Some("".to_owned()),
      option: Some(Vec::new()),
    }
  }
}

//
// DataListItem
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataListItem {
  pub element_type: Option<String>,
  pub values: Option<Vec<String>>,
  pub remove_notification: Option<Notification>,
}

impl DataListItem {
  pub fn new<F1, F2, F3>(element_type: F1, values: F2, remove_notification: F3) -> DataListItem where F1: Into<Option<String>>, F2: Into<Option<Vec<String>>>, F3: Into<Option<Notification>> {
    DataListItem {
      element_type: element_type.into(),
      values: values.into(),
      remove_notification: remove_notification.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<DataListItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<String>> = Some(Vec::new());
    let mut f_3: Option<Notification> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_string()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = Notification::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = DataListItem {
      element_type: f_1,
      values: f_2,
      remove_notification: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("dataListItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.element_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("elementType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.values {
      o_prot.write_field_begin(&TFieldIdentifier::new("values", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::String, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_string(e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.remove_notification {
      o_prot.write_field_begin(&TFieldIdentifier::new("removeNotification", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for DataListItem {
  fn default() -> Self {
    DataListItem{
      element_type: Some("".to_owned()),
      values: Some(Vec::new()),
      remove_notification: None,
    }
  }
}

//
// ActiveDependency
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ActiveDependency {
  pub name: Option<String>,
  pub condition: Option<String>,
}

impl ActiveDependency {
  pub fn new<F1, F2>(name: F1, condition: F2) -> ActiveDependency where F1: Into<Option<String>>, F2: Into<Option<String>> {
    ActiveDependency {
      name: name.into(),
      condition: condition.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ActiveDependency> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ActiveDependency {
      name: f_1,
      condition: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("activeDependency");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.condition {
      o_prot.write_field_begin(&TFieldIdentifier::new("condition", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ActiveDependency {
  fn default() -> Self {
    ActiveDependency{
      name: Some("".to_owned()),
      condition: Some("".to_owned()),
    }
  }
}

//
// SettingValue
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingValue {
  pub data_type: Option<String>,
  pub data_value: Option<String>,
}

impl SettingValue {
  pub fn new<F1, F2>(data_type: F1, data_value: F2) -> SettingValue where F1: Into<Option<String>>, F2: Into<Option<String>> {
    SettingValue {
      data_type: data_type.into(),
      data_value: data_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingValue {
      data_type: f_1,
      data_value: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.data_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataValue", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingValue {
  fn default() -> Self {
    SettingValue{
      data_type: Some("".to_owned()),
      data_value: Some("".to_owned()),
    }
  }
}

//
// SettingItem
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingItem {
  pub id: Option<String>,
  pub display: Option<String>,
  pub data_type: Option<String>,
  pub data_value: Option<String>,
  pub data_list: Option<DataListItem>,
  pub platform: Option<EPlatform>,
  pub summary: Option<String>,
  pub description: Option<String>,
  pub u_i_type: Option<EUIType>,
  pub dev_mode_only: Option<bool>,
  pub internal_only: Option<bool>,
  pub read_only: Option<bool>,
  pub is_valid: Option<bool>,
  pub is_active: Option<bool>,
  pub has_new: Option<bool>,
  pub validation: Option<String>,
  pub active_dependencies: Option<Vec<ActiveDependency>>,
  pub action_name: Option<String>,
  pub action_object: Option<String>,
  pub action_on_set_value: Option<String>,
  pub action_on_get_value: Option<String>,
}

impl SettingItem {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15, F16, F17, F18, F19, F20, F21>(id: F1, display: F2, data_type: F3, data_value: F4, data_list: F5, platform: F6, summary: F7, description: F8, u_i_type: F9, dev_mode_only: F10, internal_only: F11, read_only: F12, is_valid: F13, is_active: F14, has_new: F15, validation: F16, active_dependencies: F17, action_name: F18, action_object: F19, action_on_set_value: F20, action_on_get_value: F21) -> SettingItem where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<DataListItem>>, F6: Into<Option<EPlatform>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<EUIType>>, F10: Into<Option<bool>>, F11: Into<Option<bool>>, F12: Into<Option<bool>>, F13: Into<Option<bool>>, F14: Into<Option<bool>>, F15: Into<Option<bool>>, F16: Into<Option<String>>, F17: Into<Option<Vec<ActiveDependency>>>, F18: Into<Option<String>>, F19: Into<Option<String>>, F20: Into<Option<String>>, F21: Into<Option<String>> {
    SettingItem {
      id: id.into(),
      display: display.into(),
      data_type: data_type.into(),
      data_value: data_value.into(),
      data_list: data_list.into(),
      platform: platform.into(),
      summary: summary.into(),
      description: description.into(),
      u_i_type: u_i_type.into(),
      dev_mode_only: dev_mode_only.into(),
      internal_only: internal_only.into(),
      read_only: read_only.into(),
      is_valid: is_valid.into(),
      is_active: is_active.into(),
      has_new: has_new.into(),
      validation: validation.into(),
      active_dependencies: active_dependencies.into(),
      action_name: action_name.into(),
      action_object: action_object.into(),
      action_on_set_value: action_on_set_value.into(),
      action_on_get_value: action_on_get_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<DataListItem> = None;
    let mut f_6: Option<EPlatform> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<EUIType> = None;
    let mut f_10: Option<bool> = None;
    let mut f_11: Option<bool> = None;
    let mut f_12: Option<bool> = None;
    let mut f_13: Option<bool> = Some(false);
    let mut f_14: Option<bool> = Some(false);
    let mut f_15: Option<bool> = Some(false);
    let mut f_16: Option<String> = None;
    let mut f_17: Option<Vec<ActiveDependency>> = None;
    let mut f_18: Option<String> = None;
    let mut f_19: Option<String> = None;
    let mut f_20: Option<String> = None;
    let mut f_21: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = DataListItem::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = EPlatform::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = EUIType::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_bool()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_bool()?;
          f_12 = Some(val);
        },
        13 => {
          let val = i_prot.read_bool()?;
          f_13 = Some(val);
        },
        14 => {
          let val = i_prot.read_bool()?;
          f_14 = Some(val);
        },
        15 => {
          let val = i_prot.read_bool()?;
          f_15 = Some(val);
        },
        16 => {
          let val = i_prot.read_string()?;
          f_16 = Some(val);
        },
        17 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<ActiveDependency> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = ActiveDependency::read_from_in_protocol(i_prot)?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_17 = Some(val);
        },
        18 => {
          let val = i_prot.read_string()?;
          f_18 = Some(val);
        },
        19 => {
          let val = i_prot.read_string()?;
          f_19 = Some(val);
        },
        20 => {
          let val = i_prot.read_string()?;
          f_20 = Some(val);
        },
        21 => {
          let val = i_prot.read_string()?;
          f_21 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingItem {
      id: f_1,
      display: f_2,
      data_type: f_3,
      data_value: f_4,
      data_list: f_5,
      platform: f_6,
      summary: f_7,
      description: f_8,
      u_i_type: f_9,
      dev_mode_only: f_10,
      internal_only: f_11,
      read_only: f_12,
      is_valid: f_13,
      is_active: f_14,
      has_new: f_15,
      validation: f_16,
      active_dependencies: f_17,
      action_name: f_18,
      action_object: f_19,
      action_on_set_value: f_20,
      action_on_get_value: f_21,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display {
      o_prot.write_field_begin(&TFieldIdentifier::new("display", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataType", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataValue", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data_list {
      o_prot.write_field_begin(&TFieldIdentifier::new("dataList", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.platform {
      o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::I32, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.summary {
      o_prot.write_field_begin(&TFieldIdentifier::new("summary", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.u_i_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("UIType", TType::I32, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.dev_mode_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("devModeOnly", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.internal_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("internalOnly", TType::Bool, 11))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.read_only {
      o_prot.write_field_begin(&TFieldIdentifier::new("readOnly", TType::Bool, 12))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_valid {
      o_prot.write_field_begin(&TFieldIdentifier::new("isValid", TType::Bool, 13))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_active {
      o_prot.write_field_begin(&TFieldIdentifier::new("isActive", TType::Bool, 14))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_new {
      o_prot.write_field_begin(&TFieldIdentifier::new("hasNew", TType::Bool, 15))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.validation {
      o_prot.write_field_begin(&TFieldIdentifier::new("validation", TType::String, 16))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.active_dependencies {
      o_prot.write_field_begin(&TFieldIdentifier::new("activeDependencies", TType::List, 17))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionName", TType::String, 18))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_object {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionObject", TType::String, 19))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_on_set_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionOnSetValue", TType::String, 20))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action_on_get_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("ActionOnGetValue", TType::String, 21))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingItem {
  fn default() -> Self {
    SettingItem{
      id: Some("".to_owned()),
      display: Some("".to_owned()),
      data_type: Some("".to_owned()),
      data_value: Some("".to_owned()),
      data_list: None,
      platform: None,
      summary: Some("".to_owned()),
      description: Some("".to_owned()),
      u_i_type: None,
      dev_mode_only: Some(false),
      internal_only: Some(false),
      read_only: Some(false),
      is_valid: Some(false),
      is_active: Some(false),
      has_new: Some(false),
      validation: Some("".to_owned()),
      active_dependencies: Some(Vec::new()),
      action_name: Some("".to_owned()),
      action_object: Some("".to_owned()),
      action_on_set_value: Some("".to_owned()),
      action_on_get_value: Some("".to_owned()),
    }
  }
}

//
// SettingCategory
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingCategory {
  pub id: Option<String>,
  pub display: Option<String>,
  pub summary: Option<String>,
  pub description: Option<String>,
  pub icon: Option<String>,
  pub sorting_priority: Option<i32>,
  pub is_system_category: Option<bool>,
  pub items: Option<BTreeMap<String, i32>>,
  pub enable: Option<bool>,
  pub show_in_u_i: Option<bool>,
  pub script: Option<String>,
}

impl SettingCategory {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11>(id: F1, display: F2, summary: F3, description: F4, icon: F5, sorting_priority: F6, is_system_category: F7, items: F8, enable: F9, show_in_u_i: F10, script: F11) -> SettingCategory where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<i32>>, F7: Into<Option<bool>>, F8: Into<Option<BTreeMap<String, i32>>>, F9: Into<Option<bool>>, F10: Into<Option<bool>>, F11: Into<Option<String>> {
    SettingCategory {
      id: id.into(),
      display: display.into(),
      summary: summary.into(),
      description: description.into(),
      icon: icon.into(),
      sorting_priority: sorting_priority.into(),
      is_system_category: is_system_category.into(),
      items: items.into(),
      enable: enable.into(),
      show_in_u_i: show_in_u_i.into(),
      script: script.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingCategory> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<i32> = Some(0);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<BTreeMap<String, i32>> = Some(BTreeMap::new());
    let mut f_9: Option<bool> = Some(false);
    let mut f_10: Option<bool> = Some(false);
    let mut f_11: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, i32> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_5 = i_prot.read_string()?;
            let map_val_6 = i_prot.read_i32()?;
            val.insert(map_key_5, map_val_6);
          }
          i_prot.read_map_end()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_bool()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_bool()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingCategory {
      id: f_1,
      display: f_2,
      summary: f_3,
      description: f_4,
      icon: f_5,
      sorting_priority: f_6,
      is_system_category: f_7,
      items: f_8,
      enable: f_9,
      show_in_u_i: f_10,
      script: f_11,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingCategory");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.display {
      o_prot.write_field_begin(&TFieldIdentifier::new("display", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.summary {
      o_prot.write_field_begin(&TFieldIdentifier::new("summary", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.description {
      o_prot.write_field_begin(&TFieldIdentifier::new("description", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.icon {
      o_prot.write_field_begin(&TFieldIdentifier::new("icon", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sorting_priority {
      o_prot.write_field_begin(&TFieldIdentifier::new("sortingPriority", TType::I32, 6))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.is_system_category {
      o_prot.write_field_begin(&TFieldIdentifier::new("isSystemCategory", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.items {
      o_prot.write_field_begin(&TFieldIdentifier::new("items", TType::Map, 8))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::I32, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        o_prot.write_i32(*v)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.enable {
      o_prot.write_field_begin(&TFieldIdentifier::new("enable", TType::Bool, 9))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.show_in_u_i {
      o_prot.write_field_begin(&TFieldIdentifier::new("showInUI", TType::Bool, 10))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.script {
      o_prot.write_field_begin(&TFieldIdentifier::new("script", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingCategory {
  fn default() -> Self {
    SettingCategory{
      id: Some("".to_owned()),
      display: Some("".to_owned()),
      summary: Some("".to_owned()),
      description: Some("".to_owned()),
      icon: Some("".to_owned()),
      sorting_priority: Some(0),
      is_system_category: Some(false),
      items: Some(BTreeMap::new()),
      enable: Some(false),
      show_in_u_i: Some(false),
      script: Some("".to_owned()),
    }
  }
}

//
// ModuleBaseInfo
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ModuleBaseInfo {
  pub name: Option<String>,
  pub version: Option<String>,
  pub config_hash: Option<i32>,
}

impl ModuleBaseInfo {
  pub fn new<F1, F2, F3>(name: F1, version: F2, config_hash: F3) -> ModuleBaseInfo where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>> {
    ModuleBaseInfo {
      name: name.into(),
      version: version.into(),
      config_hash: config_hash.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ModuleBaseInfo> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ModuleBaseInfo {
      name: f_1,
      version: f_2,
      config_hash: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ModuleBaseInfo");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.config_hash {
      o_prot.write_field_begin(&TFieldIdentifier::new("configHash", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ModuleBaseInfo {
  fn default() -> Self {
    ModuleBaseInfo{
      name: Some("".to_owned()),
      version: Some("".to_owned()),
      config_hash: Some(0),
    }
  }
}

//
// ModuleSetting
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct ModuleSetting {
  pub base_info: Option<ModuleBaseInfo>,
  pub settings: Option<Vec<SettingItem>>,
  pub categories: Option<Vec<SettingCategory>>,
}

impl ModuleSetting {
  pub fn new<F1, F2, F3>(base_info: F1, settings: F2, categories: F3) -> ModuleSetting where F1: Into<Option<ModuleBaseInfo>>, F2: Into<Option<Vec<SettingItem>>>, F3: Into<Option<Vec<SettingCategory>>> {
    ModuleSetting {
      base_info: base_info.into(),
      settings: settings.into(),
      categories: categories.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<ModuleSetting> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<ModuleBaseInfo> = None;
    let mut f_2: Option<Vec<SettingItem>> = Some(Vec::new());
    let mut f_3: Option<Vec<SettingCategory>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = ModuleBaseInfo::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SettingItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = SettingItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<SettingCategory> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = SettingCategory::read_from_in_protocol(i_prot)?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = ModuleSetting {
      base_info: f_1,
      settings: f_2,
      categories: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("ModuleSetting");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.base_info {
      o_prot.write_field_begin(&TFieldIdentifier::new("baseInfo", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.settings {
      o_prot.write_field_begin(&TFieldIdentifier::new("settings", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.categories {
      o_prot.write_field_begin(&TFieldIdentifier::new("categories", TType::List, 3))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for ModuleSetting {
  fn default() -> Self {
    ModuleSetting{
      base_info: None,
      settings: Some(Vec::new()),
      categories: Some(Vec::new()),
    }
  }
}

//
// AppDataRecord
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppDataRecord {
  /// The record ID
  pub id: Option<String>,
  /// The record value
  pub content: Option<SettingValue>,
}

impl AppDataRecord {
  pub fn new<F1, F2>(id: F1, content: F2) -> AppDataRecord where F1: Into<Option<String>>, F2: Into<Option<SettingValue>> {
    AppDataRecord {
      id: id.into(),
      content: content.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppDataRecord> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<SettingValue> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = SettingValue::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppDataRecord {
      id: f_1,
      content: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppDataRecord");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.content {
      o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppDataRecord {
  fn default() -> Self {
    AppDataRecord{
      id: Some("".to_owned()),
      content: None,
    }
  }
}

//
// AppDataCollection
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppDataCollection {
  /// The category of the records
  pub category: Option<String>,
  /// The records of the collection. See AppDataRecord
  pub records: Option<Vec<AppDataRecord>>,
}

impl AppDataCollection {
  pub fn new<F1, F2>(category: F1, records: F2) -> AppDataCollection where F1: Into<Option<String>>, F2: Into<Option<Vec<AppDataRecord>>> {
    AppDataCollection {
      category: category.into(),
      records: records.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppDataCollection> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<AppDataRecord>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<AppDataRecord> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_9 = AppDataRecord::read_from_in_protocol(i_prot)?;
            val.push(list_elem_9);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppDataCollection {
      category: f_1,
      records: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppDataCollection");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.category {
      o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.records {
      o_prot.write_field_begin(&TFieldIdentifier::new("records", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppDataCollection {
  fn default() -> Self {
    AppDataCollection{
      category: Some("".to_owned()),
      records: Some(Vec::new()),
    }
  }
}

//
// AppData
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct AppData {
  /// The App ID
  pub app_id: Option<String>,
  /// The user data of the App. See AppDataCollection
  pub data: Option<Vec<AppDataCollection>>,
}

impl AppData {
  pub fn new<F1, F2>(app_id: F1, data: F2) -> AppData where F1: Into<Option<String>>, F2: Into<Option<Vec<AppDataCollection>>> {
    AppData {
      app_id: app_id.into(),
      data: data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AppData> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<AppDataCollection>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<AppDataCollection> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_10 = AppDataCollection::read_from_in_protocol(i_prot)?;
            val.push(list_elem_10);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = AppData {
      app_id: f_1,
      data: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AppData");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.app_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("appId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.data {
      o_prot.write_field_begin(&TFieldIdentifier::new("data", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for AppData {
  fn default() -> Self {
    AppData{
      app_id: Some("".to_owned()),
      data: Some(Vec::new()),
    }
  }
}

//
// TitleMainIconNotification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TitleMainIconNotification {
  pub title: Option<String>,
  pub main_icon: Option<String>,
  pub notification_type: Option<TitleMainIconNotificationType>,
}

impl TitleMainIconNotification {
  pub fn new<F1, F2, F3>(title: F1, main_icon: F2, notification_type: F3) -> TitleMainIconNotification where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<TitleMainIconNotificationType>> {
    TitleMainIconNotification {
      title: title.into(),
      main_icon: main_icon.into(),
      notification_type: notification_type.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<TitleMainIconNotification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<TitleMainIconNotificationType> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = TitleMainIconNotificationType::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TitleMainIconNotification {
      title: f_1,
      main_icon: f_2,
      notification_type: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TitleMainIconNotification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.title {
      o_prot.write_field_begin(&TFieldIdentifier::new("title", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.main_icon {
      o_prot.write_field_begin(&TFieldIdentifier::new("mainIcon", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.notification_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("NotificationType", TType::I32, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TitleMainIconNotification {
  fn default() -> Self {
    TitleMainIconNotification{
      title: Some("".to_owned()),
      main_icon: Some("".to_owned()),
      notification_type: None,
    }
  }
}

//
// EventNotification
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct EventNotification {
  pub key: Option<String>,
  pub contents: Option<JSON>,
}

impl EventNotification {
  pub fn new<F1, F2>(key: F1, contents: F2) -> EventNotification where F1: Into<Option<String>>, F2: Into<Option<JSON>> {
    EventNotification {
      key: key.into(),
      contents: contents.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<EventNotification> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<JSON> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = EventNotification {
      key: f_1,
      contents: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("EventNotification");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("key", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.contents {
      o_prot.write_field_begin(&TFieldIdentifier::new("contents", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for EventNotification {
  fn default() -> Self {
    EventNotification{
      key: Some("".to_owned()),
      contents: Some("".to_owned()),
    }
  }
}

