// Autogenerated by Thrift Compiler (0.12.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum FriendPlatform {
  All = 0,
  BrainCloud = 1,
  Facebook = 2,
}

impl FriendPlatform {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<FriendPlatform> {
    let enum_value = i_prot.read_i32()?;
    FriendPlatform::try_from(enum_value)  }
}

impl TryFrom<i32> for FriendPlatform {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(FriendPlatform::All),
      1 => Ok(FriendPlatform::BrainCloud),
      2 => Ok(FriendPlatform::Facebook),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to FriendPlatform", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum Role {
  Owner = 0,
  Admin = 1,
  Member = 2,
  Other = 3,
}

impl Role {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<Role> {
    let enum_value = i_prot.read_i32()?;
    Role::try_from(enum_value)  }
}

impl TryFrom<i32> for Role {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(Role::Owner),
      1 => Ok(Role::Admin),
      2 => Ok(Role::Member),
      3 => Ok(Role::Other),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to Role", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum AutoJoinStrategy {
  JoinFirstGroup = 0,
  JoinRandomGroup = 1,
}

impl AutoJoinStrategy {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<AutoJoinStrategy> {
    let enum_value = i_prot.read_i32()?;
    AutoJoinStrategy::try_from(enum_value)  }
}

impl TryFrom<i32> for AutoJoinStrategy {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(AutoJoinStrategy::JoinFirstGroup),
      1 => Ok(AutoJoinStrategy::JoinRandomGroup),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to AutoJoinStrategy", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SortOrder {
  HighToLow = 0,
  LowToHigh = 1,
}

impl SortOrder {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SortOrder> {
    let enum_value = i_prot.read_i32()?;
    SortOrder::try_from(enum_value)  }
}

impl TryFrom<i32> for SortOrder {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(SortOrder::HighToLow),
      1 => Ok(SortOrder::LowToHigh),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SortOrder", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SocialLeaderboardType {
  HighValue = 0,
  Cumulative = 1,
  LastValue = 2,
  LowValue = 3,
}

impl SocialLeaderboardType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SocialLeaderboardType> {
    let enum_value = i_prot.read_i32()?;
    SocialLeaderboardType::try_from(enum_value)  }
}

impl TryFrom<i32> for SocialLeaderboardType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(SocialLeaderboardType::HighValue),
      1 => Ok(SocialLeaderboardType::Cumulative),
      2 => Ok(SocialLeaderboardType::LastValue),
      3 => Ok(SocialLeaderboardType::LowValue),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to SocialLeaderboardType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum RotationType {
  Never = 0,
  Daily = 1,
  Weekly = 2,
  Monthly = 3,
  Yearly = 4,
}

impl RotationType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RotationType> {
    let enum_value = i_prot.read_i32()?;
    RotationType::try_from(enum_value)  }
}

impl TryFrom<i32> for RotationType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(RotationType::Never),
      1 => Ok(RotationType::Daily),
      2 => Ok(RotationType::Weekly),
      3 => Ok(RotationType::Monthly),
      4 => Ok(RotationType::Yearly),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to RotationType", i)
            )
          )
        )
      },
    }
  }
}

#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum LobbyType {
  Player = 0,
  Ranked = 1,
}

impl LobbyType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<LobbyType> {
    let enum_value = i_prot.read_i32()?;
    LobbyType::try_from(enum_value)  }
}

impl TryFrom<i32> for LobbyType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(LobbyType::Player),
      1 => Ok(LobbyType::Ranked),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to LobbyType", i)
            )
          )
        )
      },
    }
  }
}

pub type JSON = String;

pub type date = i64;

//
// BCServiceStartedNotification
//

/// @BCServiceStartedNotification_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BCServiceStartedNotification {
}

impl BCServiceStartedNotification {
  pub fn new() -> BCServiceStartedNotification {
    BCServiceStartedNotification {}
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BCServiceStartedNotification> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BCServiceStartedNotification {};
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BCServiceStartedNotification");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for BCServiceStartedNotification {
  fn default() -> Self {
    BCServiceStartedNotification{}
  }
}

//
// FileUploadSuccessResult
//

/// @FileUploadSuccessResult_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FileUploadSuccessResult {
  /// @FileUploadSuccessResult_fileUploadId_desc
  pub file_upload_id: Option<String>,
  /// @FileUploadSuccessResult_jsonResponse_desc
  pub json_response: Option<String>,
}

impl FileUploadSuccessResult {
  pub fn new<F1, F2>(file_upload_id: F1, json_response: F2) -> FileUploadSuccessResult where F1: Into<Option<String>>, F2: Into<Option<String>> {
    FileUploadSuccessResult {
      file_upload_id: file_upload_id.into(),
      json_response: json_response.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<FileUploadSuccessResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FileUploadSuccessResult {
      file_upload_id: f_1,
      json_response: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FileUploadSuccessResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file_upload_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("fileUploadId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.json_response {
      o_prot.write_field_begin(&TFieldIdentifier::new("jsonResponse", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FileUploadSuccessResult {
  fn default() -> Self {
    FileUploadSuccessResult{
      file_upload_id: Some("".to_owned()),
      json_response: Some("".to_owned()),
    }
  }
}

//
// FileUploadFailedResult
//

/// @FileUploadFailedResult_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FileUploadFailedResult {
  /// @FileUploadFailedResult_fileUploadId_desc
  pub file_upload_id: Option<String>,
  /// @FileUploadFailedResult_statusCode_desc
  pub status_code: Option<i32>,
  /// @FileUploadFailedResult_reasonCode_desc
  pub reason_code: Option<i32>,
  /// @FileUploadFailedResult_jsonResponse_desc
  pub json_response: Option<String>,
}

impl FileUploadFailedResult {
  pub fn new<F1, F2, F3, F4>(file_upload_id: F1, status_code: F2, reason_code: F3, json_response: F4) -> FileUploadFailedResult where F1: Into<Option<String>>, F2: Into<Option<i32>>, F3: Into<Option<i32>>, F4: Into<Option<String>> {
    FileUploadFailedResult {
      file_upload_id: file_upload_id.into(),
      status_code: status_code.into(),
      reason_code: reason_code.into(),
      json_response: json_response.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<FileUploadFailedResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = FileUploadFailedResult {
      file_upload_id: f_1,
      status_code: f_2,
      reason_code: f_3,
      json_response: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("FileUploadFailedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.file_upload_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("fileUploadId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.status_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("statusCode", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.reason_code {
      o_prot.write_field_begin(&TFieldIdentifier::new("reasonCode", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.json_response {
      o_prot.write_field_begin(&TFieldIdentifier::new("jsonResponse", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for FileUploadFailedResult {
  fn default() -> Self {
    FileUploadFailedResult{
      file_upload_id: Some("".to_owned()),
      status_code: Some(0),
      reason_code: Some(0),
      json_response: Some("".to_owned()),
    }
  }
}

