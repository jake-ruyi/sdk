// Autogenerated by Thrift Compiler (0.12.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use brain_cloud_service_s_d_k_data_types;

//
// BrainCloudService service client
//

pub trait TBrainCloudServiceSyncClient {
  /// Creates an instance of an asynchronous match.
  fn async_match_create_match(&mut self, json_opponent_ids: String, push_notification_message: String, client_index: i32) -> thrift::Result<String>;
  /// Creates an instance of an asynchronous match with an initial turn.
  fn async_match_create_match_with_initial_turn(&mut self, json_opponent_ids: String, json_match_state: String, push_notification_message: String, next_player: String, json_summary: String, client_index: i32) -> thrift::Result<String>;
  /// Submits a turn for the given match.
  fn async_match_submit_turn(&mut self, owner_id: String, match_id: String, version: i64, json_match_state: String, push_notification_message: String, next_player: String, json_summary: String, json_statistics: String, client_index: i32) -> thrift::Result<String>;
  /// Allows the current player (only) to update Summary data without having to submit a whole turn.
  fn async_match_update_match_summary_data(&mut self, owner_id: String, match_id: String, version: i64, json_summary: String, client_index: i32) -> thrift::Result<String>;
  /// Marks the given match as complete.
  fn async_match_complete_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the current state of the given match.
  fn async_match_read_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the match history of the given match.
  fn async_match_read_match_history(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns all matches that are NOT in a COMPLETE state for which the player is involved.
  fn async_match_find_matches(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Returns all matches that are in a COMPLETE state for which the player is involved.
  fn async_match_find_complete_matches(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Marks the given match as abandoned.
  fn async_match_abandon_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Removes the match and match history from the server. DEBUG ONLY, in production it is recommended
  /// the user leave it as completed.
  fn async_match_delete_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Used to create the anonymous installation id for the brainCloud profile.
  fn authentication_generate_anonymous_id(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Initialize - initializes the identity service with a saved
  /// anonymous installation id and most recently used profile id
  fn authentication_initialize(&mut self, profile_id: String, anonymous_id: String, client_index: i32) -> thrift::Result<()>;
  /// Used to clear the saved profile id - to use in cases when the user is
  /// attempting to switch to a different app profile.
  fn authentication_clear_saved_profile_i_d(&mut self, client_index: i32) -> thrift::Result<()>;
  /// Authenticate a user anonymously with brainCloud - used for apps that don't want to bother
  /// the user to login, or for users who are sensitive to their privacy
  fn authentication_authenticate_anonymous(&mut self, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user with a custom Email and Password.  Note that the client app
  /// is responsible for collecting (and storing) the e-mail and potentially password
  /// (for convenience) in the client data.  For the greatest security,
  /// force the user to re-enter their password at each login.
  /// (Or at least give them that option).
  fn authentication_authenticate_email_password(&mut self, email: String, password: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user using a userId and password (without any validation on the userId).
  /// Similar to AuthenticateEmailPassword - except that that method has additional features to
  /// allow for e-mail validation, password resets, etc.
  fn authentication_authenticate_universal(&mut self, user_id: String, password: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user via cloud code (which in turn validates the supplied credentials against an external system).
  /// This allows the developer to extend brainCloud authentication to support other backend authentication systems.
  fn authentication_authenticate_external(&mut self, user_id: String, token: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user via wechat
  fn authentication_authenticate_phone(&mut self, phone_number: String, auth_code: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user via wechat
  fn authentication_authenticate_wechat(&mut self, open_id: String, token: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Reset Email password - Sends a password reset email to the specified address
  fn authentication_reset_email_password(&mut self, external_id: String, client_index: i32) -> thrift::Result<String>;
  /// Request an SMS code sent to a phone prior to authentication.
  fn authentication_request_sms_code(&mut self, phone_number: String, force_create: bool, is_international: bool, client_index: i32) -> thrift::Result<String>;
  fn authentication_check_username_exists(&mut self, game_id: String, player_name: String, client_index: i32) -> thrift::Result<String>;
  fn authentication_change_universal_password(&mut self, game_id: String, player_id: String, old_password: String, new_password: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the sessionId or empty string if no session present.
  fn client_get_session_id(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Returns true if the user is currently authenticated.
  /// If a session time out or session invalidation is returned from executing a
  /// sever API call, this flag will reset back to false.
  fn client_is_authenticated(&mut self, client_index: i32) -> thrift::Result<bool>;
  /// Returns true if brainCloud has been initialized.
  fn client_is_initialized(&mut self, client_index: i32) -> thrift::Result<bool>;
  /// Method initializes the BrainCloudClient.
  fn client_initialize_s_s_s(&mut self, secret_key: String, app_id: String, app_version: String, client_index: i32) -> thrift::Result<()>;
  /// Method initializes the BrainCloudClient.
  fn client_initialize_s_s_s_s(&mut self, server_u_r_l: String, secret_key: String, app_id: String, app_version: String, client_index: i32) -> thrift::Result<()>;
  /// Initialize the identity aspects of brainCloud.
  fn client_initialize_identity(&mut self, profile_id: String, anonymous_id: String, client_index: i32) -> thrift::Result<()>;
  /// Update method needs to be called regularly in order
  /// to process incoming and outgoing messages.
  fn client_update(&mut self, client_index: i32) -> thrift::Result<()>;
  /// Enable logging of brainCloud transactions (comms etc)
  fn client_enable_logging(&mut self, enable: bool, client_index: i32) -> thrift::Result<()>;
  /// Resets all messages and calls to the server
  fn client_reset_communication(&mut self, client_index: i32) -> thrift::Result<()>;
  /// Sets the packet timeouts using a list of integers that
  /// represent timeout values for each packet retry. The
  /// first item in the list represents the timeout for the first packet
  /// attempt, the second for the second packet attempt, and so on.
  /// 
  /// The number of entries in this array determines how many packet
  /// retries will occur.
  /// 
  /// By default, the packet timeout array is {10, 10, 10}
  /// 
  /// Note that this method does not change the timeout for authentication
  /// packets (use SetAuthenticationPacketTimeout method).
  fn client_set_packet_timeouts(&mut self, timeouts: Vec<i32>, client_index: i32) -> thrift::Result<()>;
  /// Sets the packet timeouts back to default.
  fn client_set_packet_timeouts_to_default(&mut self, client_index: i32) -> thrift::Result<()>;
  /// Returns the list of packet timeouts.
  fn client_get_packet_timeouts(&mut self, client_index: i32) -> thrift::Result<Vec<i32>>;
  /// Sets the authentication packet timeout which is tracked separately
  /// from all other packets. Note that authentication packets are never
  /// retried and so this value represents the total time a client would
  /// wait to receive a reply to an authentication API call. By default
  /// this timeout is set to 15 seconds.
  fn client_set_authentication_packet_timeout(&mut self, timeout_secs: i32, client_index: i32) -> thrift::Result<()>;
  /// Gets the authentication packet timeout which is tracked separately
  /// from all other packets. Note that authentication packets are never
  /// retried and so this value represents the total time a client would
  /// wait to receive a reply to an authentication API call. By default
  /// this timeout is set to 15 seconds.
  fn client_get_authentication_packet_timeout(&mut self, client_index: i32) -> thrift::Result<i32>;
  /// Returns the low transfer rate timeout in secs
  fn client_get_upload_low_transfer_rate_timeout(&mut self, client_index: i32) -> thrift::Result<i32>;
  /// Sets the timeout in seconds of a low speed upload
  /// (i.e. transfer rate which is underneath the low transfer rate threshold).
  /// By default this is set to 120 secs.Setting this value to 0 will
  /// turn off the timeout. Note that this timeout method
  /// does not work on Unity mobile platforms.
  fn client_set_upload_low_transfer_rate_timeout(&mut self, timeout_secs: i32, client_index: i32) -> thrift::Result<()>;
  /// Returns the low transfer rate threshold in bytes/sec
  fn client_get_upload_low_transfer_rate_threshold(&mut self, client_index: i32) -> thrift::Result<i32>;
  /// Sets the low transfer rate threshold of an upload in bytes/sec.
  /// If the transfer rate dips below the given threshold longer
  /// than the specified timeout, the transfer will fail.
  /// By default this is set to 50 bytes/sec. Note that this timeout method
  /// does not work on Unity mobile platforms.
  fn client_set_upload_low_transfer_rate_threshold(&mut self, bytes_per_sec: i32, client_index: i32) -> thrift::Result<()>;
  /// Enables the timeout message caching which is disabled by default.
  /// Once enabled, if a client side timeout is encountered
  /// (i.e. brainCloud server is unreachable presumably due to the client
  /// network being down) the SDK will do the following:
  /// 
  /// 1 - cache the currently queued messages to brainCloud
  /// 2 - call the network error callback
  /// 3 - then expect the app to call either:
  ///     a) RetryCachedMessages() to retry sending to brainCloud
  ///     b) FlushCachedMessages() to dump all messages in the queue.
  /// 
  /// Between steps 2 and 3, the app can prompt the user to retry connecting
  /// to brainCloud to determine whether to follow path 3a or 3b.
  /// 
  /// Note that if path 3a is followed, and another timeout is encountered,
  /// the process will begin all over again from step 1.
  /// 
  /// WARNING - the brainCloud SDK will cache *all* API calls sent
  /// when a timeout is encountered if this mechanism is enabled.
  /// This effectively freezes all communication with brainCloud.
  /// Apps must call either RetryCachedMessages() or FlushCachedMessages()
  /// for the brainCloud SDK to resume sending messages.
  /// ResetCommunication() will also clear the message cache.
  fn client_enable_network_error_message_caching(&mut self, enabled: bool, client_index: i32) -> thrift::Result<()>;
  /// Attempts to resend any cached messages. If no messages are in the cache,
  /// this method does nothing.
  fn client_retry_cached_messages(&mut self, client_index: i32) -> thrift::Result<()>;
  /// Flushes the cached messages to resume API call processing. This will dump
  /// all of the cached messages in the queue.
  fn client_flush_cached_messages(&mut self, send_api_error_callbacks: bool, client_index: i32) -> thrift::Result<()>;
  /// Inserts a marker which will tell the brainCloud comms layer
  /// to close the message bundle off at this point. Any messages queued
  /// before this method was called will likely be bundled together in
  /// the next send to the server.
  /// 
  /// To ensure that only a single message is sent to the server you would
  /// do something like this:
  /// 
  /// InsertEndOfMessageBundleMarker()
  /// SomeApiCall()
  /// InsertEndOfMessageBundleMarker()
  fn client_insert_end_of_message_bundle_marker(&mut self, client_index: i32) -> thrift::Result<()>;
  /// Sets the country code sent to brainCloud when a user authenticates.
  /// Will override any auto detected country.
  fn client_override_country_code(&mut self, country_code: String, client_index: i32) -> thrift::Result<()>;
  /// Sets the language code sent to brainCloud when a user authenticates.
  /// If the language is set to a non-ISO 639-1 standard value the game default will be used instead.
  /// Will override any auto detected language.
  fn client_override_language_code(&mut self, language_code: String, client_index: i32) -> thrift::Result<()>;
  /// Creates custom data stream page event
  fn data_stream_custom_page_event(&mut self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String>;
  /// Creates custom data stream screen event
  fn data_stream_custom_screen_event(&mut self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String>;
  /// Creates custom data stream track event
  fn data_stream_custom_track_event(&mut self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String>;
  /// Method creates a new entity on the server.
  fn entity_create_entity(&mut self, entity_type: String, json_entity_data: String, json_entity_acl: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns all user entities that match the given type.
  fn entity_get_entities_by_type(&mut self, entity_type: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates a new entity on the server. This operation results in the entity
  /// data being completely replaced by the passed in JSON string.
  fn entity_update_entity(&mut self, entity_id: String, entity_type: String, json_entity_data: String, json_entity_acl: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method updates a shared entity owned by another user. This operation results in the entity
  /// data being completely replaced by the passed in JSON string.
  fn entity_update_shared_entity(&mut self, entity_id: String, target_profile_id: String, entity_type: String, json_entity_data: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method deletes the given entity on the server.
  fn entity_delete_entity(&mut self, entity_id: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method updates a singleton entity on the server. This operation results in the entity
  /// data being completely replaced by the passed in JSON string. If the entity doesn't exist it is created.
  fn entity_update_singleton(&mut self, entity_type: String, json_entity_data: String, json_entity_acl: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method deletes the given singleton on the server.
  fn entity_delete_singleton(&mut self, entity_type: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method to get a specific entity.
  fn entity_get_entity(&mut self, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves a singleton entity on the server. If the entity doesn't exist, null is returned.
  fn entity_get_singleton(&mut self, entity_type: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns a shared entity for the given profile and entity ID.
  /// An entity is shared if its ACL allows for the currently logged
  /// in user to read the data.
  fn entity_get_shared_entity_for_profile_id(&mut self, profile_id: String, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns all shared entities for the given profile id.
  /// An entity is shared if its ACL allows for the currently logged
  /// in user to read the data.
  fn entity_get_shared_entities_for_profile_id(&mut self, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of entities from the server base on type and/or where clause
  fn entity_get_list(&mut self, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of shared entities for the specified user based on type and/or where clause
  fn entity_get_shared_entities_list_for_profile_id(&mut self, profile_id: String, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets a count of entities based on the where clause
  fn entity_get_list_count(&mut self, where_json: String, client_index: i32) -> thrift::Result<String>;
  /// Method uses a paging system to iterate through user entities.
  /// After retrieving a page of entities with this method,
  /// use GetPageOffset() to retrieve previous or next pages.
  fn entity_get_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Method to retrieve previous or next pages after having called
  /// the GetPage method.
  fn entity_get_page_offset(&mut self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Partial increment of entity data field items. Partial set of items incremented as specified.
  fn entity_increment_user_entity_data(&mut self, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Partial increment of shared entity data field items. Partial set of items incremented as specified.
  fn entity_increment_shared_user_entity_data(&mut self, entity_id: String, target_profile_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Sends an event to the designated profile id with the attached json data.
  /// Any events that have been sent to a user will show up in their
  /// incoming event mailbox. If the recordLocally flag is set to true,
  /// a copy of this event (with the exact same event id) will be stored
  /// in the sending user's "sent" event mailbox.
  fn event_send_event(&mut self, to_profile_id: String, event_type: String, json_event_data: String, client_index: i32) -> thrift::Result<String>;
  /// Updates an event in the user's incoming event mailbox.
  fn event_update_incoming_event_data(&mut self, ev_id: String, json_event_data: String, client_index: i32) -> thrift::Result<String>;
  /// Delete an event out of the user's incoming mailbox.
  fn event_delete_incoming_event(&mut self, ev_id: String, client_index: i32) -> thrift::Result<String>;
  /// Get the events currently queued for the user.
  fn event_get_events(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Prepares a user file upload. On success the file will begin uploading
  /// to the brainCloud server.To be informed of success/failure of the upload
  /// register an IFileUploadCallback with the BrainCloudClient class.
  fn file_upload_file(&mut self, cloud_path: String, cloud_filename: String, shareable: bool, replace_if_exists: bool, local_path: String, client_index: i32) -> thrift::Result<String>;
  /// Method cancels an upload. If an IFileUploadCallback has been registered with the BrainCloudClient class,
  /// the fileUploadFailed callback method will be called once the upload has been canceled.
  /// NOTE: The upload will still continue in the background on versions of Unity before 5.3
  /// and on Unity mobile platforms.
  fn file_cancel_upload(&mut self, upload_id: String, client_index: i32) -> thrift::Result<()>;
  /// Returns the progress of the given upload from 0.0 to 1.0 or -1 if upload not found.
  /// NOTE: This will always return 1 on Unity mobile platforms.
  fn file_get_upload_progress(&mut self, upload_id: String, client_index: i32) -> thrift::Result<OrderedFloat<f64>>;
  /// Returns the number of bytes uploaded or -1 if upload not found.
  /// NOTE: This will always return the total bytes to transfer on Unity mobile platforms.
  fn file_get_upload_bytes_transferred(&mut self, upload_id: String, client_index: i32) -> thrift::Result<i64>;
  /// Returns the total number of bytes that will be uploaded or -1 if upload not found.
  fn file_get_upload_total_bytes_to_transfer(&mut self, upload_id: String, client_index: i32) -> thrift::Result<i64>;
  /// List all user files
  fn file_list_user_files_s_f_o(&mut self, client_index: i32) -> thrift::Result<String>;
  /// List user files from the given cloud path
  fn file_list_user_files_s_n_s_f_o(&mut self, cloud_path: String, recurse: bool, client_index: i32) -> thrift::Result<String>;
  /// Deletes a single user file.
  fn file_delete_user_file(&mut self, cloud_path: String, cloud_file_name: String, client_index: i32) -> thrift::Result<String>;
  /// Delete multiple user files
  fn file_delete_user_files(&mut self, cloud_path: String, recurse: bool, client_index: i32) -> thrift::Result<String>;
  /// Returns the CDN URL for a file object.
  fn file_get_c_d_n_url(&mut self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String>;
  fn friend_find_user_by_universal_id(&mut self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String>;
  /// Returns a particular entity of a particular friend.
  fn friend_read_friend_entity(&mut self, entity_id: String, friend_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns entities of all friends based on type and/or subtype.
  fn friend_read_friends_entities(&mut self, entity_type: String, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of a particular friend.
  fn friend_read_friend_user_state(&mut self, friend_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of a particular user.
  fn friend_get_summary_data_for_profile_id(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of a set of users.
  fn friend_get_summary_data_for_profile_ids(&mut self, player_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of the player's friends.
  fn friend_get_summary_data_for_friends(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of player's recently met.
  fn friend_get_summary_data_for_recently_met_players(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Finds a list of users matching the search text by performing an exact
  /// search of all user names.
  fn friend_find_users_by_exact_name(&mut self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String>;
  /// Finds a list of users matching the search text by performing a substring
  /// search of all user names.
  fn friend_find_users_by_substr_name(&mut self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String>;
  /// Retrieves a list of user and friend platform information for all friends of the current user.
  fn friend_list_friends(&mut self, friend_platform: brain_cloud_service_s_d_k_data_types::FriendPlatform, include_summary_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Links the current user and the specified users as brainCloud friends.
  fn friend_add_friends(&mut self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Unlinks the current user and the specified users as brainCloud friends.
  fn friend_remove_friends(&mut self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Get users online status
  fn friend_get_users_online_status(&mut self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn friend_send_friend_invitation(&mut self, to_player_id: String, client_index: i32) -> thrift::Result<String>;
  fn friend_list_friend_invitations_received(&mut self, client_index: i32) -> thrift::Result<String>;
  fn friend_list_friend_invitations_sent(&mut self, client_index: i32) -> thrift::Result<String>;
  fn friend_accept_friend_invitation(&mut self, from_player_id: String, client_index: i32) -> thrift::Result<String>;
  fn friend_reject_friend_invitation(&mut self, from_player_id: String, client_index: i32) -> thrift::Result<String>;
  fn friend_remove_friend(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves all gamification data for the player.
  fn gamification_read_all_gamification(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves all milestones defined for the game.
  fn gamification_read_milestones(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Read all of the achievements defined for the game.
  fn gamification_read_achievements(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all defined xp levels and any rewards associated
  /// with those xp levels.
  fn gamification_read_xp_levels_meta_data(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Method retrives the list of achieved achievements.
  fn gamification_read_achieved_achievements(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the list of completed milestones.
  fn gamification_read_completed_milestones(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the list of in progress milestones
  fn gamification_read_in_progress_milestones(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves milestones of the given category.
  fn gamification_read_milestones_by_category(&mut self, category: String, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method will award the achievements specified. On success, this will
  /// call AwardThirdPartyAchievement to hook into the client-side Achievement
  /// service (ie GameCentre, Facebook etc).
  fn gamification_award_achievements(&mut self, achievement_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves all of the quests defined for the game.
  fn gamification_read_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all completed quests.
  fn gamification_read_completed_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all in progress quests.
  fn gamification_read_in_progress_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests that haven't been started.
  fn gamification_read_not_started_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests with status.
  fn gamification_read_quests_with_status(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests with a basic percentage.
  fn gamification_read_quests_with_basic_percentage(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests with a complex percentage.
  fn gamification_read_quests_with_complex_percentage(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests for the given category.
  fn gamification_read_quests_by_category(&mut self, category: String, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Sets the specified milestones' statuses to LOCKED.
  fn gamification_reset_milestones(&mut self, milestone_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method reads all the global properties of the game
  fn global_app_read_properties(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Method creates a new entity on the server.
  fn global_entity_create_entity(&mut self, entity_type: String, time_to_live: i64, json_entity_acl: String, json_entity_data: String, client_index: i32) -> thrift::Result<String>;
  /// Method creates a new entity on the server with an indexed id.
  fn global_entity_create_entity_with_indexed_id(&mut self, entity_type: String, indexed_id: String, time_to_live: i64, json_entity_acl: String, json_entity_data: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity on the server.
  fn global_entity_update_entity(&mut self, entity_id: String, version: i32, json_entity_data: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity's Acl on the server.
  fn global_entity_update_entity_acl(&mut self, entity_id: String, version: i32, json_entity_acl: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity's time to live on the server.
  fn global_entity_update_entity_time_to_live(&mut self, entity_id: String, version: i32, time_to_live: i64, client_index: i32) -> thrift::Result<String>;
  /// Method deletes an existing entity on the server.
  fn global_entity_delete_entity(&mut self, entity_id: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method reads an existing entity from the server.
  fn global_entity_read_entity(&mut self, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of entities from the server base on type and/or where clause
  fn global_entity_get_list(&mut self, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of entities from the server base on indexed id
  fn global_entity_get_list_by_indexed_id(&mut self, entity_indexed_id: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets a count of entities based on the where clause
  fn global_entity_get_list_count(&mut self, where_json: String, client_index: i32) -> thrift::Result<String>;
  /// Method uses a paging system to iterate through Global Entities.
  /// After retrieving a page of Global Entities with this method,
  /// use GetPageOffset() to retrieve previous or next pages.
  fn global_entity_get_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Method to retrieve previous or next pages after having called
  /// the GetPage method.
  fn global_entity_get_page_offset(&mut self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Partial increment of global entity data field items. Partial set of items incremented as specified.
  fn global_entity_increment_global_entity_data(&mut self, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Gets a list of up to randomCount randomly selected entities from the server based on the where condition and specified maximum return count.
  fn global_entity_get_random_entities_matching(&mut self, where_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity's Owner and Acl on the server.
  fn global_entity_update_entity_owner_and_acl(&mut self, entity_id: String, version: i64, owner_id: String, acl: brain_cloud_service_s_d_k_data_types::JSON, client_index: i32) -> thrift::Result<String>;
  /// Method clears the owner id of an existing entity and sets the Acl on the server.
  fn global_entity_make_system_entity(&mut self, entity_id: String, version: i64, acl: brain_cloud_service_s_d_k_data_types::JSON, client_index: i32) -> thrift::Result<String>;
  /// Method returns all of the global statistics.
  fn global_statistics_read_all_global_stats(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Reads a subset of global statistics as defined by the input JSON.
  fn global_statistics_read_global_stats_subset(&mut self, global_stats: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the global statistics for the given category.
  fn global_statistics_read_global_stats_for_category(&mut self, category: String, client_index: i32) -> thrift::Result<String>;
  /// Atomically increment (or decrement) global statistics.
  /// Global statistics are defined through the brainCloud portal.
  fn global_statistics_increment_global_stats(&mut self, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Apply statistics grammar to a partial set of statistics.
  fn global_statistics_process_statistics(&mut self, statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// Accept an outstanding invitation to join the group.
  fn group_accept_group_invitation(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Add a member to the group.
  fn group_add_group_member(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Approve an outstanding request to join the group.
  fn group_approve_group_join_request(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Automatically join an open group that matches the search criteria and has space available.
  fn group_auto_join_group(&mut self, group_type: String, auto_join_strategy: brain_cloud_service_s_d_k_data_types::AutoJoinStrategy, data_query_json: String, client_index: i32) -> thrift::Result<String>;
  /// Cancel an outstanding invitation to the group.
  fn group_cancel_group_invitation(&mut self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Create a group.
  fn group_create_group(&mut self, name: String, group_type: String, is_open_group: bool, acl: brain_cloud_service_s_d_k_data_types::JSON, json_data: String, json_owner_attributes: String, json_default_member_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Create a group entity.
  fn group_create_group_entity(&mut self, group_id: String, entity_type: String, is_owned_by_group_member: bool, acl: brain_cloud_service_s_d_k_data_types::JSON, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Delete a group.
  fn group_delete_group(&mut self, group_id: String, version: i64, client_index: i32) -> thrift::Result<String>;
  /// Delete a group entity.
  fn group_delete_group_entity(&mut self, group_id: String, entity_id: String, version: i64, client_index: i32) -> thrift::Result<String>;
  /// Read information on groups to which the current user belongs.
  fn group_get_my_groups(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Increment elements for the group's data field.
  fn group_increment_group_data(&mut self, group_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Increment elements for the group entity's data field.
  fn group_increment_group_entity_data(&mut self, group_id: String, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Invite a member to the group.
  fn group_invite_group_member(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Join an open group or request to join a closed group.
  fn group_join_group(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Leave a group in which the user is a member.
  fn group_leave_group(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve a page of group summary information based on the specified context.
  fn group_list_groups_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve a page of group summary information based on the encoded context
  /// and specified page offset.
  fn group_list_groups_page_by_offset(&mut self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Read information on groups to which the specified user belongs.  Access is subject to restrictions.
  fn group_list_groups_with_member(&mut self, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read the specified group.
  fn group_read_group(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read the data of the specified group.
  fn group_read_group_data(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read a page of group entity information.
  fn group_read_group_entities_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Read a page of group entity information.
  fn group_read_group_entities_page_by_offset(&mut self, encoded_context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Read the specified group entity.
  fn group_read_group_entity(&mut self, group_id: String, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read the members of the group.
  fn group_read_group_members(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Reject an outstanding invitation to join the group.
  fn group_reject_group_invitation(&mut self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Reject an outstanding request to join the group.
  fn group_reject_group_join_request(&mut self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Remove a member from the group.
  fn group_remove_group_member(&mut self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Updates a group's data.
  fn group_update_group_data(&mut self, group_id: String, version: i64, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Update a group entity.
  fn group_update_group_entity_data(&mut self, group_id: String, entity_id: String, version: i64, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Update a member of the group.
  fn group_update_group_member(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Updates a group's name.
  fn group_update_group_name(&mut self, group_id: String, name: String, client_index: i32) -> thrift::Result<String>;
  /// Attach a Email and Password identity to the current profile.
  fn identity_attach_email_identity(&mut self, email: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Merge the profile associated with the provided e=mail with the current profile.
  fn identity_merge_email_identity(&mut self, email: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Detach the e-mail identity from the current profile
  fn identity_detach_email_identity(&mut self, email: String, continue_anon: bool, client_index: i32) -> thrift::Result<String>;
  /// Attach a Universal (userId + password) identity to the current profile.
  fn identity_attach_universal_identity(&mut self, user_id: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Merge the profile associated with the provided e=mail with the current profile.
  fn identity_merge_universal_identity(&mut self, user_id: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Detach the universal identity from the current profile
  fn identity_detach_universal_identity(&mut self, user_id: String, continue_anon: bool, client_index: i32) -> thrift::Result<String>;
  /// Switch to a Child Profile
  fn identity_switch_to_child_profile(&mut self, child_profile_id: String, child_app_id: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Switches to the child profile of an app when only one profile exists
  /// If multiple profiles exist this returns an error
  fn identity_switch_to_singleton_child_profile(&mut self, child_app_id: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Attach a new identity to a parent app
  fn identity_attach_parent_with_identity(&mut self, external_id: String, authentication_token: String, authentication_type: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Switch to a Parent Profile
  fn identity_switch_to_parent_profile(&mut self, parent_level_name: String, client_index: i32) -> thrift::Result<String>;
  /// Detaches parent from this user's profile
  fn identity_detach_parent(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Returns a list of all child profiles in child Apps
  fn identity_get_child_profiles(&mut self, include_summary_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Retrieve list of identities
  fn identity_get_identities(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Retrieve list of expired identities
  fn identity_get_expired_identities(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Refreshes an identity for this user
  fn identity_refresh_identity(&mut self, external_id: String, authentication_token: String, authentication_type: String, client_index: i32) -> thrift::Result<String>;
  /// Allows email identity email address to be changed
  fn identity_change_email_identity(&mut self, old_email_address: String, password: String, new_email_address: String, update_contact_email: bool, client_index: i32) -> thrift::Result<String>;
  /// Attaches a peer identity to this user's profile
  fn identity_attach_peer_profile(&mut self, peer: String, external_id: String, authentication_token: String, authentication_type: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Detaches a peer identity from this user's profile
  fn identity_detach_peer(&mut self, peer: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieves a list of attached peer profiles
  fn identity_get_peer_profiles(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Sends a simple text email to the specified user
  fn mail_send_basic_email(&mut self, profile_id: String, subject: String, body: String, client_index: i32) -> thrift::Result<String>;
  /// Sends an advanced email to the specified user
  fn mail_send_advanced_email(&mut self, profile_id: String, json_service_params: String, client_index: i32) -> thrift::Result<String>;
  /// Sends an advanced email to the specified email address
  fn mail_send_advanced_email_by_address(&mut self, email_address: String, json_service_params: String, client_index: i32) -> thrift::Result<String>;
  /// Read match making record
  fn match_making_read(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Sets player rating
  fn match_making_set_player_rating(&mut self, player_rating: i64, client_index: i32) -> thrift::Result<String>;
  /// Resets player rating
  fn match_making_reset_player_rating(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Increments player rating
  fn match_making_increment_player_rating(&mut self, increment: i64, client_index: i32) -> thrift::Result<String>;
  /// Decrements player rating
  fn match_making_decrement_player_rating(&mut self, decrement: i64, client_index: i32) -> thrift::Result<String>;
  /// Turns shield on
  fn match_making_turn_shield_on(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Turns shield on for the specified number of minutes
  fn match_making_turn_shield_on_for(&mut self, minutes: i32, client_index: i32) -> thrift::Result<String>;
  /// Turns shield off
  fn match_making_turn_shield_off(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Increases the shield on time by specified number of minutes
  fn match_making_increment_shield_on_for(&mut self, minutes: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets the shield expiry for the given player id. Passing in a null player id
  /// will return the shield expiry for the current player. The value returned is
  /// the time in UTC millis when the shield will expire.
  fn match_making_get_shield_expiry(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players
  fn match_making_find_players(&mut self, range_delta: i64, num_matches: i64, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players with additional attributes
  fn match_making_find_players_with_attributes(&mut self, range_delta: i64, num_matches: i64, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players using a cloud code filter
  fn match_making_find_players_using_filter(&mut self, range_delta: i64, num_matches: i64, json_extra_parms: String, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players using a cloud code filter
  /// and additional attributes
  fn match_making_find_players_with_attributes_using_filter(&mut self, range_delta: i64, num_matches: i64, json_attributes: String, json_extra_parms: String, client_index: i32) -> thrift::Result<String>;
  /// Enables Match Making for the Player
  fn match_making_enable_match_making(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Disables Match Making for the Player
  fn match_making_disable_match_making(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Starts a match
  fn one_way_match_start_match(&mut self, other_player_id: String, range_delta: i64, client_index: i32) -> thrift::Result<String>;
  /// Cancels a match
  fn one_way_match_cancel_match(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Completes a match
  fn one_way_match_complete_match(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Starts a stream
  fn playback_stream_start_stream(&mut self, target_player_id: String, include_shared_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Reads a stream
  fn playback_stream_read_stream(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Ends a stream
  fn playback_stream_end_stream(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Deletes a stream
  fn playback_stream_delete_stream(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Adds a stream event
  fn playback_stream_add_event(&mut self, playback_stream_id: String, event_data: String, summary: String, client_index: i32) -> thrift::Result<String>;
  /// Gets recent streams for initiating player
  fn playback_stream_get_recent_streams_for_initiating_player(&mut self, initiating_player_id: String, max_num_streams: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets recent streams for target player
  fn playback_stream_get_recent_streams_for_target_player(&mut self, target_player_id: String, max_num_streams: i32, client_index: i32) -> thrift::Result<String>;
  /// Read the state of the currently logged in user.
  /// This method returns a JSON object describing most of the
  /// player's data: entities, statistics, level, currency.
  /// Apps will typically call this method after authenticating to get an
  /// up-to-date view of the user's data.
  fn player_state_read_user_state(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Completely deletes the user record and all data fully owned
  /// by the user. After calling this method, the user will need
  /// to re-authenticate and create a new profile.
  /// This is mostly used for debugging/qa.
  fn player_state_delete_user(&mut self, client_index: i32) -> thrift::Result<String>;
  /// This method will delete *most* data for the currently logged in user.
  /// Data which is not deleted includes: currency, credentials, and
  /// purchase transactions. ResetUser is different from DeleteUser in that
  /// the player record will continue to exist after the reset (so the user
  /// does not need to re-authenticate).
  fn player_state_reset_user(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Logs user out of server.
  fn player_state_logout(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Sets the user name.
  fn player_state_update_user_name(&mut self, user_name: String, client_index: i32) -> thrift::Result<String>;
  /// Updates the "friend summary data" associated with the logged in user.
  /// Some operations will return this summary data. For instance the social
  /// leaderboards will return the player's score in the leaderboard along
  /// with the friend summary data. Generally this data is used to provide
  /// a quick overview of the player without requiring a separate API call
  /// to read their public stats or entity data.
  fn player_state_update_summary_friend_data(&mut self, json_summary_data: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the user's attributes.
  fn player_state_get_attributes(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Update user's attributes.
  fn player_state_update_attributes(&mut self, json_attributes: String, wipe_existing: bool, client_index: i32) -> thrift::Result<String>;
  /// Remove user's attributes.
  fn player_state_remove_attributes(&mut self, attribute_names: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Updates player's picture URL.
  fn player_state_update_user_picture_url(&mut self, picture_url: String, client_index: i32) -> thrift::Result<String>;
  /// Update the user's contact email.
  /// Note this is unrelated to email authentication.
  fn player_state_update_contact_email(&mut self, contact_email: String, client_index: i32) -> thrift::Result<String>;
  /// Read all available user statistics.
  fn player_statistics_read_all_user_stats(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Reads a subset of user statistics as defined by the input JSON.
  fn player_statistics_read_user_stats_subset(&mut self, player_stats: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the user statistics for the given category.
  fn player_statistics_read_user_stats_for_category(&mut self, category: String, client_index: i32) -> thrift::Result<String>;
  /// Reset all of the statistics for this user back to their initial value.
  fn player_statistics_reset_all_user_stats(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Atomically increment (or decrement) user statistics.
  /// Any rewards that are triggered from user statistic increments
  /// will be considered. User statistics are defined through the brainCloud portal.
  /// Note also that the "xpCapped" property is returned (true/false depending on whether
  /// the xp cap is turned on and whether the user has hit it).
  fn player_statistics_increment_user_stats_s_s_f_o(&mut self, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Atomically increment (or decrement) user statistics.
  /// Any rewards that are triggered from user statistic increments
  /// will be considered. User statistics are defined through the brainCloud portal.
  /// Note also that the "xpCapped" property is returned (true/false depending on whether
  /// the xp cap is turned on and whether the user has hit it).
  fn player_statistics_increment_user_stats_d_s_f_o(&mut self, dict_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// Apply statistics grammar to a partial set of statistics.
  fn player_statistics_process_statistics(&mut self, statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// Returns JSON representing the next experience level for the user.
  fn player_statistics_get_next_experience_level(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Increments the user's experience. If the user goes up a level,
  /// the new level details will be returned along with a list of rewards.
  fn player_statistics_increment_experience_points(&mut self, xp_value: i32, client_index: i32) -> thrift::Result<String>;
  /// Sets the user's experience to an absolute value. Note that this
  /// is simply a set and will not reward the user if their level changes
  /// as a result.
  fn player_statistics_set_experience_points(&mut self, xp_value: i32, client_index: i32) -> thrift::Result<String>;
  /// Trigger an event server side that will increase the user statistics.
  /// This may cause one or more awards to be sent back to the user -
  /// could be achievements, experience, etc. Achievements will be sent by this
  /// client library to the appropriate awards service (Apple Game Center, etc).
  /// 
  /// This mechanism supercedes the PlayerStatisticsService API methods, since
  /// PlayerStatisticsService API method only update the raw statistics without
  /// triggering the rewards.
  fn player_statistics_event_trigger_stats_event(&mut self, event_name: String, event_multiplier: i32, client_index: i32) -> thrift::Result<String>;
  /// See documentation for TriggerStatsEvent for more
  /// documentation.
  fn player_statistics_event_trigger_stats_events(&mut self, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Gets the player's currency for the given currency type
  /// or all currency types if null passed in.
  fn product_get_currency(&mut self, currency_type: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets the active sales inventory for the passed-in
  /// currency type.
  fn product_get_sales_inventory(&mut self, platform: String, user_currency: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets the active sales inventory for the passed-in
  /// currency type and category.
  fn product_get_sales_inventory_by_category(&mut self, platform: String, user_currency: String, category: String, client_index: i32) -> thrift::Result<String>;
  /// Verify Microsoft Receipt. On success, the player will be awarded the
  /// associated currencies.
  fn product_verify_microsoft_receipt(&mut self, receipt: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the eligible promotions for the player.
  fn product_get_eligible_promotions(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Verify ITunes Receipt. On success, the player will be awarded the
  /// associated currencies.
  fn product_verify_itunes_receipt(&mut self, base64_enc_receipt_data: String, client_index: i32) -> thrift::Result<String>;
  /// Checks supplied text for profanity.
  fn profanity_profanity_check(&mut self, text: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String>;
  /// Replaces the characters of profanity text with a passed character(s).
  fn profanity_profanity_replace_text(&mut self, text: String, replace_symbol: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String>;
  /// Checks supplied text for profanity and returns a list of bad wors.
  fn profanity_profanity_identify_bad_words(&mut self, text: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String>;
  /// Deregisters all device tokens currently registered to the user.
  fn push_notification_deregister_all_push_notification_device_tokens(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Deregisters the given device token from the server to disable this device
  /// from receiving push notifications.
  fn push_notification_deregister_push_notification_device_token(&mut self, platform: String, token: String, client_index: i32) -> thrift::Result<String>;
  /// Registers the given device token with the server to enable this device
  /// to receive push notifications.
  fn push_notification_register_push_notification_device_token(&mut self, platform: String, token: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a simple push notification based on the passed in message.
  /// NOTE: It is possible to send a push notification to oneself.
  fn push_notification_send_simple_push_notification(&mut self, to_profile_id: String, message: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a user based on a brainCloud portal configured notification template.
  /// NOTE: It is possible to send a push notification to oneself.
  fn push_notification_send_rich_push_notification(&mut self, to_profile_id: String, notification_template_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a user based on a brainCloud portal configured notification template.
  /// Includes JSON defining the substitution params to use with the template.
  /// See the Portal documentation for more info.
  /// NOTE: It is possible to send a push notification to oneself.
  fn push_notification_send_rich_push_notification_with_params(&mut self, to_profile_id: String, notification_template_id: i32, substitution_json: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
  /// Includes JSON defining the substitution params to use with the template.
  /// See the Portal documentation for more info.
  fn push_notification_send_templated_push_notification_to_group(&mut self, group_id: String, notification_template_id: i32, substitutions_json: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
  /// Includes JSON defining the substitution params to use with the template.
  /// See the Portal documentation for more info.
  fn push_notification_send_normalized_push_notification_to_group(&mut self, group_id: String, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String>;
  /// Schedules raw notifications based on user local time.
  fn push_notification_schedule_raw_push_notification_u_t_c(&mut self, profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, start_time: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules raw notifications based on user local time.
  fn push_notification_schedule_raw_push_notification_minutes(&mut self, profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String>;
  /// Sends a raw push notification to a target user.
  fn push_notification_send_raw_push_notification(&mut self, to_profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a raw push notification to a target list of users.
  fn push_notification_send_raw_push_notification_batch(&mut self, profile_ids: Vec<String>, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a raw push notification to a target group.
  fn push_notification_send_raw_push_notification_to_group(&mut self, group_id: String, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String>;
  /// Schedules a normalized push notification to a user
  fn push_notification_schedule_normalized_push_notification_u_t_c(&mut self, profile_id: String, alert_content_json: String, custom_data_json: String, start_time: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules a normalized push notification to a user
  fn push_notification_schedule_normalized_push_notification_minutes(&mut self, profile_id: String, alert_content_json: String, custom_data_json: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules a rich push notification to a user
  fn push_notification_schedule_rich_push_notification_u_t_c(&mut self, profile_id: String, notification_template_id: i32, substitutions_json: String, start_time: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules a rich push notification to a user
  fn push_notification_schedule_rich_push_notification_minutes(&mut self, profile_id: String, notification_template_id: i32, substitutions_json: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a user consisting of alert content and custom data.
  fn push_notification_send_normalized_push_notification(&mut self, to_profile_id: String, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to multiple users consisting of alert content and custom data.
  fn push_notification_send_normalized_push_notification_batch(&mut self, profile_ids: Vec<String>, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String>;
  /// Executes a script on the server.
  fn script_run_script(&mut self, script_name: String, json_script_data: String, client_index: i32) -> thrift::Result<String>;
  /// Allows cloud script executions to be scheduled
  fn script_schedule_run_script_u_t_c(&mut self, script_name: String, json_script_data: String, start_date_in_u_t_c: brain_cloud_service_s_d_k_data_types::date, client_index: i32) -> thrift::Result<String>;
  /// Allows cloud script executions to be scheduled
  fn script_schedule_run_script_minutes(&mut self, script_name: String, json_script_data: String, minutes_from_now: i64, client_index: i32) -> thrift::Result<String>;
  /// Run a cloud script in a parent app
  fn script_run_parent_script(&mut self, script_name: String, json_script_data: String, parent_level: String, client_index: i32) -> thrift::Result<String>;
  /// Cancels a scheduled cloud code script
  fn script_cancel_scheduled_script(&mut self, job_id: String, client_index: i32) -> thrift::Result<String>;
  /// Runs a script from the context of a peer
  fn script_run_peer_script(&mut self, script_name: String, json_script_data: String, peer: String, client_index: i32) -> thrift::Result<String>;
  /// Runs a script asynchronously from the context of a peer
  /// This operation does not wait for the script to complete before returning
  fn script_run_peer_script_asynch(&mut self, script_name: String, json_script_data: String, peer: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns the social leaderboard. A player's social leaderboard is
  /// comprised of players who are recognized as being your friend.
  /// For now, this applies solely to Facebook connected players who are
  /// friends with the logged in player (who also must be Facebook connected).
  /// In the future this will expand to other identification means (such as
  /// Game Centre, Google circles etc).
  /// 
  /// Leaderboards entries contain the player's score and optionally, some user-defined
  /// data associated with the score. The currently logged in player will also
  /// be returned in the social leaderboard.
  /// 
  /// Note: If no friends have played the game, the bestScore, createdAt, updatedAt
  /// will contain NULL.
  fn social_leaderboard_get_social_leaderboard(&mut self, leaderboard_id: String, replace_name: bool, client_index: i32) -> thrift::Result<String>;
  /// Reads multiple social leaderboards.
  fn social_leaderboard_get_multi_social_leaderboard(&mut self, leaderboard_ids: Vec<String>, leaderboard_result_count: i32, replace_name: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns a page of global leaderboard results.
  /// 
  /// Leaderboards entries contain the player's score and optionally, some user-defined
  /// data associated with the score.
  /// 
  /// Note: This method allows the client to retrieve pages from within the global leaderboard list
  fn social_leaderboard_get_global_leaderboard_page(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, start_index: i32, end_index: i32, client_index: i32) -> thrift::Result<String>;
  /// Method returns a page of global leaderboard results. By using a non-current version id,
  /// the user can retrieve a historical leaderboard. See GetGlobalLeaderboardVersions method
  /// to retrieve the version id.
  fn social_leaderboard_get_global_leaderboard_page_by_version(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, start_index: i32, end_index: i32, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Method returns a view of global leaderboard results that centers on the current player.
  /// 
  /// Leaderboards entries contain the player's score and optionally, some user-defined
  /// data associated with the score.
  fn social_leaderboard_get_global_leaderboard_view(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, client_index: i32) -> thrift::Result<String>;
  /// Method returns a view of global leaderboard results that centers on the current player.
  /// By using a non-current version id, the user can retrieve a historical leaderboard.
  /// See GetGlobalLeaderboardVersions method to retrieve the version id.
  fn social_leaderboard_get_global_leaderboard_view_by_version(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets the global leaderboard versions.
  fn social_leaderboard_get_global_leaderboard_versions(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the social leaderboard for a group.
  fn social_leaderboard_get_group_social_leaderboard(&mut self, leaderboard_id: String, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Post the players score to the given social leaderboard.
  /// You can optionally send a user-defined json string of data
  /// with the posted score. This string could include information
  /// relevant to the posted score.
  /// 
  /// Note that the behaviour of posting a score can be modified in
  /// the brainCloud portal. By default, the server will only keep
  /// the player's best score.
  fn social_leaderboard_post_score_to_leaderboard(&mut self, leaderboard_id: String, score: i64, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Removes a player's score from the leaderboard
  fn social_leaderboard_remove_player_score(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Post the players score to the given social leaderboard.
  /// Pass leaderboard config data to dynamically create if necessary.
  /// You can optionally send a user-defined json string of data
  /// with the posted score. This string could include information
  /// relevant to the posted score.
  fn social_leaderboard_post_score_to_dynamic_leaderboard(&mut self, leaderboard_id: String, score: i64, json_data: String, leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType, rotation_type: brain_cloud_service_s_d_k_data_types::RotationType, rotation_reset: brain_cloud_service_s_d_k_data_types::date, retained_count: i32, client_index: i32) -> thrift::Result<String>;
  /// Post the players score to the given social leaderboard with a rotation type of DAYS.
  /// Pass leaderboard config data to dynamically create if necessary.
  /// You can optionally send a user-defined json string of data
  /// with the posted score. This string could include information
  /// relevant to the posted score.
  fn social_leaderboard_post_score_to_dynamic_leaderboard_days(&mut self, leaderboard_id: String, score: i64, json_data: String, leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType, rotation_reset: brain_cloud_service_s_d_k_data_types::date, retained_count: i32, num_days_to_rotate: i32, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the social leaderboard for a list of players.
  fn social_leaderboard_get_players_social_leaderboard(&mut self, leaderboard_id: String, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Retrieve a list of all leaderboards
  fn social_leaderboard_list_leaderboards(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Gets the number of entries in a global leaderboard
  fn social_leaderboard_get_global_leaderboard_entry_count(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Gets the number of entries in a global leaderboard
  fn social_leaderboard_get_global_leaderboard_entry_count_by_version(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets a player's score from a leaderboard
  fn social_leaderboard_get_player_score(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets a player's score from multiple leaderboards
  fn social_leaderboard_get_player_scores_from_leaderboards(&mut self, leaderboard_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method returns the server time in UTC. This is in UNIX millis time format.
  /// For instance 1396378241893 represents 2014-04-01 2:50:41.893 in GMT-4.
  fn time_read_server_time(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Processes any outstanding rewards for the given player
  fn tournament_claim_tournament_reward(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Get tournament status associated with a leaderboard
  fn tournament_get_tournament_status(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Join the specified tournament.
  /// Any entry fees will be automatically collected.
  fn tournament_join_tournament(&mut self, leaderboard_id: String, tournament_code: String, initial_score: i64, client_index: i32) -> thrift::Result<String>;
  /// Removes player's score from tournament leaderboard
  fn tournament_leave_tournament(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Post the users score to the leaderboard
  fn tournament_post_tournament_score(&mut self, leaderboard_id: String, score: i64, json_data: String, round_started_time: brain_cloud_service_s_d_k_data_types::date, client_index: i32) -> thrift::Result<String>;
  /// Post the users score to the leaderboard and returns the results
  fn tournament_post_tournament_score_with_results(&mut self, leaderboard_id: String, score: i64, json_data: String, round_started_time: brain_cloud_service_s_d_k_data_types::date, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, initial_score: i64, client_index: i32) -> thrift::Result<String>;
  /// Returns the user's expected reward based on the current scores
  fn tournament_view_current_reward(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the user's reward from a finished tournament
  fn tournament_view_reward(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Create a new lobby.
  fn lobby_create_lobby(&mut self, lobby_type: brain_cloud_service_s_d_k_data_types::LobbyType, max_slots: i32, is_open: bool, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Open a lobby so players can join.
  fn lobby_open_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Close a lobby so players can't join.
  fn lobby_close_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Find lobbies the player can join.
  fn lobby_find_lobbies(&mut self, free_slots: i32, max_results: i32, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Find lobbies with the player's friends in them.
  fn lobby_find_friends_lobbies(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Join a lobby.
  fn lobby_join_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Leave a lobby.
  fn lobby_leave_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Destroy a lobby.
  fn lobby_destroy_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Start a lobby game.
  fn lobby_start_game(&mut self, lobby_id: String, connection_string: String, client_index: i32) -> thrift::Result<String>;
  /// Get a list of lobbies the player is a member of.
  fn lobby_get_my_lobbies(&mut self, client_index: i32) -> thrift::Result<String>;
  fn party_accept_party_invitation(&mut self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn party_get_party_info(&mut self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn party_join_party(&mut self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn party_leave_party(&mut self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn party_reject_party_invitation(&mut self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn party_send_party_invitation(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn party_list_party_invitations(&mut self, client_index: i32) -> thrift::Result<String>;
  fn party_get_friends_parties(&mut self, max_results: i32, client_index: i32) -> thrift::Result<String>;
  fn party_get_my_party(&mut self, client_index: i32) -> thrift::Result<String>;
  fn patch_get_game_manifest(&mut self, game_id: String, client_index: i32) -> thrift::Result<String>;
  /// Add a product to the player's shopping cart.
  fn shopping_add_to_cart_s_i_s_f_o(&mut self, product_id: String, quantity: i32, client_index: i32) -> thrift::Result<String>;
  /// Add a product to the player's shopping cart.
  fn shopping_add_to_cart_i_s_f_o(&mut self, product_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Empty the player's shopping cart.
  fn shopping_empty_cart(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the player's current shopping cart.
  fn shopping_get_cart(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Remove an item from the player's shopping cart.
  fn shopping_remove_from_cart(&mut self, product_id: String, quantity: i32, client_index: i32) -> thrift::Result<String>;
  /// Add an item to the player's wishlist.
  fn shopping_add_to_wishlist(&mut self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// Remove all items from the player's wishlist.
  fn shopping_empty_wishlist(&mut self, client_index: i32) -> thrift::Result<String>;
  /// Returns the current player's wishlist.
  fn shopping_get_my_wishlist(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Returns the specified player's wishlist.
  fn shopping_get_wishlist(&mut self, player_id: String, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Remove an item from the player's wishlist.
  fn shopping_remove_from_wishlist_s_s_f_o(&mut self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// Remove multiple items from the player's wishlist.
  fn shopping_remove_from_wishlist_i_s_f_o(&mut self, product_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Get a list of user reviews for a product.
  fn shopping_get_user_reviews(&mut self, product_id: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Submit a user review of a product.
  fn shopping_submit_user_review(&mut self, product_id: String, review_text: String, positive: bool, client_index: i32) -> thrift::Result<String>;
  /// @3972606582
  fn shopping_like_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// @594218927
  fn shopping_unlike_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// @2222188570
  fn shopping_funny_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// @2806051775
  fn shopping_unfunny_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// Return a list of recently created products.
  fn shopping_get_recently_created_products(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Return a list of recently updated products.
  fn shopping_get_recently_updated_products(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Return a list of featured products.
  fn shopping_get_featured_products(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Return a list of the mos tpopular products.
  fn shopping_get_popular_products(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Return a list of special offers.
  fn shopping_get_special_offers(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @2304250631
  fn shopping_get_my_library(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// @1350446922
  fn shopping_get_popular_tags(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @3387279661
  fn shopping_get_products_by_tag(&mut self, tag: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @2681224790
  fn shopping_get_products_by_tags(&mut self, tags: Vec<String>, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @2681224790
  fn shopping_get_recommended_products(&mut self, count: i32, client_index: i32) -> thrift::Result<String>;
  /// @919332756
  fn shopping_get_my_orders(&mut self, include_completed: bool, client_index: i32) -> thrift::Result<String>;
  /// @2681224790
  fn shopping_get_product(&mut self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// @1777617418
  fn shopping_get_user_tags(&mut self, product_id: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @274383141
  fn shopping_get_my_user_tags(&mut self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// @3717774610
  fn shopping_submit_user_tag(&mut self, product_id: String, tag: String, client_index: i32) -> thrift::Result<String>;
  /// @3717774610
  fn shopping_submit_user_tags(&mut self, product_id: String, tags: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// @2944656417
  fn shopping_remove_user_tag(&mut self, product_id: String, tag: String, client_index: i32) -> thrift::Result<String>;
  /// @1664102245
  fn shopping_get_build_details(&mut self, product_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_video(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_screenshot(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_achievement(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_app(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_channel(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_link(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_share_game_guide(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_read_social_feed(&mut self, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn social_feed_read_filtered_social_feed(&mut self, skip: i32, limit: i32, player_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn social_feed_read_friends_social_feed(&mut self, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn social_feed_post_comment(&mut self, timestamp: i32, parent_id: String, content: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_post_comment_reply(&mut self, timestamp: i32, parent_id: String, content: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_read_comments(&mut self, skip: i32, limit: i32, parent_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_read_comment_replies(&mut self, skip: i32, limit: i32, parent_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_like_comment(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_like_activity(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_unlike_comment(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_unlike_activity(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_set_feed_visibility(&mut self, visibility: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_block_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_hide_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_unblock_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_unhide_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn social_feed_get_activity(&mut self, social_feed_id: String, depth: i32, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn social_feed_get_comment(&mut self, social_feed_id: String, depth: i32, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn telemetry_start_telemetry_session(&mut self, timestamp: i32, client_index: i32) -> thrift::Result<String>;
  fn telemetry_end_telemetry_session(&mut self, telemetry_session_id: String, timestamp: i32, client_index: i32) -> thrift::Result<String>;
  fn telemetry_log_telemetry_event(&mut self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  fn telemetry_start_telemetry_event(&mut self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  fn telemetry_end_telemetry_event(&mut self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// @Authentication_GetWeChatQRPageURL_desc
  fn authentication_get_we_chat_q_r_page_u_r_l(&mut self, client_index: i32) -> thrift::Result<String>;
  /// @BrainCloud_DownloadFile_desc
  fn file_download_file(&mut self, cloud_path: String, cloud_filename: String, replace_if_exists: bool, client_index: i32) -> thrift::Result<String>;
  /// @BrainCloud_GetDownloadInfo_desc
  fn file_get_download_info(&mut self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String>;
  /// @BrainCloud_CancelDownload_desc
  fn file_cancel_download(&mut self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String>;
}

pub trait TBrainCloudServiceSyncClientMarker {}

pub struct BrainCloudServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  _i_prot: IP,
  _o_prot: OP,
  _sequence_number: i32,
}

impl <IP, OP> BrainCloudServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  pub fn new(input_protocol: IP, output_protocol: OP) -> BrainCloudServiceSyncClient<IP, OP> {
    BrainCloudServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }
  }
}

impl <IP, OP> TThriftClient for BrainCloudServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {
  fn i_prot_mut(&mut self) -> &mut TInputProtocol { &mut self._i_prot }
  fn o_prot_mut(&mut self) -> &mut TOutputProtocol { &mut self._o_prot }
  fn sequence_number(&self) -> i32 { self._sequence_number }
  fn increment_sequence_number(&mut self) -> i32 { self._sequence_number += 1; self._sequence_number }
}

impl <IP, OP> TBrainCloudServiceSyncClientMarker for BrainCloudServiceSyncClient<IP, OP> where IP: TInputProtocol, OP: TOutputProtocol {}

impl <C: TThriftClient + TBrainCloudServiceSyncClientMarker> TBrainCloudServiceSyncClient for C {
  fn async_match_create_match(&mut self, json_opponent_ids: String, push_notification_message: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchCreateMatchArgs { json_opponent_ids: json_opponent_ids, push_notification_message: push_notification_message, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_CreateMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchCreateMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_create_match_with_initial_turn(&mut self, json_opponent_ids: String, json_match_state: String, push_notification_message: String, next_player: String, json_summary: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatchWithInitialTurn", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs { json_opponent_ids: json_opponent_ids, json_match_state: json_match_state, push_notification_message: push_notification_message, next_player: next_player, json_summary: json_summary, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_CreateMatchWithInitialTurn", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_submit_turn(&mut self, owner_id: String, match_id: String, version: i64, json_match_state: String, push_notification_message: String, next_player: String, json_summary: String, json_statistics: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_SubmitTurn", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchSubmitTurnArgs { owner_id: owner_id, match_id: match_id, version: version, json_match_state: json_match_state, push_notification_message: push_notification_message, next_player: next_player, json_summary: json_summary, json_statistics: json_statistics, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_SubmitTurn", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchSubmitTurnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_update_match_summary_data(&mut self, owner_id: String, match_id: String, version: i64, json_summary: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_UpdateMatchSummaryData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs { owner_id: owner_id, match_id: match_id, version: version, json_summary: json_summary, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_UpdateMatchSummaryData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_complete_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_CompleteMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchCompleteMatchArgs { owner_id: owner_id, match_id: match_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_CompleteMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchCompleteMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_read_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchReadMatchArgs { owner_id: owner_id, match_id: match_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_ReadMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchReadMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_read_match_history(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatchHistory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchReadMatchHistoryArgs { owner_id: owner_id, match_id: match_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_ReadMatchHistory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchReadMatchHistoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_find_matches(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_FindMatches", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchFindMatchesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_FindMatches", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchFindMatchesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_find_complete_matches(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_FindCompleteMatches", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchFindCompleteMatchesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_FindCompleteMatches", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchFindCompleteMatchesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_abandon_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_AbandonMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchAbandonMatchArgs { owner_id: owner_id, match_id: match_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_AbandonMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchAbandonMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn async_match_delete_match(&mut self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("AsyncMatch_DeleteMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAsyncMatchDeleteMatchArgs { owner_id: owner_id, match_id: match_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("AsyncMatch_DeleteMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAsyncMatchDeleteMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_generate_anonymous_id(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_GenerateAnonymousId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationGenerateAnonymousIdArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_GenerateAnonymousId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationGenerateAnonymousIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_initialize(&mut self, profile_id: String, anonymous_id: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_Initialize", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationInitializeArgs { profile_id: profile_id, anonymous_id: anonymous_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_Initialize", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationInitializeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_clear_saved_profile_i_d(&mut self, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_ClearSavedProfileID", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationClearSavedProfileIDArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_ClearSavedProfileID", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationClearSavedProfileIDResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_authenticate_anonymous(&mut self, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateAnonymous", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationAuthenticateAnonymousArgs { force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_AuthenticateAnonymous", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationAuthenticateAnonymousResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_authenticate_email_password(&mut self, email: String, password: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateEmailPassword", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs { email: email, password: password, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_AuthenticateEmailPassword", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_authenticate_universal(&mut self, user_id: String, password: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateUniversal", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationAuthenticateUniversalArgs { user_id: user_id, password: password, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_AuthenticateUniversal", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationAuthenticateUniversalResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_authenticate_external(&mut self, user_id: String, token: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateExternal", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationAuthenticateExternalArgs { user_id: user_id, token: token, external_auth_name: external_auth_name, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_AuthenticateExternal", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationAuthenticateExternalResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_authenticate_phone(&mut self, phone_number: String, auth_code: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticatePhone", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationAuthenticatePhoneArgs { phone_number: phone_number, auth_code: auth_code, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_AuthenticatePhone", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationAuthenticatePhoneResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_authenticate_wechat(&mut self, open_id: String, token: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateWechat", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationAuthenticateWechatArgs { open_id: open_id, token: token, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_AuthenticateWechat", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationAuthenticateWechatResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_reset_email_password(&mut self, external_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_ResetEmailPassword", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationResetEmailPasswordArgs { external_id: external_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_ResetEmailPassword", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationResetEmailPasswordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_request_sms_code(&mut self, phone_number: String, force_create: bool, is_international: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_RequestSmsCode", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationRequestSmsCodeArgs { phone_number: phone_number, force_create: force_create, is_international: is_international, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_RequestSmsCode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationRequestSmsCodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_check_username_exists(&mut self, game_id: String, player_name: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_CheckUsernameExists", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationCheckUsernameExistsArgs { game_id: game_id, player_name: player_name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_CheckUsernameExists", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationCheckUsernameExistsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_change_universal_password(&mut self, game_id: String, player_id: String, old_password: String, new_password: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_ChangeUniversalPassword", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationChangeUniversalPasswordArgs { game_id: game_id, player_id: player_id, old_password: old_password, new_password: new_password, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_ChangeUniversalPassword", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationChangeUniversalPasswordResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_get_session_id(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_GetSessionId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientGetSessionIdArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_GetSessionId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientGetSessionIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_is_authenticated(&mut self, client_index: i32) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_IsAuthenticated", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientIsAuthenticatedArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_IsAuthenticated", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientIsAuthenticatedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_is_initialized(&mut self, client_index: i32) -> thrift::Result<bool> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_IsInitialized", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientIsInitializedArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_IsInitialized", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientIsInitializedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_initialize_s_s_s(&mut self, secret_key: String, app_id: String, app_version: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_Initialize_SSS", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientInitializeSSSArgs { secret_key: secret_key, app_id: app_id, app_version: app_version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_Initialize_SSS", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientInitializeSSSResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_initialize_s_s_s_s(&mut self, server_u_r_l: String, secret_key: String, app_id: String, app_version: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_Initialize_SSSS", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientInitializeSSSSArgs { server_u_r_l: server_u_r_l, secret_key: secret_key, app_id: app_id, app_version: app_version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_Initialize_SSSS", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientInitializeSSSSResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_initialize_identity(&mut self, profile_id: String, anonymous_id: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_InitializeIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientInitializeIdentityArgs { profile_id: profile_id, anonymous_id: anonymous_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_InitializeIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientInitializeIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_update(&mut self, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_Update", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientUpdateArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_Update", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientUpdateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_enable_logging(&mut self, enable: bool, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_EnableLogging", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientEnableLoggingArgs { enable: enable, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_EnableLogging", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientEnableLoggingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_reset_communication(&mut self, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_ResetCommunication", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientResetCommunicationArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_ResetCommunication", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientResetCommunicationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_set_packet_timeouts(&mut self, timeouts: Vec<i32>, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_SetPacketTimeouts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientSetPacketTimeoutsArgs { timeouts: timeouts, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_SetPacketTimeouts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientSetPacketTimeoutsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_set_packet_timeouts_to_default(&mut self, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_SetPacketTimeoutsToDefault", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_SetPacketTimeoutsToDefault", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientSetPacketTimeoutsToDefaultResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_get_packet_timeouts(&mut self, client_index: i32) -> thrift::Result<Vec<i32>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_GetPacketTimeouts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientGetPacketTimeoutsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_GetPacketTimeouts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientGetPacketTimeoutsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_set_authentication_packet_timeout(&mut self, timeout_secs: i32, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_SetAuthenticationPacketTimeout", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs { timeout_secs: timeout_secs, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_SetAuthenticationPacketTimeout", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientSetAuthenticationPacketTimeoutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_get_authentication_packet_timeout(&mut self, client_index: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_GetAuthenticationPacketTimeout", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_GetAuthenticationPacketTimeout", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientGetAuthenticationPacketTimeoutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_get_upload_low_transfer_rate_timeout(&mut self, client_index: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateTimeout", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_GetUploadLowTransferRateTimeout", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_set_upload_low_transfer_rate_timeout(&mut self, timeout_secs: i32, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateTimeout", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs { timeout_secs: timeout_secs, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_SetUploadLowTransferRateTimeout", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_get_upload_low_transfer_rate_threshold(&mut self, client_index: i32) -> thrift::Result<i32> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateThreshold", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_GetUploadLowTransferRateThreshold", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientGetUploadLowTransferRateThresholdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_set_upload_low_transfer_rate_threshold(&mut self, bytes_per_sec: i32, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateThreshold", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs { bytes_per_sec: bytes_per_sec, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_SetUploadLowTransferRateThreshold", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientSetUploadLowTransferRateThresholdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_enable_network_error_message_caching(&mut self, enabled: bool, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_EnableNetworkErrorMessageCaching", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs { enabled: enabled, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_EnableNetworkErrorMessageCaching", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientEnableNetworkErrorMessageCachingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_retry_cached_messages(&mut self, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_RetryCachedMessages", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientRetryCachedMessagesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_RetryCachedMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientRetryCachedMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_flush_cached_messages(&mut self, send_api_error_callbacks: bool, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_FlushCachedMessages", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientFlushCachedMessagesArgs { send_api_error_callbacks: send_api_error_callbacks, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_FlushCachedMessages", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientFlushCachedMessagesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_insert_end_of_message_bundle_marker(&mut self, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_InsertEndOfMessageBundleMarker", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_InsertEndOfMessageBundleMarker", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_override_country_code(&mut self, country_code: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_OverrideCountryCode", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientOverrideCountryCodeArgs { country_code: country_code, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_OverrideCountryCode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientOverrideCountryCodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn client_override_language_code(&mut self, language_code: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Client_OverrideLanguageCode", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceClientOverrideLanguageCodeArgs { language_code: language_code, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Client_OverrideLanguageCode", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceClientOverrideLanguageCodeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn data_stream_custom_page_event(&mut self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DataStream_CustomPageEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceDataStreamCustomPageEventArgs { event_name: event_name, json_event_properties: json_event_properties, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DataStream_CustomPageEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceDataStreamCustomPageEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn data_stream_custom_screen_event(&mut self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DataStream_CustomScreenEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceDataStreamCustomScreenEventArgs { event_name: event_name, json_event_properties: json_event_properties, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DataStream_CustomScreenEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceDataStreamCustomScreenEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn data_stream_custom_track_event(&mut self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("DataStream_CustomTrackEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceDataStreamCustomTrackEventArgs { event_name: event_name, json_event_properties: json_event_properties, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("DataStream_CustomTrackEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceDataStreamCustomTrackEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_create_entity(&mut self, entity_type: String, json_entity_data: String, json_entity_acl: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_CreateEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityCreateEntityArgs { entity_type: entity_type, json_entity_data: json_entity_data, json_entity_acl: json_entity_acl, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_CreateEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityCreateEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_entities_by_type(&mut self, entity_type: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetEntitiesByType", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetEntitiesByTypeArgs { entity_type: entity_type, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetEntitiesByType", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetEntitiesByTypeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_update_entity(&mut self, entity_id: String, entity_type: String, json_entity_data: String, json_entity_acl: String, version: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_UpdateEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityUpdateEntityArgs { entity_id: entity_id, entity_type: entity_type, json_entity_data: json_entity_data, json_entity_acl: json_entity_acl, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_UpdateEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityUpdateEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_update_shared_entity(&mut self, entity_id: String, target_profile_id: String, entity_type: String, json_entity_data: String, version: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_UpdateSharedEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityUpdateSharedEntityArgs { entity_id: entity_id, target_profile_id: target_profile_id, entity_type: entity_type, json_entity_data: json_entity_data, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_UpdateSharedEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityUpdateSharedEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_delete_entity(&mut self, entity_id: String, version: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_DeleteEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityDeleteEntityArgs { entity_id: entity_id, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_DeleteEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityDeleteEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_update_singleton(&mut self, entity_type: String, json_entity_data: String, json_entity_acl: String, version: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_UpdateSingleton", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityUpdateSingletonArgs { entity_type: entity_type, json_entity_data: json_entity_data, json_entity_acl: json_entity_acl, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_UpdateSingleton", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityUpdateSingletonResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_delete_singleton(&mut self, entity_type: String, version: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_DeleteSingleton", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityDeleteSingletonArgs { entity_type: entity_type, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_DeleteSingleton", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityDeleteSingletonResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_entity(&mut self, entity_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetEntityArgs { entity_id: entity_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_singleton(&mut self, entity_type: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetSingleton", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetSingletonArgs { entity_type: entity_type, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetSingleton", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetSingletonResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_shared_entity_for_profile_id(&mut self, profile_id: String, entity_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetSharedEntityForProfileId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetSharedEntityForProfileIdArgs { profile_id: profile_id, entity_id: entity_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetSharedEntityForProfileId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetSharedEntityForProfileIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_shared_entities_for_profile_id(&mut self, profile_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesForProfileId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs { profile_id: profile_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetSharedEntitiesForProfileId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_list(&mut self, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetList", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetListArgs { where_json: where_json, order_by_json: order_by_json, max_return: max_return, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_shared_entities_list_for_profile_id(&mut self, profile_id: String, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesListForProfileId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs { profile_id: profile_id, where_json: where_json, order_by_json: order_by_json, max_return: max_return, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetSharedEntitiesListForProfileId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_list_count(&mut self, where_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetListCount", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetListCountArgs { where_json: where_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetListCount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetListCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetPage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetPageArgs { json_context: json_context, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetPage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetPageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_get_page_offset(&mut self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_GetPageOffset", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityGetPageOffsetArgs { context: context, page_offset: page_offset, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_GetPageOffset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityGetPageOffsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_increment_user_entity_data(&mut self, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_IncrementUserEntityData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityIncrementUserEntityDataArgs { entity_id: entity_id, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_IncrementUserEntityData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityIncrementUserEntityDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn entity_increment_shared_user_entity_data(&mut self, entity_id: String, target_profile_id: String, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Entity_IncrementSharedUserEntityData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEntityIncrementSharedUserEntityDataArgs { entity_id: entity_id, target_profile_id: target_profile_id, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Entity_IncrementSharedUserEntityData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEntityIncrementSharedUserEntityDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn event_send_event(&mut self, to_profile_id: String, event_type: String, json_event_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Event_SendEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEventSendEventArgs { to_profile_id: to_profile_id, event_type: event_type, json_event_data: json_event_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Event_SendEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEventSendEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn event_update_incoming_event_data(&mut self, ev_id: String, json_event_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Event_UpdateIncomingEventData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEventUpdateIncomingEventDataArgs { ev_id: ev_id, json_event_data: json_event_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Event_UpdateIncomingEventData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEventUpdateIncomingEventDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn event_delete_incoming_event(&mut self, ev_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Event_DeleteIncomingEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEventDeleteIncomingEventArgs { ev_id: ev_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Event_DeleteIncomingEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEventDeleteIncomingEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn event_get_events(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Event_GetEvents", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceEventGetEventsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Event_GetEvents", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceEventGetEventsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_upload_file(&mut self, cloud_path: String, cloud_filename: String, shareable: bool, replace_if_exists: bool, local_path: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_UploadFile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileUploadFileArgs { cloud_path: cloud_path, cloud_filename: cloud_filename, shareable: shareable, replace_if_exists: replace_if_exists, local_path: local_path, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_UploadFile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileUploadFileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_cancel_upload(&mut self, upload_id: String, client_index: i32) -> thrift::Result<()> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_CancelUpload", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileCancelUploadArgs { upload_id: upload_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_CancelUpload", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileCancelUploadResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_get_upload_progress(&mut self, upload_id: String, client_index: i32) -> thrift::Result<OrderedFloat<f64>> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_GetUploadProgress", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileGetUploadProgressArgs { upload_id: upload_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_GetUploadProgress", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileGetUploadProgressResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_get_upload_bytes_transferred(&mut self, upload_id: String, client_index: i32) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_GetUploadBytesTransferred", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileGetUploadBytesTransferredArgs { upload_id: upload_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_GetUploadBytesTransferred", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileGetUploadBytesTransferredResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_get_upload_total_bytes_to_transfer(&mut self, upload_id: String, client_index: i32) -> thrift::Result<i64> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_GetUploadTotalBytesToTransfer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileGetUploadTotalBytesToTransferArgs { upload_id: upload_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_GetUploadTotalBytesToTransfer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileGetUploadTotalBytesToTransferResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_list_user_files_s_f_o(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_ListUserFiles_SFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileListUserFilesSFOArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_ListUserFiles_SFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileListUserFilesSFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_list_user_files_s_n_s_f_o(&mut self, cloud_path: String, recurse: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_ListUserFiles_SNSFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileListUserFilesSNSFOArgs { cloud_path: cloud_path, recurse: recurse, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_ListUserFiles_SNSFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileListUserFilesSNSFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_delete_user_file(&mut self, cloud_path: String, cloud_file_name: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_DeleteUserFile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileDeleteUserFileArgs { cloud_path: cloud_path, cloud_file_name: cloud_file_name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_DeleteUserFile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileDeleteUserFileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_delete_user_files(&mut self, cloud_path: String, recurse: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_DeleteUserFiles", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileDeleteUserFilesArgs { cloud_path: cloud_path, recurse: recurse, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_DeleteUserFiles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileDeleteUserFilesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_get_c_d_n_url(&mut self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_GetCDNUrl", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileGetCDNUrlArgs { cloud_path: cloud_path, cloud_filename: cloud_filename, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_GetCDNUrl", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileGetCDNUrlResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_find_user_by_universal_id(&mut self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_FindUserByUniversalId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendFindUserByUniversalIdArgs { search_text: search_text, max_results: max_results, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_FindUserByUniversalId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendFindUserByUniversalIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_read_friend_entity(&mut self, entity_id: String, friend_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_ReadFriendEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendReadFriendEntityArgs { entity_id: entity_id, friend_id: friend_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_ReadFriendEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendReadFriendEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_read_friends_entities(&mut self, entity_type: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_ReadFriendsEntities", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendReadFriendsEntitiesArgs { entity_type: entity_type, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_ReadFriendsEntities", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendReadFriendsEntitiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_read_friend_user_state(&mut self, friend_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_ReadFriendUserState", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendReadFriendUserStateArgs { friend_id: friend_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_ReadFriendUserState", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendReadFriendUserStateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_get_summary_data_for_profile_id(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendGetSummaryDataForProfileIdArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_GetSummaryDataForProfileId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendGetSummaryDataForProfileIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_get_summary_data_for_profile_ids(&mut self, player_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileIds", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs { player_ids: player_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_GetSummaryDataForProfileIds", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendGetSummaryDataForProfileIdsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_get_summary_data_for_friends(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForFriends", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendGetSummaryDataForFriendsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_GetSummaryDataForFriends", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendGetSummaryDataForFriendsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_get_summary_data_for_recently_met_players(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForRecentlyMetPlayers", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_GetSummaryDataForRecentlyMetPlayers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_find_users_by_exact_name(&mut self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_FindUsersByExactName", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendFindUsersByExactNameArgs { search_text: search_text, max_results: max_results, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_FindUsersByExactName", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendFindUsersByExactNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_find_users_by_substr_name(&mut self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_FindUsersBySubstrName", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendFindUsersBySubstrNameArgs { search_text: search_text, max_results: max_results, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_FindUsersBySubstrName", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendFindUsersBySubstrNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_list_friends(&mut self, friend_platform: brain_cloud_service_s_d_k_data_types::FriendPlatform, include_summary_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_ListFriends", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendListFriendsArgs { friend_platform: friend_platform, include_summary_data: include_summary_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_ListFriends", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendListFriendsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_add_friends(&mut self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_AddFriends", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendAddFriendsArgs { profile_ids: profile_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_AddFriends", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendAddFriendsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_remove_friends(&mut self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_RemoveFriends", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendRemoveFriendsArgs { profile_ids: profile_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_RemoveFriends", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendRemoveFriendsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_get_users_online_status(&mut self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_GetUsersOnlineStatus", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendGetUsersOnlineStatusArgs { profile_ids: profile_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_GetUsersOnlineStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendGetUsersOnlineStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_send_friend_invitation(&mut self, to_player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_SendFriendInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendSendFriendInvitationArgs { to_player_id: to_player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_SendFriendInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendSendFriendInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_list_friend_invitations_received(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsReceived", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendListFriendInvitationsReceivedArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_ListFriendInvitationsReceived", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendListFriendInvitationsReceivedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_list_friend_invitations_sent(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsSent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendListFriendInvitationsSentArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_ListFriendInvitationsSent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendListFriendInvitationsSentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_accept_friend_invitation(&mut self, from_player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_AcceptFriendInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendAcceptFriendInvitationArgs { from_player_id: from_player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_AcceptFriendInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendAcceptFriendInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_reject_friend_invitation(&mut self, from_player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_RejectFriendInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendRejectFriendInvitationArgs { from_player_id: from_player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_RejectFriendInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendRejectFriendInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn friend_remove_friend(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Friend_RemoveFriend", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFriendRemoveFriendArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Friend_RemoveFriend", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFriendRemoveFriendResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_all_gamification(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadAllGamification", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadAllGamificationArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadAllGamification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadAllGamificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_milestones(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadMilestones", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadMilestonesArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadMilestones", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadMilestonesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_achievements(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadAchievements", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadAchievementsArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadAchievements", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadAchievementsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_xp_levels_meta_data(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadXpLevelsMetaData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadXpLevelsMetaDataArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadXpLevelsMetaData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadXpLevelsMetaDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_achieved_achievements(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadAchievedAchievements", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadAchievedAchievementsArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadAchievedAchievements", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadAchievedAchievementsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_completed_milestones(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedMilestones", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadCompletedMilestonesArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadCompletedMilestones", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadCompletedMilestonesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_in_progress_milestones(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressMilestones", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadInProgressMilestonesArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadInProgressMilestones", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadInProgressMilestonesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_milestones_by_category(&mut self, category: String, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadMilestonesByCategory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadMilestonesByCategoryArgs { category: category, include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadMilestonesByCategory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadMilestonesByCategoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_award_achievements(&mut self, achievement_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_AwardAchievements", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationAwardAchievementsArgs { achievement_ids: achievement_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_AwardAchievements", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationAwardAchievementsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuests", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadQuestsArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadQuests", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadQuestsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_completed_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedQuests", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadCompletedQuestsArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadCompletedQuests", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadCompletedQuestsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_in_progress_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressQuests", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadInProgressQuestsArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadInProgressQuests", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadInProgressQuestsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_not_started_quests(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadNotStartedQuests", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadNotStartedQuestsArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadNotStartedQuests", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadNotStartedQuestsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_quests_with_status(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithStatus", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadQuestsWithStatusArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadQuestsWithStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadQuestsWithStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_quests_with_basic_percentage(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithBasicPercentage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadQuestsWithBasicPercentage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_quests_with_complex_percentage(&mut self, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithComplexPercentage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs { include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadQuestsWithComplexPercentage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_read_quests_by_category(&mut self, category: String, include_meta_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsByCategory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationReadQuestsByCategoryArgs { category: category, include_meta_data: include_meta_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ReadQuestsByCategory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationReadQuestsByCategoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn gamification_reset_milestones(&mut self, milestone_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Gamification_ResetMilestones", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGamificationResetMilestonesArgs { milestone_ids: milestone_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Gamification_ResetMilestones", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGamificationResetMilestonesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_app_read_properties(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalApp_ReadProperties", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalAppReadPropertiesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalApp_ReadProperties", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalAppReadPropertiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_create_entity(&mut self, entity_type: String, time_to_live: i64, json_entity_acl: String, json_entity_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityCreateEntityArgs { entity_type: entity_type, time_to_live: time_to_live, json_entity_acl: json_entity_acl, json_entity_data: json_entity_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_CreateEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityCreateEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_create_entity_with_indexed_id(&mut self, entity_type: String, indexed_id: String, time_to_live: i64, json_entity_acl: String, json_entity_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntityWithIndexedId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs { entity_type: entity_type, indexed_id: indexed_id, time_to_live: time_to_live, json_entity_acl: json_entity_acl, json_entity_data: json_entity_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_CreateEntityWithIndexedId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_update_entity(&mut self, entity_id: String, version: i32, json_entity_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityUpdateEntityArgs { entity_id: entity_id, version: version, json_entity_data: json_entity_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_UpdateEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityUpdateEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_update_entity_acl(&mut self, entity_id: String, version: i32, json_entity_acl: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityAcl", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityUpdateEntityAclArgs { entity_id: entity_id, version: version, json_entity_acl: json_entity_acl, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_UpdateEntityAcl", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityUpdateEntityAclResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_update_entity_time_to_live(&mut self, entity_id: String, version: i32, time_to_live: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityTimeToLive", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs { entity_id: entity_id, version: version, time_to_live: time_to_live, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_UpdateEntityTimeToLive", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_delete_entity(&mut self, entity_id: String, version: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_DeleteEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityDeleteEntityArgs { entity_id: entity_id, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_DeleteEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityDeleteEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_read_entity(&mut self, entity_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_ReadEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityReadEntityArgs { entity_id: entity_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_ReadEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityReadEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_get_list(&mut self, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetList", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityGetListArgs { where_json: where_json, order_by_json: order_by_json, max_return: max_return, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_GetList", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityGetListResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_get_list_by_indexed_id(&mut self, entity_indexed_id: String, max_return: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetListByIndexedId", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityGetListByIndexedIdArgs { entity_indexed_id: entity_indexed_id, max_return: max_return, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_GetListByIndexedId", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityGetListByIndexedIdResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_get_list_count(&mut self, where_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetListCount", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityGetListCountArgs { where_json: where_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_GetListCount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityGetListCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_get_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetPage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityGetPageArgs { json_context: json_context, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_GetPage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityGetPageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_get_page_offset(&mut self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetPageOffset", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityGetPageOffsetArgs { context: context, page_offset: page_offset, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_GetPageOffset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityGetPageOffsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_increment_global_entity_data(&mut self, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_IncrementGlobalEntityData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs { entity_id: entity_id, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_IncrementGlobalEntityData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_get_random_entities_matching(&mut self, where_json: String, max_return: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetRandomEntitiesMatching", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs { where_json: where_json, max_return: max_return, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_GetRandomEntitiesMatching", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_update_entity_owner_and_acl(&mut self, entity_id: String, version: i64, owner_id: String, acl: brain_cloud_service_s_d_k_data_types::JSON, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityOwnerAndAcl", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs { entity_id: entity_id, version: version, owner_id: owner_id, acl: acl, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_UpdateEntityOwnerAndAcl", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_entity_make_system_entity(&mut self, entity_id: String, version: i64, acl: brain_cloud_service_s_d_k_data_types::JSON, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalEntity_MakeSystemEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalEntityMakeSystemEntityArgs { entity_id: entity_id, version: version, acl: acl, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalEntity_MakeSystemEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalEntityMakeSystemEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_statistics_read_all_global_stats(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadAllGlobalStats", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalStatistics_ReadAllGlobalStats", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_statistics_read_global_stats_subset(&mut self, global_stats: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsSubset", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs { global_stats: global_stats, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalStatistics_ReadGlobalStatsSubset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_statistics_read_global_stats_for_category(&mut self, category: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsForCategory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs { category: category, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalStatistics_ReadGlobalStatsForCategory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_statistics_increment_global_stats(&mut self, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalStatistics_IncrementGlobalStats", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs { json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalStatistics_IncrementGlobalStats", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn global_statistics_process_statistics(&mut self, statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ProcessStatistics", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGlobalStatisticsProcessStatisticsArgs { statistics_data: statistics_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("GlobalStatistics_ProcessStatistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGlobalStatisticsProcessStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_accept_group_invitation(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_AcceptGroupInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupAcceptGroupInvitationArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_AcceptGroupInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupAcceptGroupInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_add_group_member(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_AddGroupMember", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupAddGroupMemberArgs { group_id: group_id, profile_id: profile_id, role: role, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_AddGroupMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupAddGroupMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_approve_group_join_request(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ApproveGroupJoinRequest", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupApproveGroupJoinRequestArgs { group_id: group_id, profile_id: profile_id, role: role, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ApproveGroupJoinRequest", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupApproveGroupJoinRequestResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_auto_join_group(&mut self, group_type: String, auto_join_strategy: brain_cloud_service_s_d_k_data_types::AutoJoinStrategy, data_query_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_AutoJoinGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupAutoJoinGroupArgs { group_type: group_type, auto_join_strategy: auto_join_strategy, data_query_json: data_query_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_AutoJoinGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupAutoJoinGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_cancel_group_invitation(&mut self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_CancelGroupInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupCancelGroupInvitationArgs { group_id: group_id, profile_id: profile_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_CancelGroupInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupCancelGroupInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_create_group(&mut self, name: String, group_type: String, is_open_group: bool, acl: brain_cloud_service_s_d_k_data_types::JSON, json_data: String, json_owner_attributes: String, json_default_member_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_CreateGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupCreateGroupArgs { name: name, group_type: group_type, is_open_group: is_open_group, acl: acl, json_data: json_data, json_owner_attributes: json_owner_attributes, json_default_member_attributes: json_default_member_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_CreateGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupCreateGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_create_group_entity(&mut self, group_id: String, entity_type: String, is_owned_by_group_member: bool, acl: brain_cloud_service_s_d_k_data_types::JSON, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_CreateGroupEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupCreateGroupEntityArgs { group_id: group_id, entity_type: entity_type, is_owned_by_group_member: is_owned_by_group_member, acl: acl, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_CreateGroupEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupCreateGroupEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_delete_group(&mut self, group_id: String, version: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_DeleteGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupDeleteGroupArgs { group_id: group_id, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_DeleteGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupDeleteGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_delete_group_entity(&mut self, group_id: String, entity_id: String, version: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_DeleteGroupEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupDeleteGroupEntityArgs { group_id: group_id, entity_id: entity_id, version: version, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_DeleteGroupEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupDeleteGroupEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_get_my_groups(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_GetMyGroups", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupGetMyGroupsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_GetMyGroups", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupGetMyGroupsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_increment_group_data(&mut self, group_id: String, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_IncrementGroupData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupIncrementGroupDataArgs { group_id: group_id, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_IncrementGroupData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupIncrementGroupDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_increment_group_entity_data(&mut self, group_id: String, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_IncrementGroupEntityData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupIncrementGroupEntityDataArgs { group_id: group_id, entity_id: entity_id, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_IncrementGroupEntityData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupIncrementGroupEntityDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_invite_group_member(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_InviteGroupMember", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupInviteGroupMemberArgs { group_id: group_id, profile_id: profile_id, role: role, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_InviteGroupMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupInviteGroupMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_join_group(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_JoinGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupJoinGroupArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_JoinGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupJoinGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_leave_group(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_LeaveGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupLeaveGroupArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_LeaveGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupLeaveGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_list_groups_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ListGroupsPage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupListGroupsPageArgs { json_context: json_context, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ListGroupsPage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupListGroupsPageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_list_groups_page_by_offset(&mut self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ListGroupsPageByOffset", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupListGroupsPageByOffsetArgs { context: context, page_offset: page_offset, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ListGroupsPageByOffset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupListGroupsPageByOffsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_list_groups_with_member(&mut self, profile_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ListGroupsWithMember", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupListGroupsWithMemberArgs { profile_id: profile_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ListGroupsWithMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupListGroupsWithMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_read_group(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ReadGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupReadGroupArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ReadGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupReadGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_read_group_data(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ReadGroupData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupReadGroupDataArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ReadGroupData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupReadGroupDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_read_group_entities_page(&mut self, json_context: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupReadGroupEntitiesPageArgs { json_context: json_context, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ReadGroupEntitiesPage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupReadGroupEntitiesPageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_read_group_entities_page_by_offset(&mut self, encoded_context: String, page_offset: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPageByOffset", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs { encoded_context: encoded_context, page_offset: page_offset, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ReadGroupEntitiesPageByOffset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_read_group_entity(&mut self, group_id: String, entity_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ReadGroupEntity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupReadGroupEntityArgs { group_id: group_id, entity_id: entity_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ReadGroupEntity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupReadGroupEntityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_read_group_members(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_ReadGroupMembers", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupReadGroupMembersArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_ReadGroupMembers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupReadGroupMembersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_reject_group_invitation(&mut self, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_RejectGroupInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupRejectGroupInvitationArgs { group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_RejectGroupInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupRejectGroupInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_reject_group_join_request(&mut self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_RejectGroupJoinRequest", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupRejectGroupJoinRequestArgs { group_id: group_id, profile_id: profile_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_RejectGroupJoinRequest", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupRejectGroupJoinRequestResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_remove_group_member(&mut self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_RemoveGroupMember", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupRemoveGroupMemberArgs { group_id: group_id, profile_id: profile_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_RemoveGroupMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupRemoveGroupMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_update_group_data(&mut self, group_id: String, version: i64, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupUpdateGroupDataArgs { group_id: group_id, version: version, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_UpdateGroupData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupUpdateGroupDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_update_group_entity_data(&mut self, group_id: String, entity_id: String, version: i64, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupEntityData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupUpdateGroupEntityDataArgs { group_id: group_id, entity_id: entity_id, version: version, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_UpdateGroupEntityData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupUpdateGroupEntityDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_update_group_member(&mut self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupMember", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupUpdateGroupMemberArgs { group_id: group_id, profile_id: profile_id, role: role, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_UpdateGroupMember", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupUpdateGroupMemberResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn group_update_group_name(&mut self, group_id: String, name: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupName", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceGroupUpdateGroupNameArgs { group_id: group_id, name: name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Group_UpdateGroupName", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceGroupUpdateGroupNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_attach_email_identity(&mut self, email: String, password: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_AttachEmailIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityAttachEmailIdentityArgs { email: email, password: password, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_AttachEmailIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityAttachEmailIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_merge_email_identity(&mut self, email: String, password: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_MergeEmailIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityMergeEmailIdentityArgs { email: email, password: password, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_MergeEmailIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityMergeEmailIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_detach_email_identity(&mut self, email: String, continue_anon: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_DetachEmailIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityDetachEmailIdentityArgs { email: email, continue_anon: continue_anon, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_DetachEmailIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityDetachEmailIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_attach_universal_identity(&mut self, user_id: String, password: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_AttachUniversalIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityAttachUniversalIdentityArgs { user_id: user_id, password: password, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_AttachUniversalIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityAttachUniversalIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_merge_universal_identity(&mut self, user_id: String, password: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_MergeUniversalIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityMergeUniversalIdentityArgs { user_id: user_id, password: password, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_MergeUniversalIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityMergeUniversalIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_detach_universal_identity(&mut self, user_id: String, continue_anon: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_DetachUniversalIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityDetachUniversalIdentityArgs { user_id: user_id, continue_anon: continue_anon, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_DetachUniversalIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityDetachUniversalIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_switch_to_child_profile(&mut self, child_profile_id: String, child_app_id: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_SwitchToChildProfile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentitySwitchToChildProfileArgs { child_profile_id: child_profile_id, child_app_id: child_app_id, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_SwitchToChildProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentitySwitchToChildProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_switch_to_singleton_child_profile(&mut self, child_app_id: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_SwitchToSingletonChildProfile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs { child_app_id: child_app_id, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_SwitchToSingletonChildProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentitySwitchToSingletonChildProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_attach_parent_with_identity(&mut self, external_id: String, authentication_token: String, authentication_type: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_AttachParentWithIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityAttachParentWithIdentityArgs { external_id: external_id, authentication_token: authentication_token, authentication_type: authentication_type, external_auth_name: external_auth_name, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_AttachParentWithIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityAttachParentWithIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_switch_to_parent_profile(&mut self, parent_level_name: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_SwitchToParentProfile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentitySwitchToParentProfileArgs { parent_level_name: parent_level_name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_SwitchToParentProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentitySwitchToParentProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_detach_parent(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_DetachParent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityDetachParentArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_DetachParent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityDetachParentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_get_child_profiles(&mut self, include_summary_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_GetChildProfiles", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityGetChildProfilesArgs { include_summary_data: include_summary_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_GetChildProfiles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityGetChildProfilesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_get_identities(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_GetIdentities", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityGetIdentitiesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_GetIdentities", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityGetIdentitiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_get_expired_identities(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_GetExpiredIdentities", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityGetExpiredIdentitiesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_GetExpiredIdentities", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityGetExpiredIdentitiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_refresh_identity(&mut self, external_id: String, authentication_token: String, authentication_type: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_RefreshIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityRefreshIdentityArgs { external_id: external_id, authentication_token: authentication_token, authentication_type: authentication_type, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_RefreshIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityRefreshIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_change_email_identity(&mut self, old_email_address: String, password: String, new_email_address: String, update_contact_email: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_ChangeEmailIdentity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityChangeEmailIdentityArgs { old_email_address: old_email_address, password: password, new_email_address: new_email_address, update_contact_email: update_contact_email, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_ChangeEmailIdentity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityChangeEmailIdentityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_attach_peer_profile(&mut self, peer: String, external_id: String, authentication_token: String, authentication_type: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_AttachPeerProfile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityAttachPeerProfileArgs { peer: peer, external_id: external_id, authentication_token: authentication_token, authentication_type: authentication_type, external_auth_name: external_auth_name, force_create: force_create, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_AttachPeerProfile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityAttachPeerProfileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_detach_peer(&mut self, peer: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_DetachPeer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityDetachPeerArgs { peer: peer, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_DetachPeer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityDetachPeerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn identity_get_peer_profiles(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Identity_GetPeerProfiles", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceIdentityGetPeerProfilesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Identity_GetPeerProfiles", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceIdentityGetPeerProfilesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mail_send_basic_email(&mut self, profile_id: String, subject: String, body: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Mail_SendBasicEmail", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMailSendBasicEmailArgs { profile_id: profile_id, subject: subject, body: body, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Mail_SendBasicEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMailSendBasicEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mail_send_advanced_email(&mut self, profile_id: String, json_service_params: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmail", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMailSendAdvancedEmailArgs { profile_id: profile_id, json_service_params: json_service_params, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Mail_SendAdvancedEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMailSendAdvancedEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn mail_send_advanced_email_by_address(&mut self, email_address: String, json_service_params: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmailByAddress", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMailSendAdvancedEmailByAddressArgs { email_address: email_address, json_service_params: json_service_params, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Mail_SendAdvancedEmailByAddress", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMailSendAdvancedEmailByAddressResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_read(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_Read", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingReadArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_Read", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingReadResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_set_player_rating(&mut self, player_rating: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_SetPlayerRating", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingSetPlayerRatingArgs { player_rating: player_rating, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_SetPlayerRating", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingSetPlayerRatingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_reset_player_rating(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_ResetPlayerRating", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingResetPlayerRatingArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_ResetPlayerRating", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingResetPlayerRatingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_increment_player_rating(&mut self, increment: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_IncrementPlayerRating", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingIncrementPlayerRatingArgs { increment: increment, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_IncrementPlayerRating", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingIncrementPlayerRatingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_decrement_player_rating(&mut self, decrement: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_DecrementPlayerRating", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingDecrementPlayerRatingArgs { decrement: decrement, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_DecrementPlayerRating", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingDecrementPlayerRatingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_turn_shield_on(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOn", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingTurnShieldOnArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_TurnShieldOn", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingTurnShieldOnResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_turn_shield_on_for(&mut self, minutes: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOnFor", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingTurnShieldOnForArgs { minutes: minutes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_TurnShieldOnFor", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingTurnShieldOnForResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_turn_shield_off(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOff", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingTurnShieldOffArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_TurnShieldOff", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingTurnShieldOffResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_increment_shield_on_for(&mut self, minutes: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_IncrementShieldOnFor", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingIncrementShieldOnForArgs { minutes: minutes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_IncrementShieldOnFor", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingIncrementShieldOnForResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_get_shield_expiry(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_GetShieldExpiry", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingGetShieldExpiryArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_GetShieldExpiry", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingGetShieldExpiryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_find_players(&mut self, range_delta: i64, num_matches: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayers", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingFindPlayersArgs { range_delta: range_delta, num_matches: num_matches, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_FindPlayers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingFindPlayersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_find_players_with_attributes(&mut self, range_delta: i64, num_matches: i64, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs { range_delta: range_delta, num_matches: num_matches, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_FindPlayersWithAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingFindPlayersWithAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_find_players_using_filter(&mut self, range_delta: i64, num_matches: i64, json_extra_parms: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersUsingFilter", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs { range_delta: range_delta, num_matches: num_matches, json_extra_parms: json_extra_parms, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_FindPlayersUsingFilter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingFindPlayersUsingFilterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_find_players_with_attributes_using_filter(&mut self, range_delta: i64, num_matches: i64, json_attributes: String, json_extra_parms: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributesUsingFilter", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs { range_delta: range_delta, num_matches: num_matches, json_attributes: json_attributes, json_extra_parms: json_extra_parms, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_FindPlayersWithAttributesUsingFilter", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_enable_match_making(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_EnableMatchMaking", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingEnableMatchMakingArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_EnableMatchMaking", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingEnableMatchMakingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn match_making_disable_match_making(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("MatchMaking_DisableMatchMaking", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceMatchMakingDisableMatchMakingArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("MatchMaking_DisableMatchMaking", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceMatchMakingDisableMatchMakingResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn one_way_match_start_match(&mut self, other_player_id: String, range_delta: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("OneWayMatch_StartMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceOneWayMatchStartMatchArgs { other_player_id: other_player_id, range_delta: range_delta, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("OneWayMatch_StartMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceOneWayMatchStartMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn one_way_match_cancel_match(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("OneWayMatch_CancelMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceOneWayMatchCancelMatchArgs { playback_stream_id: playback_stream_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("OneWayMatch_CancelMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceOneWayMatchCancelMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn one_way_match_complete_match(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("OneWayMatch_CompleteMatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceOneWayMatchCompleteMatchArgs { playback_stream_id: playback_stream_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("OneWayMatch_CompleteMatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceOneWayMatchCompleteMatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_start_stream(&mut self, target_player_id: String, include_shared_data: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_StartStream", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamStartStreamArgs { target_player_id: target_player_id, include_shared_data: include_shared_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_StartStream", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamStartStreamResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_read_stream(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_ReadStream", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamReadStreamArgs { playback_stream_id: playback_stream_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_ReadStream", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamReadStreamResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_end_stream(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_EndStream", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamEndStreamArgs { playback_stream_id: playback_stream_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_EndStream", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamEndStreamResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_delete_stream(&mut self, playback_stream_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_DeleteStream", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamDeleteStreamArgs { playback_stream_id: playback_stream_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_DeleteStream", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamDeleteStreamResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_add_event(&mut self, playback_stream_id: String, event_data: String, summary: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_AddEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamAddEventArgs { playback_stream_id: playback_stream_id, event_data: event_data, summary: summary, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_AddEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamAddEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_get_recent_streams_for_initiating_player(&mut self, initiating_player_id: String, max_num_streams: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForInitiatingPlayer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs { initiating_player_id: initiating_player_id, max_num_streams: max_num_streams, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_GetRecentStreamsForInitiatingPlayer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn playback_stream_get_recent_streams_for_target_player(&mut self, target_player_id: String, max_num_streams: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForTargetPlayer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs { target_player_id: target_player_id, max_num_streams: max_num_streams, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlaybackStream_GetRecentStreamsForTargetPlayer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_read_user_state(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_ReadUserState", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateReadUserStateArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_ReadUserState", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateReadUserStateResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_delete_user(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_DeleteUser", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateDeleteUserArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_DeleteUser", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateDeleteUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_reset_user(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_ResetUser", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateResetUserArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_ResetUser", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateResetUserResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_logout(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_Logout", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateLogoutArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_Logout", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateLogoutResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_update_user_name(&mut self, user_name: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserName", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateUpdateUserNameArgs { user_name: user_name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_UpdateUserName", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateUpdateUserNameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_update_summary_friend_data(&mut self, json_summary_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateSummaryFriendData", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs { json_summary_data: json_summary_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_UpdateSummaryFriendData", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateUpdateSummaryFriendDataResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_get_attributes(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_GetAttributes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateGetAttributesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_GetAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateGetAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_update_attributes(&mut self, json_attributes: String, wipe_existing: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateAttributes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateUpdateAttributesArgs { json_attributes: json_attributes, wipe_existing: wipe_existing, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_UpdateAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateUpdateAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_remove_attributes(&mut self, attribute_names: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_RemoveAttributes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateRemoveAttributesArgs { attribute_names: attribute_names, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_RemoveAttributes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateRemoveAttributesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_update_user_picture_url(&mut self, picture_url: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserPictureUrl", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateUpdateUserPictureUrlArgs { picture_url: picture_url, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_UpdateUserPictureUrl", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateUpdateUserPictureUrlResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_state_update_contact_email(&mut self, contact_email: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateContactEmail", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStateUpdateContactEmailArgs { contact_email: contact_email, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerState_UpdateContactEmail", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStateUpdateContactEmailResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_read_all_user_stats(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadAllUserStats", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsReadAllUserStatsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_ReadAllUserStats", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsReadAllUserStatsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_read_user_stats_subset(&mut self, player_stats: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsSubset", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs { player_stats: player_stats, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_ReadUserStatsSubset", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_read_user_stats_for_category(&mut self, category: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsForCategory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs { category: category, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_ReadUserStatsForCategory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_reset_all_user_stats(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ResetAllUserStats", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsResetAllUserStatsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_ResetAllUserStats", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsResetAllUserStatsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_increment_user_stats_s_s_f_o(&mut self, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_SSFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs { json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_IncrementUserStats_SSFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_increment_user_stats_d_s_f_o(&mut self, dict_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_DSFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs { dict_data: dict_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_IncrementUserStats_DSFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_process_statistics(&mut self, statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ProcessStatistics", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsProcessStatisticsArgs { statistics_data: statistics_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_ProcessStatistics", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsProcessStatisticsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_get_next_experience_level(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_GetNextExperienceLevel", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_GetNextExperienceLevel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_increment_experience_points(&mut self, xp_value: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementExperiencePoints", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs { xp_value: xp_value, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_IncrementExperiencePoints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_set_experience_points(&mut self, xp_value: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatistics_SetExperiencePoints", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsSetExperiencePointsArgs { xp_value: xp_value, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatistics_SetExperiencePoints", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsSetExperiencePointsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_event_trigger_stats_event(&mut self, event_name: String, event_multiplier: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs { event_name: event_name, event_multiplier: event_multiplier, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatisticsEvent_TriggerStatsEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn player_statistics_event_trigger_stats_events(&mut self, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvents", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs { json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PlayerStatisticsEvent_TriggerStatsEvents", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn product_get_currency(&mut self, currency_type: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Product_GetCurrency", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProductGetCurrencyArgs { currency_type: currency_type, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Product_GetCurrency", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProductGetCurrencyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn product_get_sales_inventory(&mut self, platform: String, user_currency: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Product_GetSalesInventory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProductGetSalesInventoryArgs { platform: platform, user_currency: user_currency, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Product_GetSalesInventory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProductGetSalesInventoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn product_get_sales_inventory_by_category(&mut self, platform: String, user_currency: String, category: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Product_GetSalesInventoryByCategory", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProductGetSalesInventoryByCategoryArgs { platform: platform, user_currency: user_currency, category: category, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Product_GetSalesInventoryByCategory", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProductGetSalesInventoryByCategoryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn product_verify_microsoft_receipt(&mut self, receipt: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Product_VerifyMicrosoftReceipt", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProductVerifyMicrosoftReceiptArgs { receipt: receipt, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Product_VerifyMicrosoftReceipt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProductVerifyMicrosoftReceiptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn product_get_eligible_promotions(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Product_GetEligiblePromotions", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProductGetEligiblePromotionsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Product_GetEligiblePromotions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProductGetEligiblePromotionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn product_verify_itunes_receipt(&mut self, base64_enc_receipt_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Product_VerifyItunesReceipt", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProductVerifyItunesReceiptArgs { base64_enc_receipt_data: base64_enc_receipt_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Product_VerifyItunesReceipt", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProductVerifyItunesReceiptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn profanity_profanity_check(&mut self, text: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Profanity_ProfanityCheck", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProfanityProfanityCheckArgs { text: text, languages: languages, flag_email: flag_email, flag_phone: flag_phone, flag_urls: flag_urls, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Profanity_ProfanityCheck", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProfanityProfanityCheckResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn profanity_profanity_replace_text(&mut self, text: String, replace_symbol: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Profanity_ProfanityReplaceText", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProfanityProfanityReplaceTextArgs { text: text, replace_symbol: replace_symbol, languages: languages, flag_email: flag_email, flag_phone: flag_phone, flag_urls: flag_urls, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Profanity_ProfanityReplaceText", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProfanityProfanityReplaceTextResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn profanity_profanity_identify_bad_words(&mut self, text: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Profanity_ProfanityIdentifyBadWords", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs { text: text, languages: languages, flag_email: flag_email, flag_phone: flag_phone, flag_urls: flag_urls, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Profanity_ProfanityIdentifyBadWords", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceProfanityProfanityIdentifyBadWordsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_deregister_all_push_notification_device_tokens(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_DeregisterAllPushNotificationDeviceTokens", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_DeregisterAllPushNotificationDeviceTokens", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_deregister_push_notification_device_token(&mut self, platform: String, token: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_DeregisterPushNotificationDeviceToken", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs { platform: platform, token: token, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_DeregisterPushNotificationDeviceToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_register_push_notification_device_token(&mut self, platform: String, token: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_RegisterPushNotificationDeviceToken", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs { platform: platform, token: token, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_RegisterPushNotificationDeviceToken", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_simple_push_notification(&mut self, to_profile_id: String, message: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendSimplePushNotification", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendSimplePushNotificationArgs { to_profile_id: to_profile_id, message: message, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendSimplePushNotification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendSimplePushNotificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_rich_push_notification(&mut self, to_profile_id: String, notification_template_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotification", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendRichPushNotificationArgs { to_profile_id: to_profile_id, notification_template_id: notification_template_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendRichPushNotification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendRichPushNotificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_rich_push_notification_with_params(&mut self, to_profile_id: String, notification_template_id: i32, substitution_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotificationWithParams", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs { to_profile_id: to_profile_id, notification_template_id: notification_template_id, substitution_json: substitution_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendRichPushNotificationWithParams", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_templated_push_notification_to_group(&mut self, group_id: String, notification_template_id: i32, substitutions_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendTemplatedPushNotificationToGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs { group_id: group_id, notification_template_id: notification_template_id, substitutions_json: substitutions_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendTemplatedPushNotificationToGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_normalized_push_notification_to_group(&mut self, group_id: String, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationToGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs { group_id: group_id, alert_content_json: alert_content_json, custom_data_json: custom_data_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendNormalizedPushNotificationToGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_schedule_raw_push_notification_u_t_c(&mut self, profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, start_time: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationUTC", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs { profile_id: profile_id, fcm_content: fcm_content, ios_content: ios_content, facebook_content: facebook_content, start_time: start_time, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_ScheduleRawPushNotificationUTC", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_schedule_raw_push_notification_minutes(&mut self, profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationMinutes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs { profile_id: profile_id, fcm_content: fcm_content, ios_content: ios_content, facebook_content: facebook_content, minutes_from_now: minutes_from_now, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_ScheduleRawPushNotificationMinutes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_raw_push_notification(&mut self, to_profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotification", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendRawPushNotificationArgs { to_profile_id: to_profile_id, fcm_content: fcm_content, ios_content: ios_content, facebook_content: facebook_content, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendRawPushNotification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendRawPushNotificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_raw_push_notification_batch(&mut self, profile_ids: Vec<String>, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationBatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs { profile_ids: profile_ids, fcm_content: fcm_content, ios_content: ios_content, facebook_content: facebook_content, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendRawPushNotificationBatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendRawPushNotificationBatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_raw_push_notification_to_group(&mut self, group_id: String, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationToGroup", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs { group_id: group_id, fcm_content: fcm_content, ios_content: ios_content, facebook_content: facebook_content, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendRawPushNotificationToGroup", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_schedule_normalized_push_notification_u_t_c(&mut self, profile_id: String, alert_content_json: String, custom_data_json: String, start_time: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationUTC", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs { profile_id: profile_id, alert_content_json: alert_content_json, custom_data_json: custom_data_json, start_time: start_time, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_ScheduleNormalizedPushNotificationUTC", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_schedule_normalized_push_notification_minutes(&mut self, profile_id: String, alert_content_json: String, custom_data_json: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationMinutes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs { profile_id: profile_id, alert_content_json: alert_content_json, custom_data_json: custom_data_json, minutes_from_now: minutes_from_now, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_ScheduleNormalizedPushNotificationMinutes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_schedule_rich_push_notification_u_t_c(&mut self, profile_id: String, notification_template_id: i32, substitutions_json: String, start_time: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationUTC", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs { profile_id: profile_id, notification_template_id: notification_template_id, substitutions_json: substitutions_json, start_time: start_time, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_ScheduleRichPushNotificationUTC", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_schedule_rich_push_notification_minutes(&mut self, profile_id: String, notification_template_id: i32, substitutions_json: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationMinutes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs { profile_id: profile_id, notification_template_id: notification_template_id, substitutions_json: substitutions_json, minutes_from_now: minutes_from_now, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_ScheduleRichPushNotificationMinutes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_normalized_push_notification(&mut self, to_profile_id: String, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotification", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs { to_profile_id: to_profile_id, alert_content_json: alert_content_json, custom_data_json: custom_data_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendNormalizedPushNotification", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendNormalizedPushNotificationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn push_notification_send_normalized_push_notification_batch(&mut self, profile_ids: Vec<String>, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationBatch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs { profile_ids: profile_ids, alert_content_json: alert_content_json, custom_data_json: custom_data_json, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("PushNotification_SendNormalizedPushNotificationBatch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_run_script(&mut self, script_name: String, json_script_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_RunScript", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptRunScriptArgs { script_name: script_name, json_script_data: json_script_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_RunScript", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptRunScriptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_schedule_run_script_u_t_c(&mut self, script_name: String, json_script_data: String, start_date_in_u_t_c: brain_cloud_service_s_d_k_data_types::date, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptUTC", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptScheduleRunScriptUTCArgs { script_name: script_name, json_script_data: json_script_data, start_date_in_u_t_c: start_date_in_u_t_c, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_ScheduleRunScriptUTC", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptScheduleRunScriptUTCResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_schedule_run_script_minutes(&mut self, script_name: String, json_script_data: String, minutes_from_now: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptMinutes", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptScheduleRunScriptMinutesArgs { script_name: script_name, json_script_data: json_script_data, minutes_from_now: minutes_from_now, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_ScheduleRunScriptMinutes", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptScheduleRunScriptMinutesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_run_parent_script(&mut self, script_name: String, json_script_data: String, parent_level: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_RunParentScript", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptRunParentScriptArgs { script_name: script_name, json_script_data: json_script_data, parent_level: parent_level, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_RunParentScript", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptRunParentScriptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_cancel_scheduled_script(&mut self, job_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_CancelScheduledScript", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptCancelScheduledScriptArgs { job_id: job_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_CancelScheduledScript", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptCancelScheduledScriptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_run_peer_script(&mut self, script_name: String, json_script_data: String, peer: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_RunPeerScript", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptRunPeerScriptArgs { script_name: script_name, json_script_data: json_script_data, peer: peer, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_RunPeerScript", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptRunPeerScriptResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn script_run_peer_script_asynch(&mut self, script_name: String, json_script_data: String, peer: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Script_RunPeerScriptAsynch", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceScriptRunPeerScriptAsynchArgs { script_name: script_name, json_script_data: json_script_data, peer: peer, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Script_RunPeerScriptAsynch", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceScriptRunPeerScriptAsynchResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_social_leaderboard(&mut self, leaderboard_id: String, replace_name: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetSocialLeaderboard", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs { leaderboard_id: leaderboard_id, replace_name: replace_name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetSocialLeaderboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_multi_social_leaderboard(&mut self, leaderboard_ids: Vec<String>, leaderboard_result_count: i32, replace_name: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetMultiSocialLeaderboard", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs { leaderboard_ids: leaderboard_ids, leaderboard_result_count: leaderboard_result_count, replace_name: replace_name, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetMultiSocialLeaderboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_page(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, start_index: i32, end_index: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPage", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs { leaderboard_id: leaderboard_id, sort: sort, start_index: start_index, end_index: end_index, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardPage", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_page_by_version(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, start_index: i32, end_index: i32, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPageByVersion", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs { leaderboard_id: leaderboard_id, sort: sort, start_index: start_index, end_index: end_index, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardPageByVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_view(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardView", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs { leaderboard_id: leaderboard_id, sort: sort, before_count: before_count, after_count: after_count, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardView", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_view_by_version(&mut self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardViewByVersion", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs { leaderboard_id: leaderboard_id, sort: sort, before_count: before_count, after_count: after_count, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardViewByVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_versions(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardVersions", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs { leaderboard_id: leaderboard_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardVersions", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_group_social_leaderboard(&mut self, leaderboard_id: String, group_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGroupSocialLeaderboard", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs { leaderboard_id: leaderboard_id, group_id: group_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGroupSocialLeaderboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_post_score_to_leaderboard(&mut self, leaderboard_id: String, score: i64, json_data: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToLeaderboard", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs { leaderboard_id: leaderboard_id, score: score, json_data: json_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_PostScoreToLeaderboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_remove_player_score(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_RemovePlayerScore", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs { leaderboard_id: leaderboard_id, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_RemovePlayerScore", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_post_score_to_dynamic_leaderboard(&mut self, leaderboard_id: String, score: i64, json_data: String, leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType, rotation_type: brain_cloud_service_s_d_k_data_types::RotationType, rotation_reset: brain_cloud_service_s_d_k_data_types::date, retained_count: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboard", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs { leaderboard_id: leaderboard_id, score: score, json_data: json_data, leaderboard_type: leaderboard_type, rotation_type: rotation_type, rotation_reset: rotation_reset, retained_count: retained_count, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_PostScoreToDynamicLeaderboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_post_score_to_dynamic_leaderboard_days(&mut self, leaderboard_id: String, score: i64, json_data: String, leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType, rotation_reset: brain_cloud_service_s_d_k_data_types::date, retained_count: i32, num_days_to_rotate: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboardDays", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs { leaderboard_id: leaderboard_id, score: score, json_data: json_data, leaderboard_type: leaderboard_type, rotation_reset: rotation_reset, retained_count: retained_count, num_days_to_rotate: num_days_to_rotate, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_PostScoreToDynamicLeaderboardDays", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_players_social_leaderboard(&mut self, leaderboard_id: String, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayersSocialLeaderboard", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs { leaderboard_id: leaderboard_id, profile_ids: profile_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetPlayersSocialLeaderboard", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_list_leaderboards(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_ListLeaderboards", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardListLeaderboardsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_ListLeaderboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardListLeaderboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_entry_count(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCount", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs { leaderboard_id: leaderboard_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardEntryCount", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_global_leaderboard_entry_count_by_version(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs { leaderboard_id: leaderboard_id, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_player_score(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScore", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs { leaderboard_id: leaderboard_id, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetPlayerScore", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetPlayerScoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_leaderboard_get_player_scores_from_leaderboards(&mut self, leaderboard_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScoresFromLeaderboards", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs { leaderboard_ids: leaderboard_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialLeaderboard_GetPlayerScoresFromLeaderboards", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn time_read_server_time(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Time_ReadServerTime", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTimeReadServerTimeArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Time_ReadServerTime", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTimeReadServerTimeResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_claim_tournament_reward(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_ClaimTournamentReward", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentClaimTournamentRewardArgs { leaderboard_id: leaderboard_id, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_ClaimTournamentReward", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentClaimTournamentRewardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_get_tournament_status(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_GetTournamentStatus", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentGetTournamentStatusArgs { leaderboard_id: leaderboard_id, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_GetTournamentStatus", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentGetTournamentStatusResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_join_tournament(&mut self, leaderboard_id: String, tournament_code: String, initial_score: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_JoinTournament", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentJoinTournamentArgs { leaderboard_id: leaderboard_id, tournament_code: tournament_code, initial_score: initial_score, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_JoinTournament", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentJoinTournamentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_leave_tournament(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_LeaveTournament", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentLeaveTournamentArgs { leaderboard_id: leaderboard_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_LeaveTournament", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentLeaveTournamentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_post_tournament_score(&mut self, leaderboard_id: String, score: i64, json_data: String, round_started_time: brain_cloud_service_s_d_k_data_types::date, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScore", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentPostTournamentScoreArgs { leaderboard_id: leaderboard_id, score: score, json_data: json_data, round_started_time: round_started_time, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_PostTournamentScore", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentPostTournamentScoreResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_post_tournament_score_with_results(&mut self, leaderboard_id: String, score: i64, json_data: String, round_started_time: brain_cloud_service_s_d_k_data_types::date, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, initial_score: i64, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScoreWithResults", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs { leaderboard_id: leaderboard_id, score: score, json_data: json_data, round_started_time: round_started_time, sort: sort, before_count: before_count, after_count: after_count, initial_score: initial_score, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_PostTournamentScoreWithResults", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentPostTournamentScoreWithResultsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_view_current_reward(&mut self, leaderboard_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_ViewCurrentReward", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentViewCurrentRewardArgs { leaderboard_id: leaderboard_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_ViewCurrentReward", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentViewCurrentRewardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn tournament_view_reward(&mut self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Tournament_ViewReward", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTournamentViewRewardArgs { leaderboard_id: leaderboard_id, version_id: version_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Tournament_ViewReward", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTournamentViewRewardResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_create_lobby(&mut self, lobby_type: brain_cloud_service_s_d_k_data_types::LobbyType, max_slots: i32, is_open: bool, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_CreateLobby", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyCreateLobbyArgs { lobby_type: lobby_type, max_slots: max_slots, is_open: is_open, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_CreateLobby", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyCreateLobbyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_open_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_OpenLobby", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyOpenLobbyArgs { lobby_id: lobby_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_OpenLobby", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyOpenLobbyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_close_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_CloseLobby", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyCloseLobbyArgs { lobby_id: lobby_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_CloseLobby", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyCloseLobbyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_find_lobbies(&mut self, free_slots: i32, max_results: i32, json_attributes: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_FindLobbies", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyFindLobbiesArgs { free_slots: free_slots, max_results: max_results, json_attributes: json_attributes, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_FindLobbies", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyFindLobbiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_find_friends_lobbies(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_FindFriendsLobbies", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyFindFriendsLobbiesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_FindFriendsLobbies", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyFindFriendsLobbiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_join_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_JoinLobby", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyJoinLobbyArgs { lobby_id: lobby_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_JoinLobby", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyJoinLobbyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_leave_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_LeaveLobby", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyLeaveLobbyArgs { lobby_id: lobby_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_LeaveLobby", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyLeaveLobbyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_destroy_lobby(&mut self, lobby_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_DestroyLobby", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyDestroyLobbyArgs { lobby_id: lobby_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_DestroyLobby", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyDestroyLobbyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_start_game(&mut self, lobby_id: String, connection_string: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_StartGame", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyStartGameArgs { lobby_id: lobby_id, connection_string: connection_string, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_StartGame", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyStartGameResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn lobby_get_my_lobbies(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Lobby_GetMyLobbies", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceLobbyGetMyLobbiesArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Lobby_GetMyLobbies", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceLobbyGetMyLobbiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_accept_party_invitation(&mut self, party_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_AcceptPartyInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyAcceptPartyInvitationArgs { party_id: party_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_AcceptPartyInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyAcceptPartyInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_get_party_info(&mut self, party_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_GetPartyInfo", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyGetPartyInfoArgs { party_id: party_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_GetPartyInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyGetPartyInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_join_party(&mut self, party_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_JoinParty", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyJoinPartyArgs { party_id: party_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_JoinParty", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyJoinPartyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_leave_party(&mut self, party_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_LeaveParty", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyLeavePartyArgs { party_id: party_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_LeaveParty", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyLeavePartyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_reject_party_invitation(&mut self, party_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_RejectPartyInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyRejectPartyInvitationArgs { party_id: party_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_RejectPartyInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyRejectPartyInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_send_party_invitation(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_SendPartyInvitation", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartySendPartyInvitationArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_SendPartyInvitation", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartySendPartyInvitationResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_list_party_invitations(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_ListPartyInvitations", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyListPartyInvitationsArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_ListPartyInvitations", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyListPartyInvitationsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_get_friends_parties(&mut self, max_results: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_GetFriendsParties", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyGetFriendsPartiesArgs { max_results: max_results, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_GetFriendsParties", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyGetFriendsPartiesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn party_get_my_party(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Party_GetMyParty", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePartyGetMyPartyArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Party_GetMyParty", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePartyGetMyPartyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn patch_get_game_manifest(&mut self, game_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Patch_GetGameManifest", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServicePatchGetGameManifestArgs { game_id: game_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Patch_GetGameManifest", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServicePatchGetGameManifestResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_add_to_cart_s_i_s_f_o(&mut self, product_id: String, quantity: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_AddToCart_SISFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingAddToCartSISFOArgs { product_id: product_id, quantity: quantity, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_AddToCart_SISFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingAddToCartSISFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_add_to_cart_i_s_f_o(&mut self, product_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_AddToCart_ISFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingAddToCartISFOArgs { product_ids: product_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_AddToCart_ISFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingAddToCartISFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_empty_cart(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_EmptyCart", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingEmptyCartArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_EmptyCart", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingEmptyCartResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_cart(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetCart", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetCartArgs { include_details: include_details, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetCart", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetCartResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_remove_from_cart(&mut self, product_id: String, quantity: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_RemoveFromCart", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingRemoveFromCartArgs { product_id: product_id, quantity: quantity, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_RemoveFromCart", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingRemoveFromCartResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_add_to_wishlist(&mut self, product_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_AddToWishlist", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingAddToWishlistArgs { product_id: product_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_AddToWishlist", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingAddToWishlistResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_empty_wishlist(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_EmptyWishlist", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingEmptyWishlistArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_EmptyWishlist", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingEmptyWishlistResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_my_wishlist(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetMyWishlist", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetMyWishlistArgs { include_details: include_details, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetMyWishlist", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetMyWishlistResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_wishlist(&mut self, player_id: String, include_details: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetWishlist", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetWishlistArgs { player_id: player_id, include_details: include_details, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetWishlist", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetWishlistResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_remove_from_wishlist_s_s_f_o(&mut self, product_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_SSFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs { product_id: product_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_RemoveFromWishlist_SSFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingRemoveFromWishlistSSFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_remove_from_wishlist_i_s_f_o(&mut self, product_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_ISFO", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingRemoveFromWishlistISFOArgs { product_ids: product_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_RemoveFromWishlist_ISFO", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingRemoveFromWishlistISFOResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_user_reviews(&mut self, product_id: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetUserReviews", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetUserReviewsArgs { product_id: product_id, page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetUserReviews", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetUserReviewsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_submit_user_review(&mut self, product_id: String, review_text: String, positive: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_SubmitUserReview", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingSubmitUserReviewArgs { product_id: product_id, review_text: review_text, positive: positive, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_SubmitUserReview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingSubmitUserReviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_like_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_LikeUserReview", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingLikeUserReviewArgs { product_id: product_id, review_id: review_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_LikeUserReview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingLikeUserReviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_unlike_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_UnlikeUserReview", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingUnlikeUserReviewArgs { product_id: product_id, review_id: review_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_UnlikeUserReview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingUnlikeUserReviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_funny_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_FunnyUserReview", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingFunnyUserReviewArgs { product_id: product_id, review_id: review_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_FunnyUserReview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingFunnyUserReviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_unfunny_user_review(&mut self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_UnfunnyUserReview", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingUnfunnyUserReviewArgs { product_id: product_id, review_id: review_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_UnfunnyUserReview", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingUnfunnyUserReviewResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_recently_created_products(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyCreatedProducts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs { page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetRecentlyCreatedProducts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetRecentlyCreatedProductsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_recently_updated_products(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyUpdatedProducts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs { page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetRecentlyUpdatedProducts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_featured_products(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetFeaturedProducts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetFeaturedProductsArgs { include_details: include_details, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetFeaturedProducts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetFeaturedProductsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_popular_products(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetPopularProducts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetPopularProductsArgs { page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetPopularProducts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetPopularProductsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_special_offers(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetSpecialOffers", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetSpecialOffersArgs { page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetSpecialOffers", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetSpecialOffersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_my_library(&mut self, include_details: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetMyLibrary", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetMyLibraryArgs { include_details: include_details, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetMyLibrary", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetMyLibraryResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_popular_tags(&mut self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetPopularTags", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetPopularTagsArgs { page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetPopularTags", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetPopularTagsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_products_by_tag(&mut self, tag: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTag", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetProductsByTagArgs { tag: tag, page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetProductsByTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetProductsByTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_products_by_tags(&mut self, tags: Vec<String>, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTags", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetProductsByTagsArgs { tags: tags, page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetProductsByTags", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetProductsByTagsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_recommended_products(&mut self, count: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetRecommendedProducts", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetRecommendedProductsArgs { count: count, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetRecommendedProducts", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetRecommendedProductsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_my_orders(&mut self, include_completed: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetMyOrders", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetMyOrdersArgs { include_completed: include_completed, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetMyOrders", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetMyOrdersResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_product(&mut self, product_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetProduct", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetProductArgs { product_id: product_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetProduct", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetProductResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_user_tags(&mut self, product_id: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetUserTags", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetUserTagsArgs { product_id: product_id, page: page, page_size: page_size, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetUserTags", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetUserTagsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_my_user_tags(&mut self, product_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetMyUserTags", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetMyUserTagsArgs { product_id: product_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetMyUserTags", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetMyUserTagsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_submit_user_tag(&mut self, product_id: String, tag: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTag", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingSubmitUserTagArgs { product_id: product_id, tag: tag, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_SubmitUserTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingSubmitUserTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_submit_user_tags(&mut self, product_id: String, tags: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTags", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingSubmitUserTagsArgs { product_id: product_id, tags: tags, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_SubmitUserTags", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingSubmitUserTagsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_remove_user_tag(&mut self, product_id: String, tag: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_RemoveUserTag", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingRemoveUserTagArgs { product_id: product_id, tag: tag, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_RemoveUserTag", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingRemoveUserTagResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn shopping_get_build_details(&mut self, product_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Shopping_GetBuildDetails", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceShoppingGetBuildDetailsArgs { product_id: product_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Shopping_GetBuildDetails", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceShoppingGetBuildDetailsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_video(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareVideo", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareVideoArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareVideo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareVideoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_screenshot(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareScreenshot", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareScreenshotArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareScreenshot", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareScreenshotResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_achievement(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareAchievement", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareAchievementArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareAchievement", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareAchievementResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_app(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareApp", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareAppArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareApp", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareAppResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_channel(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareChannel", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareChannelArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareChannel", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareChannelResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_link(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareLink", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareLinkArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareLink", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareLinkResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_share_game_guide(&mut self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareGameGuide", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedShareGameGuideArgs { timestamp: timestamp, resource: resource, tagged: tagged, show: show, block: block, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ShareGameGuide", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedShareGameGuideResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_read_social_feed(&mut self, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadSocialFeed", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedReadSocialFeedArgs { skip: skip, limit: limit, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ReadSocialFeed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedReadSocialFeedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_read_filtered_social_feed(&mut self, skip: i32, limit: i32, player_ids: Vec<String>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadFilteredSocialFeed", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs { skip: skip, limit: limit, player_ids: player_ids, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ReadFilteredSocialFeed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedReadFilteredSocialFeedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_read_friends_social_feed(&mut self, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadFriendsSocialFeed", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs { skip: skip, limit: limit, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ReadFriendsSocialFeed", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedReadFriendsSocialFeedResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_post_comment(&mut self, timestamp: i32, parent_id: String, content: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_PostComment", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedPostCommentArgs { timestamp: timestamp, parent_id: parent_id, content: content, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_PostComment", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedPostCommentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_post_comment_reply(&mut self, timestamp: i32, parent_id: String, content: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_PostCommentReply", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedPostCommentReplyArgs { timestamp: timestamp, parent_id: parent_id, content: content, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_PostCommentReply", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedPostCommentReplyResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_read_comments(&mut self, skip: i32, limit: i32, parent_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadComments", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedReadCommentsArgs { skip: skip, limit: limit, parent_id: parent_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ReadComments", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedReadCommentsResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_read_comment_replies(&mut self, skip: i32, limit: i32, parent_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadCommentReplies", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedReadCommentRepliesArgs { skip: skip, limit: limit, parent_id: parent_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_ReadCommentReplies", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedReadCommentRepliesResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_like_comment(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_LikeComment", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedLikeCommentArgs { social_feed_id: social_feed_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_LikeComment", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedLikeCommentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_like_activity(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_LikeActivity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedLikeActivityArgs { social_feed_id: social_feed_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_LikeActivity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedLikeActivityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_unlike_comment(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeComment", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedUnlikeCommentArgs { social_feed_id: social_feed_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_UnlikeComment", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedUnlikeCommentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_unlike_activity(&mut self, social_feed_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeActivity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedUnlikeActivityArgs { social_feed_id: social_feed_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_UnlikeActivity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedUnlikeActivityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_set_feed_visibility(&mut self, visibility: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_SetFeedVisibility", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedSetFeedVisibilityArgs { visibility: visibility, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_SetFeedVisibility", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedSetFeedVisibilityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_block_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_BlockPlayer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedBlockPlayerArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_BlockPlayer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedBlockPlayerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_hide_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_HidePlayer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedHidePlayerArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_HidePlayer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedHidePlayerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_unblock_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_UnblockPlayer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedUnblockPlayerArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_UnblockPlayer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedUnblockPlayerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_unhide_player(&mut self, player_id: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_UnhidePlayer", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedUnhidePlayerArgs { player_id: player_id, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_UnhidePlayer", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedUnhidePlayerResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_get_activity(&mut self, social_feed_id: String, depth: i32, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_GetActivity", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedGetActivityArgs { social_feed_id: social_feed_id, depth: depth, skip: skip, limit: limit, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_GetActivity", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedGetActivityResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn social_feed_get_comment(&mut self, social_feed_id: String, depth: i32, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("SocialFeed_GetComment", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceSocialFeedGetCommentArgs { social_feed_id: social_feed_id, depth: depth, skip: skip, limit: limit, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("SocialFeed_GetComment", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceSocialFeedGetCommentResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn telemetry_start_telemetry_session(&mut self, timestamp: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetrySession", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTelemetryStartTelemetrySessionArgs { timestamp: timestamp, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Telemetry_StartTelemetrySession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTelemetryStartTelemetrySessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn telemetry_end_telemetry_session(&mut self, telemetry_session_id: String, timestamp: i32, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetrySession", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTelemetryEndTelemetrySessionArgs { telemetry_session_id: telemetry_session_id, timestamp: timestamp, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Telemetry_EndTelemetrySession", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTelemetryEndTelemetrySessionResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn telemetry_log_telemetry_event(&mut self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Telemetry_LogTelemetryEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTelemetryLogTelemetryEventArgs { telemetry_session_id: telemetry_session_id, timestamp: timestamp, event_type: event_type, participant_id: participant_id, custom_data: custom_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Telemetry_LogTelemetryEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTelemetryLogTelemetryEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn telemetry_start_telemetry_event(&mut self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetryEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTelemetryStartTelemetryEventArgs { telemetry_session_id: telemetry_session_id, timestamp: timestamp, event_type: event_type, participant_id: participant_id, custom_data: custom_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Telemetry_StartTelemetryEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTelemetryStartTelemetryEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn telemetry_end_telemetry_event(&mut self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetryEvent", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceTelemetryEndTelemetryEventArgs { telemetry_session_id: telemetry_session_id, timestamp: timestamp, event_type: event_type, participant_id: participant_id, custom_data: custom_data, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Telemetry_EndTelemetryEvent", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceTelemetryEndTelemetryEventResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn authentication_get_we_chat_q_r_page_u_r_l(&mut self, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("Authentication_GetWeChatQRPageURL", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs { client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("Authentication_GetWeChatQRPageURL", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceAuthenticationGetWeChatQRPageURLResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_download_file(&mut self, cloud_path: String, cloud_filename: String, replace_if_exists: bool, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_DownloadFile", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileDownloadFileArgs { cloud_path: cloud_path, cloud_filename: cloud_filename, replace_if_exists: replace_if_exists, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_DownloadFile", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileDownloadFileResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_get_download_info(&mut self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_GetDownloadInfo", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileGetDownloadInfoArgs { cloud_path: cloud_path, cloud_filename: cloud_filename, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_GetDownloadInfo", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileGetDownloadInfoResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
  fn file_cancel_download(&mut self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String> {
    (
      {
        self.increment_sequence_number();
        let message_ident = TMessageIdentifier::new("File_CancelDownload", TMessageType::Call, self.sequence_number());
        let call_args = BrainCloudServiceFileCancelDownloadArgs { cloud_path: cloud_path, cloud_filename: cloud_filename, client_index: client_index };
        self.o_prot_mut().write_message_begin(&message_ident)?;
        call_args.write_to_out_protocol(self.o_prot_mut())?;
        self.o_prot_mut().write_message_end()?;
        self.o_prot_mut().flush()
      }
    )?;
    {
      let message_ident = self.i_prot_mut().read_message_begin()?;
      verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
      verify_expected_service_call("File_CancelDownload", &message_ident.name)?;
      if message_ident.message_type == TMessageType::Exception {
        let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
        self.i_prot_mut().read_message_end()?;
        return Err(thrift::Error::Application(remote_error))
      }
      verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
      let result = BrainCloudServiceFileCancelDownloadResult::read_from_in_protocol(self.i_prot_mut())?;
      self.i_prot_mut().read_message_end()?;
      result.ok_or()
    }
  }
}

//
// BrainCloudService service processor
//

pub trait BrainCloudServiceSyncHandler {
  /// Creates an instance of an asynchronous match.
  fn handle_async_match_create_match(&self, json_opponent_ids: String, push_notification_message: String, client_index: i32) -> thrift::Result<String>;
  /// Creates an instance of an asynchronous match with an initial turn.
  fn handle_async_match_create_match_with_initial_turn(&self, json_opponent_ids: String, json_match_state: String, push_notification_message: String, next_player: String, json_summary: String, client_index: i32) -> thrift::Result<String>;
  /// Submits a turn for the given match.
  fn handle_async_match_submit_turn(&self, owner_id: String, match_id: String, version: i64, json_match_state: String, push_notification_message: String, next_player: String, json_summary: String, json_statistics: String, client_index: i32) -> thrift::Result<String>;
  /// Allows the current player (only) to update Summary data without having to submit a whole turn.
  fn handle_async_match_update_match_summary_data(&self, owner_id: String, match_id: String, version: i64, json_summary: String, client_index: i32) -> thrift::Result<String>;
  /// Marks the given match as complete.
  fn handle_async_match_complete_match(&self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the current state of the given match.
  fn handle_async_match_read_match(&self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the match history of the given match.
  fn handle_async_match_read_match_history(&self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns all matches that are NOT in a COMPLETE state for which the player is involved.
  fn handle_async_match_find_matches(&self, client_index: i32) -> thrift::Result<String>;
  /// Returns all matches that are in a COMPLETE state for which the player is involved.
  fn handle_async_match_find_complete_matches(&self, client_index: i32) -> thrift::Result<String>;
  /// Marks the given match as abandoned.
  fn handle_async_match_abandon_match(&self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Removes the match and match history from the server. DEBUG ONLY, in production it is recommended
  /// the user leave it as completed.
  fn handle_async_match_delete_match(&self, owner_id: String, match_id: String, client_index: i32) -> thrift::Result<String>;
  /// Used to create the anonymous installation id for the brainCloud profile.
  fn handle_authentication_generate_anonymous_id(&self, client_index: i32) -> thrift::Result<String>;
  /// Initialize - initializes the identity service with a saved
  /// anonymous installation id and most recently used profile id
  fn handle_authentication_initialize(&self, profile_id: String, anonymous_id: String, client_index: i32) -> thrift::Result<()>;
  /// Used to clear the saved profile id - to use in cases when the user is
  /// attempting to switch to a different app profile.
  fn handle_authentication_clear_saved_profile_i_d(&self, client_index: i32) -> thrift::Result<()>;
  /// Authenticate a user anonymously with brainCloud - used for apps that don't want to bother
  /// the user to login, or for users who are sensitive to their privacy
  fn handle_authentication_authenticate_anonymous(&self, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user with a custom Email and Password.  Note that the client app
  /// is responsible for collecting (and storing) the e-mail and potentially password
  /// (for convenience) in the client data.  For the greatest security,
  /// force the user to re-enter their password at each login.
  /// (Or at least give them that option).
  fn handle_authentication_authenticate_email_password(&self, email: String, password: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user using a userId and password (without any validation on the userId).
  /// Similar to AuthenticateEmailPassword - except that that method has additional features to
  /// allow for e-mail validation, password resets, etc.
  fn handle_authentication_authenticate_universal(&self, user_id: String, password: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user via cloud code (which in turn validates the supplied credentials against an external system).
  /// This allows the developer to extend brainCloud authentication to support other backend authentication systems.
  fn handle_authentication_authenticate_external(&self, user_id: String, token: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user via wechat
  fn handle_authentication_authenticate_phone(&self, phone_number: String, auth_code: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Authenticate the user via wechat
  fn handle_authentication_authenticate_wechat(&self, open_id: String, token: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Reset Email password - Sends a password reset email to the specified address
  fn handle_authentication_reset_email_password(&self, external_id: String, client_index: i32) -> thrift::Result<String>;
  /// Request an SMS code sent to a phone prior to authentication.
  fn handle_authentication_request_sms_code(&self, phone_number: String, force_create: bool, is_international: bool, client_index: i32) -> thrift::Result<String>;
  fn handle_authentication_check_username_exists(&self, game_id: String, player_name: String, client_index: i32) -> thrift::Result<String>;
  fn handle_authentication_change_universal_password(&self, game_id: String, player_id: String, old_password: String, new_password: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the sessionId or empty string if no session present.
  fn handle_client_get_session_id(&self, client_index: i32) -> thrift::Result<String>;
  /// Returns true if the user is currently authenticated.
  /// If a session time out or session invalidation is returned from executing a
  /// sever API call, this flag will reset back to false.
  fn handle_client_is_authenticated(&self, client_index: i32) -> thrift::Result<bool>;
  /// Returns true if brainCloud has been initialized.
  fn handle_client_is_initialized(&self, client_index: i32) -> thrift::Result<bool>;
  /// Method initializes the BrainCloudClient.
  fn handle_client_initialize_s_s_s(&self, secret_key: String, app_id: String, app_version: String, client_index: i32) -> thrift::Result<()>;
  /// Method initializes the BrainCloudClient.
  fn handle_client_initialize_s_s_s_s(&self, server_u_r_l: String, secret_key: String, app_id: String, app_version: String, client_index: i32) -> thrift::Result<()>;
  /// Initialize the identity aspects of brainCloud.
  fn handle_client_initialize_identity(&self, profile_id: String, anonymous_id: String, client_index: i32) -> thrift::Result<()>;
  /// Update method needs to be called regularly in order
  /// to process incoming and outgoing messages.
  fn handle_client_update(&self, client_index: i32) -> thrift::Result<()>;
  /// Enable logging of brainCloud transactions (comms etc)
  fn handle_client_enable_logging(&self, enable: bool, client_index: i32) -> thrift::Result<()>;
  /// Resets all messages and calls to the server
  fn handle_client_reset_communication(&self, client_index: i32) -> thrift::Result<()>;
  /// Sets the packet timeouts using a list of integers that
  /// represent timeout values for each packet retry. The
  /// first item in the list represents the timeout for the first packet
  /// attempt, the second for the second packet attempt, and so on.
  /// 
  /// The number of entries in this array determines how many packet
  /// retries will occur.
  /// 
  /// By default, the packet timeout array is {10, 10, 10}
  /// 
  /// Note that this method does not change the timeout for authentication
  /// packets (use SetAuthenticationPacketTimeout method).
  fn handle_client_set_packet_timeouts(&self, timeouts: Vec<i32>, client_index: i32) -> thrift::Result<()>;
  /// Sets the packet timeouts back to default.
  fn handle_client_set_packet_timeouts_to_default(&self, client_index: i32) -> thrift::Result<()>;
  /// Returns the list of packet timeouts.
  fn handle_client_get_packet_timeouts(&self, client_index: i32) -> thrift::Result<Vec<i32>>;
  /// Sets the authentication packet timeout which is tracked separately
  /// from all other packets. Note that authentication packets are never
  /// retried and so this value represents the total time a client would
  /// wait to receive a reply to an authentication API call. By default
  /// this timeout is set to 15 seconds.
  fn handle_client_set_authentication_packet_timeout(&self, timeout_secs: i32, client_index: i32) -> thrift::Result<()>;
  /// Gets the authentication packet timeout which is tracked separately
  /// from all other packets. Note that authentication packets are never
  /// retried and so this value represents the total time a client would
  /// wait to receive a reply to an authentication API call. By default
  /// this timeout is set to 15 seconds.
  fn handle_client_get_authentication_packet_timeout(&self, client_index: i32) -> thrift::Result<i32>;
  /// Returns the low transfer rate timeout in secs
  fn handle_client_get_upload_low_transfer_rate_timeout(&self, client_index: i32) -> thrift::Result<i32>;
  /// Sets the timeout in seconds of a low speed upload
  /// (i.e. transfer rate which is underneath the low transfer rate threshold).
  /// By default this is set to 120 secs.Setting this value to 0 will
  /// turn off the timeout. Note that this timeout method
  /// does not work on Unity mobile platforms.
  fn handle_client_set_upload_low_transfer_rate_timeout(&self, timeout_secs: i32, client_index: i32) -> thrift::Result<()>;
  /// Returns the low transfer rate threshold in bytes/sec
  fn handle_client_get_upload_low_transfer_rate_threshold(&self, client_index: i32) -> thrift::Result<i32>;
  /// Sets the low transfer rate threshold of an upload in bytes/sec.
  /// If the transfer rate dips below the given threshold longer
  /// than the specified timeout, the transfer will fail.
  /// By default this is set to 50 bytes/sec. Note that this timeout method
  /// does not work on Unity mobile platforms.
  fn handle_client_set_upload_low_transfer_rate_threshold(&self, bytes_per_sec: i32, client_index: i32) -> thrift::Result<()>;
  /// Enables the timeout message caching which is disabled by default.
  /// Once enabled, if a client side timeout is encountered
  /// (i.e. brainCloud server is unreachable presumably due to the client
  /// network being down) the SDK will do the following:
  /// 
  /// 1 - cache the currently queued messages to brainCloud
  /// 2 - call the network error callback
  /// 3 - then expect the app to call either:
  ///     a) RetryCachedMessages() to retry sending to brainCloud
  ///     b) FlushCachedMessages() to dump all messages in the queue.
  /// 
  /// Between steps 2 and 3, the app can prompt the user to retry connecting
  /// to brainCloud to determine whether to follow path 3a or 3b.
  /// 
  /// Note that if path 3a is followed, and another timeout is encountered,
  /// the process will begin all over again from step 1.
  /// 
  /// WARNING - the brainCloud SDK will cache *all* API calls sent
  /// when a timeout is encountered if this mechanism is enabled.
  /// This effectively freezes all communication with brainCloud.
  /// Apps must call either RetryCachedMessages() or FlushCachedMessages()
  /// for the brainCloud SDK to resume sending messages.
  /// ResetCommunication() will also clear the message cache.
  fn handle_client_enable_network_error_message_caching(&self, enabled: bool, client_index: i32) -> thrift::Result<()>;
  /// Attempts to resend any cached messages. If no messages are in the cache,
  /// this method does nothing.
  fn handle_client_retry_cached_messages(&self, client_index: i32) -> thrift::Result<()>;
  /// Flushes the cached messages to resume API call processing. This will dump
  /// all of the cached messages in the queue.
  fn handle_client_flush_cached_messages(&self, send_api_error_callbacks: bool, client_index: i32) -> thrift::Result<()>;
  /// Inserts a marker which will tell the brainCloud comms layer
  /// to close the message bundle off at this point. Any messages queued
  /// before this method was called will likely be bundled together in
  /// the next send to the server.
  /// 
  /// To ensure that only a single message is sent to the server you would
  /// do something like this:
  /// 
  /// InsertEndOfMessageBundleMarker()
  /// SomeApiCall()
  /// InsertEndOfMessageBundleMarker()
  fn handle_client_insert_end_of_message_bundle_marker(&self, client_index: i32) -> thrift::Result<()>;
  /// Sets the country code sent to brainCloud when a user authenticates.
  /// Will override any auto detected country.
  fn handle_client_override_country_code(&self, country_code: String, client_index: i32) -> thrift::Result<()>;
  /// Sets the language code sent to brainCloud when a user authenticates.
  /// If the language is set to a non-ISO 639-1 standard value the game default will be used instead.
  /// Will override any auto detected language.
  fn handle_client_override_language_code(&self, language_code: String, client_index: i32) -> thrift::Result<()>;
  /// Creates custom data stream page event
  fn handle_data_stream_custom_page_event(&self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String>;
  /// Creates custom data stream screen event
  fn handle_data_stream_custom_screen_event(&self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String>;
  /// Creates custom data stream track event
  fn handle_data_stream_custom_track_event(&self, event_name: String, json_event_properties: String, client_index: i32) -> thrift::Result<String>;
  /// Method creates a new entity on the server.
  fn handle_entity_create_entity(&self, entity_type: String, json_entity_data: String, json_entity_acl: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns all user entities that match the given type.
  fn handle_entity_get_entities_by_type(&self, entity_type: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates a new entity on the server. This operation results in the entity
  /// data being completely replaced by the passed in JSON string.
  fn handle_entity_update_entity(&self, entity_id: String, entity_type: String, json_entity_data: String, json_entity_acl: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method updates a shared entity owned by another user. This operation results in the entity
  /// data being completely replaced by the passed in JSON string.
  fn handle_entity_update_shared_entity(&self, entity_id: String, target_profile_id: String, entity_type: String, json_entity_data: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method deletes the given entity on the server.
  fn handle_entity_delete_entity(&self, entity_id: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method updates a singleton entity on the server. This operation results in the entity
  /// data being completely replaced by the passed in JSON string. If the entity doesn't exist it is created.
  fn handle_entity_update_singleton(&self, entity_type: String, json_entity_data: String, json_entity_acl: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method deletes the given singleton on the server.
  fn handle_entity_delete_singleton(&self, entity_type: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method to get a specific entity.
  fn handle_entity_get_entity(&self, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves a singleton entity on the server. If the entity doesn't exist, null is returned.
  fn handle_entity_get_singleton(&self, entity_type: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns a shared entity for the given profile and entity ID.
  /// An entity is shared if its ACL allows for the currently logged
  /// in user to read the data.
  fn handle_entity_get_shared_entity_for_profile_id(&self, profile_id: String, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns all shared entities for the given profile id.
  /// An entity is shared if its ACL allows for the currently logged
  /// in user to read the data.
  fn handle_entity_get_shared_entities_for_profile_id(&self, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of entities from the server base on type and/or where clause
  fn handle_entity_get_list(&self, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of shared entities for the specified user based on type and/or where clause
  fn handle_entity_get_shared_entities_list_for_profile_id(&self, profile_id: String, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets a count of entities based on the where clause
  fn handle_entity_get_list_count(&self, where_json: String, client_index: i32) -> thrift::Result<String>;
  /// Method uses a paging system to iterate through user entities.
  /// After retrieving a page of entities with this method,
  /// use GetPageOffset() to retrieve previous or next pages.
  fn handle_entity_get_page(&self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Method to retrieve previous or next pages after having called
  /// the GetPage method.
  fn handle_entity_get_page_offset(&self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Partial increment of entity data field items. Partial set of items incremented as specified.
  fn handle_entity_increment_user_entity_data(&self, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Partial increment of shared entity data field items. Partial set of items incremented as specified.
  fn handle_entity_increment_shared_user_entity_data(&self, entity_id: String, target_profile_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Sends an event to the designated profile id with the attached json data.
  /// Any events that have been sent to a user will show up in their
  /// incoming event mailbox. If the recordLocally flag is set to true,
  /// a copy of this event (with the exact same event id) will be stored
  /// in the sending user's "sent" event mailbox.
  fn handle_event_send_event(&self, to_profile_id: String, event_type: String, json_event_data: String, client_index: i32) -> thrift::Result<String>;
  /// Updates an event in the user's incoming event mailbox.
  fn handle_event_update_incoming_event_data(&self, ev_id: String, json_event_data: String, client_index: i32) -> thrift::Result<String>;
  /// Delete an event out of the user's incoming mailbox.
  fn handle_event_delete_incoming_event(&self, ev_id: String, client_index: i32) -> thrift::Result<String>;
  /// Get the events currently queued for the user.
  fn handle_event_get_events(&self, client_index: i32) -> thrift::Result<String>;
  /// Prepares a user file upload. On success the file will begin uploading
  /// to the brainCloud server.To be informed of success/failure of the upload
  /// register an IFileUploadCallback with the BrainCloudClient class.
  fn handle_file_upload_file(&self, cloud_path: String, cloud_filename: String, shareable: bool, replace_if_exists: bool, local_path: String, client_index: i32) -> thrift::Result<String>;
  /// Method cancels an upload. If an IFileUploadCallback has been registered with the BrainCloudClient class,
  /// the fileUploadFailed callback method will be called once the upload has been canceled.
  /// NOTE: The upload will still continue in the background on versions of Unity before 5.3
  /// and on Unity mobile platforms.
  fn handle_file_cancel_upload(&self, upload_id: String, client_index: i32) -> thrift::Result<()>;
  /// Returns the progress of the given upload from 0.0 to 1.0 or -1 if upload not found.
  /// NOTE: This will always return 1 on Unity mobile platforms.
  fn handle_file_get_upload_progress(&self, upload_id: String, client_index: i32) -> thrift::Result<OrderedFloat<f64>>;
  /// Returns the number of bytes uploaded or -1 if upload not found.
  /// NOTE: This will always return the total bytes to transfer on Unity mobile platforms.
  fn handle_file_get_upload_bytes_transferred(&self, upload_id: String, client_index: i32) -> thrift::Result<i64>;
  /// Returns the total number of bytes that will be uploaded or -1 if upload not found.
  fn handle_file_get_upload_total_bytes_to_transfer(&self, upload_id: String, client_index: i32) -> thrift::Result<i64>;
  /// List all user files
  fn handle_file_list_user_files_s_f_o(&self, client_index: i32) -> thrift::Result<String>;
  /// List user files from the given cloud path
  fn handle_file_list_user_files_s_n_s_f_o(&self, cloud_path: String, recurse: bool, client_index: i32) -> thrift::Result<String>;
  /// Deletes a single user file.
  fn handle_file_delete_user_file(&self, cloud_path: String, cloud_file_name: String, client_index: i32) -> thrift::Result<String>;
  /// Delete multiple user files
  fn handle_file_delete_user_files(&self, cloud_path: String, recurse: bool, client_index: i32) -> thrift::Result<String>;
  /// Returns the CDN URL for a file object.
  fn handle_file_get_c_d_n_url(&self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_find_user_by_universal_id(&self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String>;
  /// Returns a particular entity of a particular friend.
  fn handle_friend_read_friend_entity(&self, entity_id: String, friend_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns entities of all friends based on type and/or subtype.
  fn handle_friend_read_friends_entities(&self, entity_type: String, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of a particular friend.
  fn handle_friend_read_friend_user_state(&self, friend_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of a particular user.
  fn handle_friend_get_summary_data_for_profile_id(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of a set of users.
  fn handle_friend_get_summary_data_for_profile_ids(&self, player_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of the player's friends.
  fn handle_friend_get_summary_data_for_friends(&self, client_index: i32) -> thrift::Result<String>;
  /// Returns user state of player's recently met.
  fn handle_friend_get_summary_data_for_recently_met_players(&self, client_index: i32) -> thrift::Result<String>;
  /// Finds a list of users matching the search text by performing an exact
  /// search of all user names.
  fn handle_friend_find_users_by_exact_name(&self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String>;
  /// Finds a list of users matching the search text by performing a substring
  /// search of all user names.
  fn handle_friend_find_users_by_substr_name(&self, search_text: String, max_results: i32, client_index: i32) -> thrift::Result<String>;
  /// Retrieves a list of user and friend platform information for all friends of the current user.
  fn handle_friend_list_friends(&self, friend_platform: brain_cloud_service_s_d_k_data_types::FriendPlatform, include_summary_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Links the current user and the specified users as brainCloud friends.
  fn handle_friend_add_friends(&self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Unlinks the current user and the specified users as brainCloud friends.
  fn handle_friend_remove_friends(&self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Get users online status
  fn handle_friend_get_users_online_status(&self, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_send_friend_invitation(&self, to_player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_list_friend_invitations_received(&self, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_list_friend_invitations_sent(&self, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_accept_friend_invitation(&self, from_player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_reject_friend_invitation(&self, from_player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_friend_remove_friend(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves all gamification data for the player.
  fn handle_gamification_read_all_gamification(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves all milestones defined for the game.
  fn handle_gamification_read_milestones(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Read all of the achievements defined for the game.
  fn handle_gamification_read_achievements(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all defined xp levels and any rewards associated
  /// with those xp levels.
  fn handle_gamification_read_xp_levels_meta_data(&self, client_index: i32) -> thrift::Result<String>;
  /// Method retrives the list of achieved achievements.
  fn handle_gamification_read_achieved_achievements(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the list of completed milestones.
  fn handle_gamification_read_completed_milestones(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the list of in progress milestones
  fn handle_gamification_read_in_progress_milestones(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves milestones of the given category.
  fn handle_gamification_read_milestones_by_category(&self, category: String, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method will award the achievements specified. On success, this will
  /// call AwardThirdPartyAchievement to hook into the client-side Achievement
  /// service (ie GameCentre, Facebook etc).
  fn handle_gamification_award_achievements(&self, achievement_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves all of the quests defined for the game.
  fn handle_gamification_read_quests(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all completed quests.
  fn handle_gamification_read_completed_quests(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all in progress quests.
  fn handle_gamification_read_in_progress_quests(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests that haven't been started.
  fn handle_gamification_read_not_started_quests(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests with status.
  fn handle_gamification_read_quests_with_status(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests with a basic percentage.
  fn handle_gamification_read_quests_with_basic_percentage(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests with a complex percentage.
  fn handle_gamification_read_quests_with_complex_percentage(&self, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns all quests for the given category.
  fn handle_gamification_read_quests_by_category(&self, category: String, include_meta_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Sets the specified milestones' statuses to LOCKED.
  fn handle_gamification_reset_milestones(&self, milestone_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method reads all the global properties of the game
  fn handle_global_app_read_properties(&self, client_index: i32) -> thrift::Result<String>;
  /// Method creates a new entity on the server.
  fn handle_global_entity_create_entity(&self, entity_type: String, time_to_live: i64, json_entity_acl: String, json_entity_data: String, client_index: i32) -> thrift::Result<String>;
  /// Method creates a new entity on the server with an indexed id.
  fn handle_global_entity_create_entity_with_indexed_id(&self, entity_type: String, indexed_id: String, time_to_live: i64, json_entity_acl: String, json_entity_data: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity on the server.
  fn handle_global_entity_update_entity(&self, entity_id: String, version: i32, json_entity_data: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity's Acl on the server.
  fn handle_global_entity_update_entity_acl(&self, entity_id: String, version: i32, json_entity_acl: String, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity's time to live on the server.
  fn handle_global_entity_update_entity_time_to_live(&self, entity_id: String, version: i32, time_to_live: i64, client_index: i32) -> thrift::Result<String>;
  /// Method deletes an existing entity on the server.
  fn handle_global_entity_delete_entity(&self, entity_id: String, version: i32, client_index: i32) -> thrift::Result<String>;
  /// Method reads an existing entity from the server.
  fn handle_global_entity_read_entity(&self, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of entities from the server base on type and/or where clause
  fn handle_global_entity_get_list(&self, where_json: String, order_by_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets list of entities from the server base on indexed id
  fn handle_global_entity_get_list_by_indexed_id(&self, entity_indexed_id: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method gets a count of entities based on the where clause
  fn handle_global_entity_get_list_count(&self, where_json: String, client_index: i32) -> thrift::Result<String>;
  /// Method uses a paging system to iterate through Global Entities.
  /// After retrieving a page of Global Entities with this method,
  /// use GetPageOffset() to retrieve previous or next pages.
  fn handle_global_entity_get_page(&self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Method to retrieve previous or next pages after having called
  /// the GetPage method.
  fn handle_global_entity_get_page_offset(&self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Partial increment of global entity data field items. Partial set of items incremented as specified.
  fn handle_global_entity_increment_global_entity_data(&self, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Gets a list of up to randomCount randomly selected entities from the server based on the where condition and specified maximum return count.
  fn handle_global_entity_get_random_entities_matching(&self, where_json: String, max_return: i32, client_index: i32) -> thrift::Result<String>;
  /// Method updates an existing entity's Owner and Acl on the server.
  fn handle_global_entity_update_entity_owner_and_acl(&self, entity_id: String, version: i64, owner_id: String, acl: brain_cloud_service_s_d_k_data_types::JSON, client_index: i32) -> thrift::Result<String>;
  /// Method clears the owner id of an existing entity and sets the Acl on the server.
  fn handle_global_entity_make_system_entity(&self, entity_id: String, version: i64, acl: brain_cloud_service_s_d_k_data_types::JSON, client_index: i32) -> thrift::Result<String>;
  /// Method returns all of the global statistics.
  fn handle_global_statistics_read_all_global_stats(&self, client_index: i32) -> thrift::Result<String>;
  /// Reads a subset of global statistics as defined by the input JSON.
  fn handle_global_statistics_read_global_stats_subset(&self, global_stats: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the global statistics for the given category.
  fn handle_global_statistics_read_global_stats_for_category(&self, category: String, client_index: i32) -> thrift::Result<String>;
  /// Atomically increment (or decrement) global statistics.
  /// Global statistics are defined through the brainCloud portal.
  fn handle_global_statistics_increment_global_stats(&self, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Apply statistics grammar to a partial set of statistics.
  fn handle_global_statistics_process_statistics(&self, statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// Accept an outstanding invitation to join the group.
  fn handle_group_accept_group_invitation(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Add a member to the group.
  fn handle_group_add_group_member(&self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Approve an outstanding request to join the group.
  fn handle_group_approve_group_join_request(&self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Automatically join an open group that matches the search criteria and has space available.
  fn handle_group_auto_join_group(&self, group_type: String, auto_join_strategy: brain_cloud_service_s_d_k_data_types::AutoJoinStrategy, data_query_json: String, client_index: i32) -> thrift::Result<String>;
  /// Cancel an outstanding invitation to the group.
  fn handle_group_cancel_group_invitation(&self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Create a group.
  fn handle_group_create_group(&self, name: String, group_type: String, is_open_group: bool, acl: brain_cloud_service_s_d_k_data_types::JSON, json_data: String, json_owner_attributes: String, json_default_member_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Create a group entity.
  fn handle_group_create_group_entity(&self, group_id: String, entity_type: String, is_owned_by_group_member: bool, acl: brain_cloud_service_s_d_k_data_types::JSON, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Delete a group.
  fn handle_group_delete_group(&self, group_id: String, version: i64, client_index: i32) -> thrift::Result<String>;
  /// Delete a group entity.
  fn handle_group_delete_group_entity(&self, group_id: String, entity_id: String, version: i64, client_index: i32) -> thrift::Result<String>;
  /// Read information on groups to which the current user belongs.
  fn handle_group_get_my_groups(&self, client_index: i32) -> thrift::Result<String>;
  /// Increment elements for the group's data field.
  fn handle_group_increment_group_data(&self, group_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Increment elements for the group entity's data field.
  fn handle_group_increment_group_entity_data(&self, group_id: String, entity_id: String, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Invite a member to the group.
  fn handle_group_invite_group_member(&self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Join an open group or request to join a closed group.
  fn handle_group_join_group(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Leave a group in which the user is a member.
  fn handle_group_leave_group(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve a page of group summary information based on the specified context.
  fn handle_group_list_groups_page(&self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve a page of group summary information based on the encoded context
  /// and specified page offset.
  fn handle_group_list_groups_page_by_offset(&self, context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Read information on groups to which the specified user belongs.  Access is subject to restrictions.
  fn handle_group_list_groups_with_member(&self, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read the specified group.
  fn handle_group_read_group(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read the data of the specified group.
  fn handle_group_read_group_data(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read a page of group entity information.
  fn handle_group_read_group_entities_page(&self, json_context: String, client_index: i32) -> thrift::Result<String>;
  /// Read a page of group entity information.
  fn handle_group_read_group_entities_page_by_offset(&self, encoded_context: String, page_offset: i32, client_index: i32) -> thrift::Result<String>;
  /// Read the specified group entity.
  fn handle_group_read_group_entity(&self, group_id: String, entity_id: String, client_index: i32) -> thrift::Result<String>;
  /// Read the members of the group.
  fn handle_group_read_group_members(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Reject an outstanding invitation to join the group.
  fn handle_group_reject_group_invitation(&self, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Reject an outstanding request to join the group.
  fn handle_group_reject_group_join_request(&self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Remove a member from the group.
  fn handle_group_remove_group_member(&self, group_id: String, profile_id: String, client_index: i32) -> thrift::Result<String>;
  /// Updates a group's data.
  fn handle_group_update_group_data(&self, group_id: String, version: i64, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Update a group entity.
  fn handle_group_update_group_entity_data(&self, group_id: String, entity_id: String, version: i64, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Update a member of the group.
  fn handle_group_update_group_member(&self, group_id: String, profile_id: String, role: brain_cloud_service_s_d_k_data_types::Role, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Updates a group's name.
  fn handle_group_update_group_name(&self, group_id: String, name: String, client_index: i32) -> thrift::Result<String>;
  /// Attach a Email and Password identity to the current profile.
  fn handle_identity_attach_email_identity(&self, email: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Merge the profile associated with the provided e=mail with the current profile.
  fn handle_identity_merge_email_identity(&self, email: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Detach the e-mail identity from the current profile
  fn handle_identity_detach_email_identity(&self, email: String, continue_anon: bool, client_index: i32) -> thrift::Result<String>;
  /// Attach a Universal (userId + password) identity to the current profile.
  fn handle_identity_attach_universal_identity(&self, user_id: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Merge the profile associated with the provided e=mail with the current profile.
  fn handle_identity_merge_universal_identity(&self, user_id: String, password: String, client_index: i32) -> thrift::Result<String>;
  /// Detach the universal identity from the current profile
  fn handle_identity_detach_universal_identity(&self, user_id: String, continue_anon: bool, client_index: i32) -> thrift::Result<String>;
  /// Switch to a Child Profile
  fn handle_identity_switch_to_child_profile(&self, child_profile_id: String, child_app_id: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Switches to the child profile of an app when only one profile exists
  /// If multiple profiles exist this returns an error
  fn handle_identity_switch_to_singleton_child_profile(&self, child_app_id: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Attach a new identity to a parent app
  fn handle_identity_attach_parent_with_identity(&self, external_id: String, authentication_token: String, authentication_type: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Switch to a Parent Profile
  fn handle_identity_switch_to_parent_profile(&self, parent_level_name: String, client_index: i32) -> thrift::Result<String>;
  /// Detaches parent from this user's profile
  fn handle_identity_detach_parent(&self, client_index: i32) -> thrift::Result<String>;
  /// Returns a list of all child profiles in child Apps
  fn handle_identity_get_child_profiles(&self, include_summary_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Retrieve list of identities
  fn handle_identity_get_identities(&self, client_index: i32) -> thrift::Result<String>;
  /// Retrieve list of expired identities
  fn handle_identity_get_expired_identities(&self, client_index: i32) -> thrift::Result<String>;
  /// Refreshes an identity for this user
  fn handle_identity_refresh_identity(&self, external_id: String, authentication_token: String, authentication_type: String, client_index: i32) -> thrift::Result<String>;
  /// Allows email identity email address to be changed
  fn handle_identity_change_email_identity(&self, old_email_address: String, password: String, new_email_address: String, update_contact_email: bool, client_index: i32) -> thrift::Result<String>;
  /// Attaches a peer identity to this user's profile
  fn handle_identity_attach_peer_profile(&self, peer: String, external_id: String, authentication_token: String, authentication_type: String, external_auth_name: String, force_create: bool, client_index: i32) -> thrift::Result<String>;
  /// Detaches a peer identity from this user's profile
  fn handle_identity_detach_peer(&self, peer: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieves a list of attached peer profiles
  fn handle_identity_get_peer_profiles(&self, client_index: i32) -> thrift::Result<String>;
  /// Sends a simple text email to the specified user
  fn handle_mail_send_basic_email(&self, profile_id: String, subject: String, body: String, client_index: i32) -> thrift::Result<String>;
  /// Sends an advanced email to the specified user
  fn handle_mail_send_advanced_email(&self, profile_id: String, json_service_params: String, client_index: i32) -> thrift::Result<String>;
  /// Sends an advanced email to the specified email address
  fn handle_mail_send_advanced_email_by_address(&self, email_address: String, json_service_params: String, client_index: i32) -> thrift::Result<String>;
  /// Read match making record
  fn handle_match_making_read(&self, client_index: i32) -> thrift::Result<String>;
  /// Sets player rating
  fn handle_match_making_set_player_rating(&self, player_rating: i64, client_index: i32) -> thrift::Result<String>;
  /// Resets player rating
  fn handle_match_making_reset_player_rating(&self, client_index: i32) -> thrift::Result<String>;
  /// Increments player rating
  fn handle_match_making_increment_player_rating(&self, increment: i64, client_index: i32) -> thrift::Result<String>;
  /// Decrements player rating
  fn handle_match_making_decrement_player_rating(&self, decrement: i64, client_index: i32) -> thrift::Result<String>;
  /// Turns shield on
  fn handle_match_making_turn_shield_on(&self, client_index: i32) -> thrift::Result<String>;
  /// Turns shield on for the specified number of minutes
  fn handle_match_making_turn_shield_on_for(&self, minutes: i32, client_index: i32) -> thrift::Result<String>;
  /// Turns shield off
  fn handle_match_making_turn_shield_off(&self, client_index: i32) -> thrift::Result<String>;
  /// Increases the shield on time by specified number of minutes
  fn handle_match_making_increment_shield_on_for(&self, minutes: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets the shield expiry for the given player id. Passing in a null player id
  /// will return the shield expiry for the current player. The value returned is
  /// the time in UTC millis when the shield will expire.
  fn handle_match_making_get_shield_expiry(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players
  fn handle_match_making_find_players(&self, range_delta: i64, num_matches: i64, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players with additional attributes
  fn handle_match_making_find_players_with_attributes(&self, range_delta: i64, num_matches: i64, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players using a cloud code filter
  fn handle_match_making_find_players_using_filter(&self, range_delta: i64, num_matches: i64, json_extra_parms: String, client_index: i32) -> thrift::Result<String>;
  /// Finds matchmaking enabled players using a cloud code filter
  /// and additional attributes
  fn handle_match_making_find_players_with_attributes_using_filter(&self, range_delta: i64, num_matches: i64, json_attributes: String, json_extra_parms: String, client_index: i32) -> thrift::Result<String>;
  /// Enables Match Making for the Player
  fn handle_match_making_enable_match_making(&self, client_index: i32) -> thrift::Result<String>;
  /// Disables Match Making for the Player
  fn handle_match_making_disable_match_making(&self, client_index: i32) -> thrift::Result<String>;
  /// Starts a match
  fn handle_one_way_match_start_match(&self, other_player_id: String, range_delta: i64, client_index: i32) -> thrift::Result<String>;
  /// Cancels a match
  fn handle_one_way_match_cancel_match(&self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Completes a match
  fn handle_one_way_match_complete_match(&self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Starts a stream
  fn handle_playback_stream_start_stream(&self, target_player_id: String, include_shared_data: bool, client_index: i32) -> thrift::Result<String>;
  /// Reads a stream
  fn handle_playback_stream_read_stream(&self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Ends a stream
  fn handle_playback_stream_end_stream(&self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Deletes a stream
  fn handle_playback_stream_delete_stream(&self, playback_stream_id: String, client_index: i32) -> thrift::Result<String>;
  /// Adds a stream event
  fn handle_playback_stream_add_event(&self, playback_stream_id: String, event_data: String, summary: String, client_index: i32) -> thrift::Result<String>;
  /// Gets recent streams for initiating player
  fn handle_playback_stream_get_recent_streams_for_initiating_player(&self, initiating_player_id: String, max_num_streams: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets recent streams for target player
  fn handle_playback_stream_get_recent_streams_for_target_player(&self, target_player_id: String, max_num_streams: i32, client_index: i32) -> thrift::Result<String>;
  /// Read the state of the currently logged in user.
  /// This method returns a JSON object describing most of the
  /// player's data: entities, statistics, level, currency.
  /// Apps will typically call this method after authenticating to get an
  /// up-to-date view of the user's data.
  fn handle_player_state_read_user_state(&self, client_index: i32) -> thrift::Result<String>;
  /// Completely deletes the user record and all data fully owned
  /// by the user. After calling this method, the user will need
  /// to re-authenticate and create a new profile.
  /// This is mostly used for debugging/qa.
  fn handle_player_state_delete_user(&self, client_index: i32) -> thrift::Result<String>;
  /// This method will delete *most* data for the currently logged in user.
  /// Data which is not deleted includes: currency, credentials, and
  /// purchase transactions. ResetUser is different from DeleteUser in that
  /// the player record will continue to exist after the reset (so the user
  /// does not need to re-authenticate).
  fn handle_player_state_reset_user(&self, client_index: i32) -> thrift::Result<String>;
  /// Logs user out of server.
  fn handle_player_state_logout(&self, client_index: i32) -> thrift::Result<String>;
  /// Sets the user name.
  fn handle_player_state_update_user_name(&self, user_name: String, client_index: i32) -> thrift::Result<String>;
  /// Updates the "friend summary data" associated with the logged in user.
  /// Some operations will return this summary data. For instance the social
  /// leaderboards will return the player's score in the leaderboard along
  /// with the friend summary data. Generally this data is used to provide
  /// a quick overview of the player without requiring a separate API call
  /// to read their public stats or entity data.
  fn handle_player_state_update_summary_friend_data(&self, json_summary_data: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the user's attributes.
  fn handle_player_state_get_attributes(&self, client_index: i32) -> thrift::Result<String>;
  /// Update user's attributes.
  fn handle_player_state_update_attributes(&self, json_attributes: String, wipe_existing: bool, client_index: i32) -> thrift::Result<String>;
  /// Remove user's attributes.
  fn handle_player_state_remove_attributes(&self, attribute_names: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Updates player's picture URL.
  fn handle_player_state_update_user_picture_url(&self, picture_url: String, client_index: i32) -> thrift::Result<String>;
  /// Update the user's contact email.
  /// Note this is unrelated to email authentication.
  fn handle_player_state_update_contact_email(&self, contact_email: String, client_index: i32) -> thrift::Result<String>;
  /// Read all available user statistics.
  fn handle_player_statistics_read_all_user_stats(&self, client_index: i32) -> thrift::Result<String>;
  /// Reads a subset of user statistics as defined by the input JSON.
  fn handle_player_statistics_read_user_stats_subset(&self, player_stats: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method retrieves the user statistics for the given category.
  fn handle_player_statistics_read_user_stats_for_category(&self, category: String, client_index: i32) -> thrift::Result<String>;
  /// Reset all of the statistics for this user back to their initial value.
  fn handle_player_statistics_reset_all_user_stats(&self, client_index: i32) -> thrift::Result<String>;
  /// Atomically increment (or decrement) user statistics.
  /// Any rewards that are triggered from user statistic increments
  /// will be considered. User statistics are defined through the brainCloud portal.
  /// Note also that the "xpCapped" property is returned (true/false depending on whether
  /// the xp cap is turned on and whether the user has hit it).
  fn handle_player_statistics_increment_user_stats_s_s_f_o(&self, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Atomically increment (or decrement) user statistics.
  /// Any rewards that are triggered from user statistic increments
  /// will be considered. User statistics are defined through the brainCloud portal.
  /// Note also that the "xpCapped" property is returned (true/false depending on whether
  /// the xp cap is turned on and whether the user has hit it).
  fn handle_player_statistics_increment_user_stats_d_s_f_o(&self, dict_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// Apply statistics grammar to a partial set of statistics.
  fn handle_player_statistics_process_statistics(&self, statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// Returns JSON representing the next experience level for the user.
  fn handle_player_statistics_get_next_experience_level(&self, client_index: i32) -> thrift::Result<String>;
  /// Increments the user's experience. If the user goes up a level,
  /// the new level details will be returned along with a list of rewards.
  fn handle_player_statistics_increment_experience_points(&self, xp_value: i32, client_index: i32) -> thrift::Result<String>;
  /// Sets the user's experience to an absolute value. Note that this
  /// is simply a set and will not reward the user if their level changes
  /// as a result.
  fn handle_player_statistics_set_experience_points(&self, xp_value: i32, client_index: i32) -> thrift::Result<String>;
  /// Trigger an event server side that will increase the user statistics.
  /// This may cause one or more awards to be sent back to the user -
  /// could be achievements, experience, etc. Achievements will be sent by this
  /// client library to the appropriate awards service (Apple Game Center, etc).
  /// 
  /// This mechanism supercedes the PlayerStatisticsService API methods, since
  /// PlayerStatisticsService API method only update the raw statistics without
  /// triggering the rewards.
  fn handle_player_statistics_event_trigger_stats_event(&self, event_name: String, event_multiplier: i32, client_index: i32) -> thrift::Result<String>;
  /// See documentation for TriggerStatsEvent for more
  /// documentation.
  fn handle_player_statistics_event_trigger_stats_events(&self, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Gets the player's currency for the given currency type
  /// or all currency types if null passed in.
  fn handle_product_get_currency(&self, currency_type: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets the active sales inventory for the passed-in
  /// currency type.
  fn handle_product_get_sales_inventory(&self, platform: String, user_currency: String, client_index: i32) -> thrift::Result<String>;
  /// Method gets the active sales inventory for the passed-in
  /// currency type and category.
  fn handle_product_get_sales_inventory_by_category(&self, platform: String, user_currency: String, category: String, client_index: i32) -> thrift::Result<String>;
  /// Verify Microsoft Receipt. On success, the player will be awarded the
  /// associated currencies.
  fn handle_product_verify_microsoft_receipt(&self, receipt: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the eligible promotions for the player.
  fn handle_product_get_eligible_promotions(&self, client_index: i32) -> thrift::Result<String>;
  /// Verify ITunes Receipt. On success, the player will be awarded the
  /// associated currencies.
  fn handle_product_verify_itunes_receipt(&self, base64_enc_receipt_data: String, client_index: i32) -> thrift::Result<String>;
  /// Checks supplied text for profanity.
  fn handle_profanity_profanity_check(&self, text: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String>;
  /// Replaces the characters of profanity text with a passed character(s).
  fn handle_profanity_profanity_replace_text(&self, text: String, replace_symbol: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String>;
  /// Checks supplied text for profanity and returns a list of bad wors.
  fn handle_profanity_profanity_identify_bad_words(&self, text: String, languages: String, flag_email: bool, flag_phone: bool, flag_urls: bool, client_index: i32) -> thrift::Result<String>;
  /// Deregisters all device tokens currently registered to the user.
  fn handle_push_notification_deregister_all_push_notification_device_tokens(&self, client_index: i32) -> thrift::Result<String>;
  /// Deregisters the given device token from the server to disable this device
  /// from receiving push notifications.
  fn handle_push_notification_deregister_push_notification_device_token(&self, platform: String, token: String, client_index: i32) -> thrift::Result<String>;
  /// Registers the given device token with the server to enable this device
  /// to receive push notifications.
  fn handle_push_notification_register_push_notification_device_token(&self, platform: String, token: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a simple push notification based on the passed in message.
  /// NOTE: It is possible to send a push notification to oneself.
  fn handle_push_notification_send_simple_push_notification(&self, to_profile_id: String, message: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a user based on a brainCloud portal configured notification template.
  /// NOTE: It is possible to send a push notification to oneself.
  fn handle_push_notification_send_rich_push_notification(&self, to_profile_id: String, notification_template_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a user based on a brainCloud portal configured notification template.
  /// Includes JSON defining the substitution params to use with the template.
  /// See the Portal documentation for more info.
  /// NOTE: It is possible to send a push notification to oneself.
  fn handle_push_notification_send_rich_push_notification_with_params(&self, to_profile_id: String, notification_template_id: i32, substitution_json: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
  /// Includes JSON defining the substitution params to use with the template.
  /// See the Portal documentation for more info.
  fn handle_push_notification_send_templated_push_notification_to_group(&self, group_id: String, notification_template_id: i32, substitutions_json: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
  /// Includes JSON defining the substitution params to use with the template.
  /// See the Portal documentation for more info.
  fn handle_push_notification_send_normalized_push_notification_to_group(&self, group_id: String, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String>;
  /// Schedules raw notifications based on user local time.
  fn handle_push_notification_schedule_raw_push_notification_u_t_c(&self, profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, start_time: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules raw notifications based on user local time.
  fn handle_push_notification_schedule_raw_push_notification_minutes(&self, profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String>;
  /// Sends a raw push notification to a target user.
  fn handle_push_notification_send_raw_push_notification(&self, to_profile_id: String, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a raw push notification to a target list of users.
  fn handle_push_notification_send_raw_push_notification_batch(&self, profile_ids: Vec<String>, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a raw push notification to a target group.
  fn handle_push_notification_send_raw_push_notification_to_group(&self, group_id: String, fcm_content: String, ios_content: String, facebook_content: String, client_index: i32) -> thrift::Result<String>;
  /// Schedules a normalized push notification to a user
  fn handle_push_notification_schedule_normalized_push_notification_u_t_c(&self, profile_id: String, alert_content_json: String, custom_data_json: String, start_time: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules a normalized push notification to a user
  fn handle_push_notification_schedule_normalized_push_notification_minutes(&self, profile_id: String, alert_content_json: String, custom_data_json: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules a rich push notification to a user
  fn handle_push_notification_schedule_rich_push_notification_u_t_c(&self, profile_id: String, notification_template_id: i32, substitutions_json: String, start_time: i32, client_index: i32) -> thrift::Result<String>;
  /// Schedules a rich push notification to a user
  fn handle_push_notification_schedule_rich_push_notification_minutes(&self, profile_id: String, notification_template_id: i32, substitutions_json: String, minutes_from_now: i32, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to a user consisting of alert content and custom data.
  fn handle_push_notification_send_normalized_push_notification(&self, to_profile_id: String, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String>;
  /// Sends a notification to multiple users consisting of alert content and custom data.
  fn handle_push_notification_send_normalized_push_notification_batch(&self, profile_ids: Vec<String>, alert_content_json: String, custom_data_json: String, client_index: i32) -> thrift::Result<String>;
  /// Executes a script on the server.
  fn handle_script_run_script(&self, script_name: String, json_script_data: String, client_index: i32) -> thrift::Result<String>;
  /// Allows cloud script executions to be scheduled
  fn handle_script_schedule_run_script_u_t_c(&self, script_name: String, json_script_data: String, start_date_in_u_t_c: brain_cloud_service_s_d_k_data_types::date, client_index: i32) -> thrift::Result<String>;
  /// Allows cloud script executions to be scheduled
  fn handle_script_schedule_run_script_minutes(&self, script_name: String, json_script_data: String, minutes_from_now: i64, client_index: i32) -> thrift::Result<String>;
  /// Run a cloud script in a parent app
  fn handle_script_run_parent_script(&self, script_name: String, json_script_data: String, parent_level: String, client_index: i32) -> thrift::Result<String>;
  /// Cancels a scheduled cloud code script
  fn handle_script_cancel_scheduled_script(&self, job_id: String, client_index: i32) -> thrift::Result<String>;
  /// Runs a script from the context of a peer
  fn handle_script_run_peer_script(&self, script_name: String, json_script_data: String, peer: String, client_index: i32) -> thrift::Result<String>;
  /// Runs a script asynchronously from the context of a peer
  /// This operation does not wait for the script to complete before returning
  fn handle_script_run_peer_script_asynch(&self, script_name: String, json_script_data: String, peer: String, client_index: i32) -> thrift::Result<String>;
  /// Method returns the social leaderboard. A player's social leaderboard is
  /// comprised of players who are recognized as being your friend.
  /// For now, this applies solely to Facebook connected players who are
  /// friends with the logged in player (who also must be Facebook connected).
  /// In the future this will expand to other identification means (such as
  /// Game Centre, Google circles etc).
  /// 
  /// Leaderboards entries contain the player's score and optionally, some user-defined
  /// data associated with the score. The currently logged in player will also
  /// be returned in the social leaderboard.
  /// 
  /// Note: If no friends have played the game, the bestScore, createdAt, updatedAt
  /// will contain NULL.
  fn handle_social_leaderboard_get_social_leaderboard(&self, leaderboard_id: String, replace_name: bool, client_index: i32) -> thrift::Result<String>;
  /// Reads multiple social leaderboards.
  fn handle_social_leaderboard_get_multi_social_leaderboard(&self, leaderboard_ids: Vec<String>, leaderboard_result_count: i32, replace_name: bool, client_index: i32) -> thrift::Result<String>;
  /// Method returns a page of global leaderboard results.
  /// 
  /// Leaderboards entries contain the player's score and optionally, some user-defined
  /// data associated with the score.
  /// 
  /// Note: This method allows the client to retrieve pages from within the global leaderboard list
  fn handle_social_leaderboard_get_global_leaderboard_page(&self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, start_index: i32, end_index: i32, client_index: i32) -> thrift::Result<String>;
  /// Method returns a page of global leaderboard results. By using a non-current version id,
  /// the user can retrieve a historical leaderboard. See GetGlobalLeaderboardVersions method
  /// to retrieve the version id.
  fn handle_social_leaderboard_get_global_leaderboard_page_by_version(&self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, start_index: i32, end_index: i32, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Method returns a view of global leaderboard results that centers on the current player.
  /// 
  /// Leaderboards entries contain the player's score and optionally, some user-defined
  /// data associated with the score.
  fn handle_social_leaderboard_get_global_leaderboard_view(&self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, client_index: i32) -> thrift::Result<String>;
  /// Method returns a view of global leaderboard results that centers on the current player.
  /// By using a non-current version id, the user can retrieve a historical leaderboard.
  /// See GetGlobalLeaderboardVersions method to retrieve the version id.
  fn handle_social_leaderboard_get_global_leaderboard_view_by_version(&self, leaderboard_id: String, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets the global leaderboard versions.
  fn handle_social_leaderboard_get_global_leaderboard_versions(&self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the social leaderboard for a group.
  fn handle_social_leaderboard_get_group_social_leaderboard(&self, leaderboard_id: String, group_id: String, client_index: i32) -> thrift::Result<String>;
  /// Post the players score to the given social leaderboard.
  /// You can optionally send a user-defined json string of data
  /// with the posted score. This string could include information
  /// relevant to the posted score.
  /// 
  /// Note that the behaviour of posting a score can be modified in
  /// the brainCloud portal. By default, the server will only keep
  /// the player's best score.
  fn handle_social_leaderboard_post_score_to_leaderboard(&self, leaderboard_id: String, score: i64, json_data: String, client_index: i32) -> thrift::Result<String>;
  /// Removes a player's score from the leaderboard
  fn handle_social_leaderboard_remove_player_score(&self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Post the players score to the given social leaderboard.
  /// Pass leaderboard config data to dynamically create if necessary.
  /// You can optionally send a user-defined json string of data
  /// with the posted score. This string could include information
  /// relevant to the posted score.
  fn handle_social_leaderboard_post_score_to_dynamic_leaderboard(&self, leaderboard_id: String, score: i64, json_data: String, leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType, rotation_type: brain_cloud_service_s_d_k_data_types::RotationType, rotation_reset: brain_cloud_service_s_d_k_data_types::date, retained_count: i32, client_index: i32) -> thrift::Result<String>;
  /// Post the players score to the given social leaderboard with a rotation type of DAYS.
  /// Pass leaderboard config data to dynamically create if necessary.
  /// You can optionally send a user-defined json string of data
  /// with the posted score. This string could include information
  /// relevant to the posted score.
  fn handle_social_leaderboard_post_score_to_dynamic_leaderboard_days(&self, leaderboard_id: String, score: i64, json_data: String, leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType, rotation_reset: brain_cloud_service_s_d_k_data_types::date, retained_count: i32, num_days_to_rotate: i32, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the social leaderboard for a list of players.
  fn handle_social_leaderboard_get_players_social_leaderboard(&self, leaderboard_id: String, profile_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Retrieve a list of all leaderboards
  fn handle_social_leaderboard_list_leaderboards(&self, client_index: i32) -> thrift::Result<String>;
  /// Gets the number of entries in a global leaderboard
  fn handle_social_leaderboard_get_global_leaderboard_entry_count(&self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Gets the number of entries in a global leaderboard
  fn handle_social_leaderboard_get_global_leaderboard_entry_count_by_version(&self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets a player's score from a leaderboard
  fn handle_social_leaderboard_get_player_score(&self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Gets a player's score from multiple leaderboards
  fn handle_social_leaderboard_get_player_scores_from_leaderboards(&self, leaderboard_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Method returns the server time in UTC. This is in UNIX millis time format.
  /// For instance 1396378241893 represents 2014-04-01 2:50:41.893 in GMT-4.
  fn handle_time_read_server_time(&self, client_index: i32) -> thrift::Result<String>;
  /// Processes any outstanding rewards for the given player
  fn handle_tournament_claim_tournament_reward(&self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Get tournament status associated with a leaderboard
  fn handle_tournament_get_tournament_status(&self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Join the specified tournament.
  /// Any entry fees will be automatically collected.
  fn handle_tournament_join_tournament(&self, leaderboard_id: String, tournament_code: String, initial_score: i64, client_index: i32) -> thrift::Result<String>;
  /// Removes player's score from tournament leaderboard
  fn handle_tournament_leave_tournament(&self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Post the users score to the leaderboard
  fn handle_tournament_post_tournament_score(&self, leaderboard_id: String, score: i64, json_data: String, round_started_time: brain_cloud_service_s_d_k_data_types::date, client_index: i32) -> thrift::Result<String>;
  /// Post the users score to the leaderboard and returns the results
  fn handle_tournament_post_tournament_score_with_results(&self, leaderboard_id: String, score: i64, json_data: String, round_started_time: brain_cloud_service_s_d_k_data_types::date, sort: brain_cloud_service_s_d_k_data_types::SortOrder, before_count: i32, after_count: i32, initial_score: i64, client_index: i32) -> thrift::Result<String>;
  /// Returns the user's expected reward based on the current scores
  fn handle_tournament_view_current_reward(&self, leaderboard_id: String, client_index: i32) -> thrift::Result<String>;
  /// Returns the user's reward from a finished tournament
  fn handle_tournament_view_reward(&self, leaderboard_id: String, version_id: i32, client_index: i32) -> thrift::Result<String>;
  /// Create a new lobby.
  fn handle_lobby_create_lobby(&self, lobby_type: brain_cloud_service_s_d_k_data_types::LobbyType, max_slots: i32, is_open: bool, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Open a lobby so players can join.
  fn handle_lobby_open_lobby(&self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Close a lobby so players can't join.
  fn handle_lobby_close_lobby(&self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Find lobbies the player can join.
  fn handle_lobby_find_lobbies(&self, free_slots: i32, max_results: i32, json_attributes: String, client_index: i32) -> thrift::Result<String>;
  /// Find lobbies with the player's friends in them.
  fn handle_lobby_find_friends_lobbies(&self, client_index: i32) -> thrift::Result<String>;
  /// Join a lobby.
  fn handle_lobby_join_lobby(&self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Leave a lobby.
  fn handle_lobby_leave_lobby(&self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Destroy a lobby.
  fn handle_lobby_destroy_lobby(&self, lobby_id: String, client_index: i32) -> thrift::Result<String>;
  /// Start a lobby game.
  fn handle_lobby_start_game(&self, lobby_id: String, connection_string: String, client_index: i32) -> thrift::Result<String>;
  /// Get a list of lobbies the player is a member of.
  fn handle_lobby_get_my_lobbies(&self, client_index: i32) -> thrift::Result<String>;
  fn handle_party_accept_party_invitation(&self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_party_get_party_info(&self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_party_join_party(&self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_party_leave_party(&self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_party_reject_party_invitation(&self, party_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_party_send_party_invitation(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_party_list_party_invitations(&self, client_index: i32) -> thrift::Result<String>;
  fn handle_party_get_friends_parties(&self, max_results: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_party_get_my_party(&self, client_index: i32) -> thrift::Result<String>;
  fn handle_patch_get_game_manifest(&self, game_id: String, client_index: i32) -> thrift::Result<String>;
  /// Add a product to the player's shopping cart.
  fn handle_shopping_add_to_cart_s_i_s_f_o(&self, product_id: String, quantity: i32, client_index: i32) -> thrift::Result<String>;
  /// Add a product to the player's shopping cart.
  fn handle_shopping_add_to_cart_i_s_f_o(&self, product_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Empty the player's shopping cart.
  fn handle_shopping_empty_cart(&self, client_index: i32) -> thrift::Result<String>;
  /// Retrieve the player's current shopping cart.
  fn handle_shopping_get_cart(&self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Remove an item from the player's shopping cart.
  fn handle_shopping_remove_from_cart(&self, product_id: String, quantity: i32, client_index: i32) -> thrift::Result<String>;
  /// Add an item to the player's wishlist.
  fn handle_shopping_add_to_wishlist(&self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// Remove all items from the player's wishlist.
  fn handle_shopping_empty_wishlist(&self, client_index: i32) -> thrift::Result<String>;
  /// Returns the current player's wishlist.
  fn handle_shopping_get_my_wishlist(&self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Returns the specified player's wishlist.
  fn handle_shopping_get_wishlist(&self, player_id: String, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Remove an item from the player's wishlist.
  fn handle_shopping_remove_from_wishlist_s_s_f_o(&self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// Remove multiple items from the player's wishlist.
  fn handle_shopping_remove_from_wishlist_i_s_f_o(&self, product_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// Get a list of user reviews for a product.
  fn handle_shopping_get_user_reviews(&self, product_id: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Submit a user review of a product.
  fn handle_shopping_submit_user_review(&self, product_id: String, review_text: String, positive: bool, client_index: i32) -> thrift::Result<String>;
  /// @3972606582
  fn handle_shopping_like_user_review(&self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// @594218927
  fn handle_shopping_unlike_user_review(&self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// @2222188570
  fn handle_shopping_funny_user_review(&self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// @2806051775
  fn handle_shopping_unfunny_user_review(&self, product_id: String, review_id: String, client_index: i32) -> thrift::Result<String>;
  /// Return a list of recently created products.
  fn handle_shopping_get_recently_created_products(&self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Return a list of recently updated products.
  fn handle_shopping_get_recently_updated_products(&self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Return a list of featured products.
  fn handle_shopping_get_featured_products(&self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// Return a list of the mos tpopular products.
  fn handle_shopping_get_popular_products(&self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// Return a list of special offers.
  fn handle_shopping_get_special_offers(&self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @2304250631
  fn handle_shopping_get_my_library(&self, include_details: bool, client_index: i32) -> thrift::Result<String>;
  /// @1350446922
  fn handle_shopping_get_popular_tags(&self, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @3387279661
  fn handle_shopping_get_products_by_tag(&self, tag: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @2681224790
  fn handle_shopping_get_products_by_tags(&self, tags: Vec<String>, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @2681224790
  fn handle_shopping_get_recommended_products(&self, count: i32, client_index: i32) -> thrift::Result<String>;
  /// @919332756
  fn handle_shopping_get_my_orders(&self, include_completed: bool, client_index: i32) -> thrift::Result<String>;
  /// @2681224790
  fn handle_shopping_get_product(&self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// @1777617418
  fn handle_shopping_get_user_tags(&self, product_id: String, page: i32, page_size: i32, client_index: i32) -> thrift::Result<String>;
  /// @274383141
  fn handle_shopping_get_my_user_tags(&self, product_id: String, client_index: i32) -> thrift::Result<String>;
  /// @3717774610
  fn handle_shopping_submit_user_tag(&self, product_id: String, tag: String, client_index: i32) -> thrift::Result<String>;
  /// @3717774610
  fn handle_shopping_submit_user_tags(&self, product_id: String, tags: Vec<String>, client_index: i32) -> thrift::Result<String>;
  /// @2944656417
  fn handle_shopping_remove_user_tag(&self, product_id: String, tag: String, client_index: i32) -> thrift::Result<String>;
  /// @1664102245
  fn handle_shopping_get_build_details(&self, product_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_video(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_screenshot(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_achievement(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_app(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_channel(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_link(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_share_game_guide(&self, timestamp: i32, resource: String, tagged: Vec<String>, show: Vec<String>, block: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_read_social_feed(&self, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_read_filtered_social_feed(&self, skip: i32, limit: i32, player_ids: Vec<String>, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_read_friends_social_feed(&self, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_post_comment(&self, timestamp: i32, parent_id: String, content: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_post_comment_reply(&self, timestamp: i32, parent_id: String, content: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_read_comments(&self, skip: i32, limit: i32, parent_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_read_comment_replies(&self, skip: i32, limit: i32, parent_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_like_comment(&self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_like_activity(&self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_unlike_comment(&self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_unlike_activity(&self, social_feed_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_set_feed_visibility(&self, visibility: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_block_player(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_hide_player(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_unblock_player(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_unhide_player(&self, player_id: String, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_get_activity(&self, social_feed_id: String, depth: i32, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_social_feed_get_comment(&self, social_feed_id: String, depth: i32, skip: i32, limit: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_telemetry_start_telemetry_session(&self, timestamp: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_telemetry_end_telemetry_session(&self, telemetry_session_id: String, timestamp: i32, client_index: i32) -> thrift::Result<String>;
  fn handle_telemetry_log_telemetry_event(&self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  fn handle_telemetry_start_telemetry_event(&self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  fn handle_telemetry_end_telemetry_event(&self, telemetry_session_id: String, timestamp: i32, event_type: String, participant_id: String, custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>, client_index: i32) -> thrift::Result<String>;
  /// @Authentication_GetWeChatQRPageURL_desc
  fn handle_authentication_get_we_chat_q_r_page_u_r_l(&self, client_index: i32) -> thrift::Result<String>;
  /// @BrainCloud_DownloadFile_desc
  fn handle_file_download_file(&self, cloud_path: String, cloud_filename: String, replace_if_exists: bool, client_index: i32) -> thrift::Result<String>;
  /// @BrainCloud_GetDownloadInfo_desc
  fn handle_file_get_download_info(&self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String>;
  /// @BrainCloud_CancelDownload_desc
  fn handle_file_cancel_download(&self, cloud_path: String, cloud_filename: String, client_index: i32) -> thrift::Result<String>;
}

pub struct BrainCloudServiceSyncProcessor<H: BrainCloudServiceSyncHandler> {
  handler: H,
}

impl <H: BrainCloudServiceSyncHandler> BrainCloudServiceSyncProcessor<H> {
  pub fn new(handler: H) -> BrainCloudServiceSyncProcessor<H> {
    BrainCloudServiceSyncProcessor {
      handler,
    }
  }
  fn process_async_match_create_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_create_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_create_match_with_initial_turn(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_create_match_with_initial_turn(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_submit_turn(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_submit_turn(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_update_match_summary_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_update_match_summary_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_complete_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_complete_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_read_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_read_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_read_match_history(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_read_match_history(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_find_matches(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_find_matches(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_find_complete_matches(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_find_complete_matches(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_abandon_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_abandon_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_async_match_delete_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_async_match_delete_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_generate_anonymous_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_generate_anonymous_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_initialize(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_initialize(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_clear_saved_profile_i_d(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_clear_saved_profile_i_d(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_authenticate_anonymous(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_authenticate_anonymous(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_authenticate_email_password(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_authenticate_email_password(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_authenticate_universal(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_authenticate_universal(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_authenticate_external(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_authenticate_external(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_authenticate_phone(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_authenticate_phone(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_authenticate_wechat(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_authenticate_wechat(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_reset_email_password(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_reset_email_password(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_request_sms_code(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_request_sms_code(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_check_username_exists(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_check_username_exists(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_change_universal_password(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_change_universal_password(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_get_session_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_get_session_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_is_authenticated(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_is_authenticated(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_is_initialized(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_is_initialized(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_initialize_s_s_s(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_initialize_s_s_s(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_initialize_s_s_s_s(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_initialize_s_s_s_s(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_initialize_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_initialize_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_update(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_update(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_enable_logging(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_enable_logging(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_reset_communication(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_reset_communication(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_set_packet_timeouts(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_set_packet_timeouts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_set_packet_timeouts_to_default(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_set_packet_timeouts_to_default(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_get_packet_timeouts(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_get_packet_timeouts(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_set_authentication_packet_timeout(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_set_authentication_packet_timeout(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_get_authentication_packet_timeout(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_get_authentication_packet_timeout(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_get_upload_low_transfer_rate_timeout(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_get_upload_low_transfer_rate_timeout(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_set_upload_low_transfer_rate_timeout(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_set_upload_low_transfer_rate_timeout(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_get_upload_low_transfer_rate_threshold(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_get_upload_low_transfer_rate_threshold(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_set_upload_low_transfer_rate_threshold(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_set_upload_low_transfer_rate_threshold(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_enable_network_error_message_caching(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_enable_network_error_message_caching(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_retry_cached_messages(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_retry_cached_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_flush_cached_messages(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_flush_cached_messages(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_insert_end_of_message_bundle_marker(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_insert_end_of_message_bundle_marker(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_override_country_code(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_override_country_code(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_client_override_language_code(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_client_override_language_code(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_data_stream_custom_page_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_data_stream_custom_page_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_data_stream_custom_screen_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_data_stream_custom_screen_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_data_stream_custom_track_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_data_stream_custom_track_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_create_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_create_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_entities_by_type(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_entities_by_type(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_update_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_update_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_update_shared_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_update_shared_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_delete_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_delete_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_update_singleton(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_update_singleton(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_delete_singleton(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_delete_singleton(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_singleton(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_singleton(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_shared_entity_for_profile_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_shared_entity_for_profile_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_shared_entities_for_profile_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_shared_entities_for_profile_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_list(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_shared_entities_list_for_profile_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_shared_entities_list_for_profile_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_list_count(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_list_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_page(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_page(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_get_page_offset(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_get_page_offset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_increment_user_entity_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_increment_user_entity_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_entity_increment_shared_user_entity_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_entity_increment_shared_user_entity_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_event_send_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_event_send_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_event_update_incoming_event_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_event_update_incoming_event_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_event_delete_incoming_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_event_delete_incoming_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_event_get_events(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_event_get_events(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_upload_file(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_upload_file(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_cancel_upload(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_cancel_upload(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_get_upload_progress(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_get_upload_progress(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_get_upload_bytes_transferred(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_get_upload_bytes_transferred(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_get_upload_total_bytes_to_transfer(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_get_upload_total_bytes_to_transfer(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_list_user_files_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_list_user_files_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_list_user_files_s_n_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_list_user_files_s_n_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_delete_user_file(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_delete_user_file(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_delete_user_files(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_delete_user_files(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_get_c_d_n_url(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_get_c_d_n_url(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_find_user_by_universal_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_find_user_by_universal_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_read_friend_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_read_friend_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_read_friends_entities(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_read_friends_entities(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_read_friend_user_state(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_read_friend_user_state(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_get_summary_data_for_profile_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_get_summary_data_for_profile_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_get_summary_data_for_profile_ids(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_get_summary_data_for_profile_ids(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_get_summary_data_for_friends(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_get_summary_data_for_friends(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_get_summary_data_for_recently_met_players(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_get_summary_data_for_recently_met_players(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_find_users_by_exact_name(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_find_users_by_exact_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_find_users_by_substr_name(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_find_users_by_substr_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_list_friends(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_list_friends(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_add_friends(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_add_friends(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_remove_friends(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_remove_friends(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_get_users_online_status(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_get_users_online_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_send_friend_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_send_friend_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_list_friend_invitations_received(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_list_friend_invitations_received(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_list_friend_invitations_sent(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_list_friend_invitations_sent(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_accept_friend_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_accept_friend_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_reject_friend_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_reject_friend_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_friend_remove_friend(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_friend_remove_friend(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_all_gamification(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_all_gamification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_milestones(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_milestones(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_achievements(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_achievements(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_xp_levels_meta_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_xp_levels_meta_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_achieved_achievements(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_achieved_achievements(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_completed_milestones(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_completed_milestones(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_in_progress_milestones(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_in_progress_milestones(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_milestones_by_category(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_milestones_by_category(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_award_achievements(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_award_achievements(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_quests(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_quests(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_completed_quests(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_completed_quests(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_in_progress_quests(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_in_progress_quests(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_not_started_quests(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_not_started_quests(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_quests_with_status(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_quests_with_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_quests_with_basic_percentage(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_quests_with_basic_percentage(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_quests_with_complex_percentage(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_quests_with_complex_percentage(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_read_quests_by_category(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_read_quests_by_category(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_gamification_reset_milestones(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_gamification_reset_milestones(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_app_read_properties(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_app_read_properties(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_create_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_create_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_create_entity_with_indexed_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_create_entity_with_indexed_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_update_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_update_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_update_entity_acl(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_update_entity_acl(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_update_entity_time_to_live(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_update_entity_time_to_live(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_delete_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_delete_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_read_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_read_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_get_list(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_get_list(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_get_list_by_indexed_id(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_get_list_by_indexed_id(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_get_list_count(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_get_list_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_get_page(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_get_page(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_get_page_offset(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_get_page_offset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_increment_global_entity_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_increment_global_entity_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_get_random_entities_matching(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_get_random_entities_matching(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_update_entity_owner_and_acl(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_update_entity_owner_and_acl(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_entity_make_system_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_entity_make_system_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_statistics_read_all_global_stats(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_statistics_read_all_global_stats(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_statistics_read_global_stats_subset(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_statistics_read_global_stats_subset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_statistics_read_global_stats_for_category(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_statistics_read_global_stats_for_category(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_statistics_increment_global_stats(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_statistics_increment_global_stats(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_global_statistics_process_statistics(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_global_statistics_process_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_accept_group_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_accept_group_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_add_group_member(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_add_group_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_approve_group_join_request(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_approve_group_join_request(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_auto_join_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_auto_join_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_cancel_group_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_cancel_group_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_create_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_create_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_create_group_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_create_group_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_delete_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_delete_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_delete_group_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_delete_group_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_get_my_groups(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_get_my_groups(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_increment_group_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_increment_group_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_increment_group_entity_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_increment_group_entity_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_invite_group_member(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_invite_group_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_join_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_join_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_leave_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_leave_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_list_groups_page(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_list_groups_page(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_list_groups_page_by_offset(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_list_groups_page_by_offset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_list_groups_with_member(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_list_groups_with_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_read_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_read_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_read_group_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_read_group_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_read_group_entities_page(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_read_group_entities_page(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_read_group_entities_page_by_offset(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_read_group_entities_page_by_offset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_read_group_entity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_read_group_entity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_read_group_members(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_read_group_members(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_reject_group_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_reject_group_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_reject_group_join_request(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_reject_group_join_request(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_remove_group_member(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_remove_group_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_update_group_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_update_group_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_update_group_entity_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_update_group_entity_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_update_group_member(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_update_group_member(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_group_update_group_name(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_group_update_group_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_attach_email_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_attach_email_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_merge_email_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_merge_email_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_detach_email_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_detach_email_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_attach_universal_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_attach_universal_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_merge_universal_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_merge_universal_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_detach_universal_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_detach_universal_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_switch_to_child_profile(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_switch_to_child_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_switch_to_singleton_child_profile(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_switch_to_singleton_child_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_attach_parent_with_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_attach_parent_with_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_switch_to_parent_profile(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_switch_to_parent_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_detach_parent(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_detach_parent(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_get_child_profiles(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_get_child_profiles(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_get_identities(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_get_identities(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_get_expired_identities(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_get_expired_identities(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_refresh_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_refresh_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_change_email_identity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_change_email_identity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_attach_peer_profile(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_attach_peer_profile(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_detach_peer(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_detach_peer(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_identity_get_peer_profiles(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_identity_get_peer_profiles(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mail_send_basic_email(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_mail_send_basic_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mail_send_advanced_email(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_mail_send_advanced_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_mail_send_advanced_email_by_address(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_mail_send_advanced_email_by_address(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_read(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_read(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_set_player_rating(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_set_player_rating(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_reset_player_rating(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_reset_player_rating(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_increment_player_rating(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_increment_player_rating(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_decrement_player_rating(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_decrement_player_rating(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_turn_shield_on(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_turn_shield_on(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_turn_shield_on_for(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_turn_shield_on_for(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_turn_shield_off(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_turn_shield_off(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_increment_shield_on_for(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_increment_shield_on_for(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_get_shield_expiry(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_get_shield_expiry(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_find_players(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_find_players(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_find_players_with_attributes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_find_players_with_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_find_players_using_filter(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_find_players_using_filter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_find_players_with_attributes_using_filter(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_find_players_with_attributes_using_filter(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_enable_match_making(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_enable_match_making(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_match_making_disable_match_making(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_match_making_disable_match_making(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_one_way_match_start_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_one_way_match_start_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_one_way_match_cancel_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_one_way_match_cancel_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_one_way_match_complete_match(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_one_way_match_complete_match(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_start_stream(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_start_stream(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_read_stream(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_read_stream(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_end_stream(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_end_stream(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_delete_stream(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_delete_stream(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_add_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_add_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_get_recent_streams_for_initiating_player(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_get_recent_streams_for_initiating_player(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_playback_stream_get_recent_streams_for_target_player(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_playback_stream_get_recent_streams_for_target_player(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_read_user_state(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_read_user_state(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_delete_user(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_delete_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_reset_user(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_reset_user(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_logout(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_logout(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_update_user_name(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_update_user_name(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_update_summary_friend_data(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_update_summary_friend_data(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_get_attributes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_get_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_update_attributes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_update_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_remove_attributes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_remove_attributes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_update_user_picture_url(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_update_user_picture_url(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_state_update_contact_email(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_state_update_contact_email(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_read_all_user_stats(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_read_all_user_stats(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_read_user_stats_subset(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_read_user_stats_subset(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_read_user_stats_for_category(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_read_user_stats_for_category(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_reset_all_user_stats(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_reset_all_user_stats(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_increment_user_stats_s_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_increment_user_stats_s_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_increment_user_stats_d_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_increment_user_stats_d_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_process_statistics(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_process_statistics(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_get_next_experience_level(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_get_next_experience_level(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_increment_experience_points(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_increment_experience_points(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_set_experience_points(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_set_experience_points(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_event_trigger_stats_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_event_trigger_stats_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_player_statistics_event_trigger_stats_events(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_player_statistics_event_trigger_stats_events(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_product_get_currency(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_product_get_currency(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_product_get_sales_inventory(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_product_get_sales_inventory(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_product_get_sales_inventory_by_category(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_product_get_sales_inventory_by_category(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_product_verify_microsoft_receipt(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_product_verify_microsoft_receipt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_product_get_eligible_promotions(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_product_get_eligible_promotions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_product_verify_itunes_receipt(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_product_verify_itunes_receipt(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_profanity_profanity_check(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_profanity_profanity_check(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_profanity_profanity_replace_text(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_profanity_profanity_replace_text(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_profanity_profanity_identify_bad_words(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_profanity_profanity_identify_bad_words(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_deregister_all_push_notification_device_tokens(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_deregister_all_push_notification_device_tokens(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_deregister_push_notification_device_token(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_deregister_push_notification_device_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_register_push_notification_device_token(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_register_push_notification_device_token(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_simple_push_notification(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_simple_push_notification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_rich_push_notification(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_rich_push_notification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_rich_push_notification_with_params(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_rich_push_notification_with_params(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_templated_push_notification_to_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_templated_push_notification_to_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_normalized_push_notification_to_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_normalized_push_notification_to_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_schedule_raw_push_notification_u_t_c(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_schedule_raw_push_notification_u_t_c(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_schedule_raw_push_notification_minutes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_schedule_raw_push_notification_minutes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_raw_push_notification(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_raw_push_notification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_raw_push_notification_batch(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_raw_push_notification_batch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_raw_push_notification_to_group(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_raw_push_notification_to_group(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_schedule_normalized_push_notification_u_t_c(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_schedule_normalized_push_notification_u_t_c(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_schedule_normalized_push_notification_minutes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_schedule_normalized_push_notification_minutes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_schedule_rich_push_notification_u_t_c(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_schedule_rich_push_notification_u_t_c(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_schedule_rich_push_notification_minutes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_schedule_rich_push_notification_minutes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_normalized_push_notification(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_normalized_push_notification(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_push_notification_send_normalized_push_notification_batch(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_push_notification_send_normalized_push_notification_batch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_run_script(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_run_script(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_schedule_run_script_u_t_c(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_schedule_run_script_u_t_c(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_schedule_run_script_minutes(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_schedule_run_script_minutes(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_run_parent_script(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_run_parent_script(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_cancel_scheduled_script(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_cancel_scheduled_script(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_run_peer_script(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_run_peer_script(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_script_run_peer_script_asynch(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_script_run_peer_script_asynch(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_social_leaderboard(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_social_leaderboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_multi_social_leaderboard(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_multi_social_leaderboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_page(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_page(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_page_by_version(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_page_by_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_view(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_view(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_view_by_version(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_view_by_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_versions(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_versions(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_group_social_leaderboard(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_group_social_leaderboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_post_score_to_leaderboard(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_post_score_to_leaderboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_remove_player_score(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_remove_player_score(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_post_score_to_dynamic_leaderboard(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_post_score_to_dynamic_leaderboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_post_score_to_dynamic_leaderboard_days(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_post_score_to_dynamic_leaderboard_days(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_players_social_leaderboard(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_players_social_leaderboard(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_list_leaderboards(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_list_leaderboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_entry_count(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_entry_count(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_global_leaderboard_entry_count_by_version(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_global_leaderboard_entry_count_by_version(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_player_score(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_player_score(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_leaderboard_get_player_scores_from_leaderboards(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_leaderboard_get_player_scores_from_leaderboards(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_time_read_server_time(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_time_read_server_time(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_claim_tournament_reward(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_claim_tournament_reward(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_get_tournament_status(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_get_tournament_status(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_join_tournament(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_join_tournament(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_leave_tournament(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_leave_tournament(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_post_tournament_score(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_post_tournament_score(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_post_tournament_score_with_results(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_post_tournament_score_with_results(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_view_current_reward(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_view_current_reward(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_tournament_view_reward(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_tournament_view_reward(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_create_lobby(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_create_lobby(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_open_lobby(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_open_lobby(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_close_lobby(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_close_lobby(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_find_lobbies(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_find_lobbies(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_find_friends_lobbies(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_find_friends_lobbies(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_join_lobby(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_join_lobby(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_leave_lobby(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_leave_lobby(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_destroy_lobby(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_destroy_lobby(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_start_game(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_start_game(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_lobby_get_my_lobbies(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_lobby_get_my_lobbies(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_accept_party_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_accept_party_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_get_party_info(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_get_party_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_join_party(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_join_party(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_leave_party(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_leave_party(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_reject_party_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_reject_party_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_send_party_invitation(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_send_party_invitation(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_list_party_invitations(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_list_party_invitations(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_get_friends_parties(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_get_friends_parties(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_party_get_my_party(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_party_get_my_party(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_patch_get_game_manifest(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_patch_get_game_manifest(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_add_to_cart_s_i_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_add_to_cart_s_i_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_add_to_cart_i_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_add_to_cart_i_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_empty_cart(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_empty_cart(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_cart(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_cart(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_remove_from_cart(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_remove_from_cart(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_add_to_wishlist(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_add_to_wishlist(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_empty_wishlist(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_empty_wishlist(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_my_wishlist(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_my_wishlist(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_wishlist(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_wishlist(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_remove_from_wishlist_s_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_remove_from_wishlist_s_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_remove_from_wishlist_i_s_f_o(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_remove_from_wishlist_i_s_f_o(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_user_reviews(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_user_reviews(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_submit_user_review(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_submit_user_review(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_like_user_review(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_like_user_review(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_unlike_user_review(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_unlike_user_review(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_funny_user_review(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_funny_user_review(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_unfunny_user_review(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_unfunny_user_review(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_recently_created_products(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_recently_created_products(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_recently_updated_products(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_recently_updated_products(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_featured_products(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_featured_products(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_popular_products(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_popular_products(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_special_offers(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_special_offers(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_my_library(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_my_library(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_popular_tags(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_popular_tags(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_products_by_tag(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_products_by_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_products_by_tags(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_products_by_tags(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_recommended_products(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_recommended_products(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_my_orders(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_my_orders(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_product(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_product(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_user_tags(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_user_tags(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_my_user_tags(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_my_user_tags(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_submit_user_tag(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_submit_user_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_submit_user_tags(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_submit_user_tags(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_remove_user_tag(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_remove_user_tag(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_shopping_get_build_details(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_shopping_get_build_details(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_video(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_video(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_screenshot(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_screenshot(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_achievement(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_achievement(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_app(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_app(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_channel(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_channel(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_link(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_link(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_share_game_guide(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_share_game_guide(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_read_social_feed(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_read_social_feed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_read_filtered_social_feed(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_read_filtered_social_feed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_read_friends_social_feed(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_read_friends_social_feed(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_post_comment(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_post_comment(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_post_comment_reply(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_post_comment_reply(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_read_comments(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_read_comments(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_read_comment_replies(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_read_comment_replies(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_like_comment(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_like_comment(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_like_activity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_like_activity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_unlike_comment(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_unlike_comment(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_unlike_activity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_unlike_activity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_set_feed_visibility(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_set_feed_visibility(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_block_player(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_block_player(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_hide_player(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_hide_player(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_unblock_player(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_unblock_player(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_unhide_player(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_unhide_player(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_get_activity(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_get_activity(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_social_feed_get_comment(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_social_feed_get_comment(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_telemetry_start_telemetry_session(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_telemetry_start_telemetry_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_telemetry_end_telemetry_session(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_telemetry_end_telemetry_session(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_telemetry_log_telemetry_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_telemetry_log_telemetry_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_telemetry_start_telemetry_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_telemetry_start_telemetry_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_telemetry_end_telemetry_event(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_telemetry_end_telemetry_event(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_authentication_get_we_chat_q_r_page_u_r_l(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_authentication_get_we_chat_q_r_page_u_r_l(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_download_file(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_download_file(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_get_download_info(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_get_download_info(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
  fn process_file_cancel_download(&self, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    TBrainCloudServiceProcessFunctions::process_file_cancel_download(&self.handler, incoming_sequence_number, i_prot, o_prot)
  }
}

pub struct TBrainCloudServiceProcessFunctions;

impl TBrainCloudServiceProcessFunctions {
  pub fn process_async_match_create_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchCreateMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_create_match(args.json_opponent_ids, args.push_notification_message, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchCreateMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_create_match_with_initial_turn<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_create_match_with_initial_turn(args.json_opponent_ids, args.json_match_state, args.push_notification_message, args.next_player, args.json_summary, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatchWithInitialTurn", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatchWithInitialTurn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_CreateMatchWithInitialTurn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_submit_turn<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchSubmitTurnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_submit_turn(args.owner_id, args.match_id, args.version, args.json_match_state, args.push_notification_message, args.next_player, args.json_summary, args.json_statistics, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_SubmitTurn", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchSubmitTurnResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_SubmitTurn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_SubmitTurn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_update_match_summary_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_update_match_summary_data(args.owner_id, args.match_id, args.version, args.json_summary, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_UpdateMatchSummaryData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_UpdateMatchSummaryData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_UpdateMatchSummaryData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_complete_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchCompleteMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_complete_match(args.owner_id, args.match_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_CompleteMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchCompleteMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_CompleteMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_CompleteMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_read_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchReadMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_read_match(args.owner_id, args.match_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchReadMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_read_match_history<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchReadMatchHistoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_read_match_history(args.owner_id, args.match_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatchHistory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchReadMatchHistoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatchHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_ReadMatchHistory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_find_matches<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchFindMatchesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_find_matches(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_FindMatches", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchFindMatchesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_FindMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_FindMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_find_complete_matches<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchFindCompleteMatchesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_find_complete_matches(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_FindCompleteMatches", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchFindCompleteMatchesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_FindCompleteMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_FindCompleteMatches", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_abandon_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchAbandonMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_abandon_match(args.owner_id, args.match_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_AbandonMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchAbandonMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_AbandonMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_AbandonMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_async_match_delete_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAsyncMatchDeleteMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_async_match_delete_match(args.owner_id, args.match_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("AsyncMatch_DeleteMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAsyncMatchDeleteMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("AsyncMatch_DeleteMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("AsyncMatch_DeleteMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_generate_anonymous_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationGenerateAnonymousIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_generate_anonymous_id(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_GenerateAnonymousId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationGenerateAnonymousIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_GenerateAnonymousId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_GenerateAnonymousId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_initialize<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationInitializeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_initialize(args.profile_id, args.anonymous_id, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Authentication_Initialize", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationInitializeResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_Initialize", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_Initialize", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_clear_saved_profile_i_d<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationClearSavedProfileIDArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_clear_saved_profile_i_d(args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Authentication_ClearSavedProfileID", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationClearSavedProfileIDResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_ClearSavedProfileID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_ClearSavedProfileID", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_authenticate_anonymous<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationAuthenticateAnonymousArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_authenticate_anonymous(args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateAnonymous", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationAuthenticateAnonymousResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateAnonymous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateAnonymous", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_authenticate_email_password<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_authenticate_email_password(args.email, args.password, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateEmailPassword", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateEmailPassword", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateEmailPassword", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_authenticate_universal<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationAuthenticateUniversalArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_authenticate_universal(args.user_id, args.password, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateUniversal", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationAuthenticateUniversalResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateUniversal", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateUniversal", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_authenticate_external<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationAuthenticateExternalArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_authenticate_external(args.user_id, args.token, args.external_auth_name, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateExternal", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationAuthenticateExternalResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateExternal", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateExternal", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_authenticate_phone<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationAuthenticatePhoneArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_authenticate_phone(args.phone_number, args.auth_code, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticatePhone", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationAuthenticatePhoneResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticatePhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticatePhone", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_authenticate_wechat<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationAuthenticateWechatArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_authenticate_wechat(args.open_id, args.token, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_AuthenticateWechat", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationAuthenticateWechatResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateWechat", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_AuthenticateWechat", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_reset_email_password<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationResetEmailPasswordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_reset_email_password(args.external_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_ResetEmailPassword", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationResetEmailPasswordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_ResetEmailPassword", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_ResetEmailPassword", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_request_sms_code<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationRequestSmsCodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_request_sms_code(args.phone_number, args.force_create, args.is_international, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_RequestSmsCode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationRequestSmsCodeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_RequestSmsCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_RequestSmsCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_check_username_exists<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationCheckUsernameExistsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_check_username_exists(args.game_id, args.player_name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_CheckUsernameExists", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationCheckUsernameExistsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_CheckUsernameExists", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_CheckUsernameExists", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_change_universal_password<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationChangeUniversalPasswordArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_change_universal_password(args.game_id, args.player_id, args.old_password, args.new_password, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_ChangeUniversalPassword", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationChangeUniversalPasswordResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_ChangeUniversalPassword", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_ChangeUniversalPassword", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_get_session_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientGetSessionIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_get_session_id(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_GetSessionId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientGetSessionIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_GetSessionId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_GetSessionId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_is_authenticated<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientIsAuthenticatedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_is_authenticated(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_IsAuthenticated", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientIsAuthenticatedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_IsAuthenticated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_IsAuthenticated", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_is_initialized<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientIsInitializedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_is_initialized(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_IsInitialized", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientIsInitializedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_IsInitialized", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_IsInitialized", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_initialize_s_s_s<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientInitializeSSSArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_initialize_s_s_s(args.secret_key, args.app_id, args.app_version, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_Initialize_SSS", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientInitializeSSSResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_Initialize_SSS", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_Initialize_SSS", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_initialize_s_s_s_s<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientInitializeSSSSArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_initialize_s_s_s_s(args.server_u_r_l, args.secret_key, args.app_id, args.app_version, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_Initialize_SSSS", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientInitializeSSSSResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_Initialize_SSSS", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_Initialize_SSSS", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_initialize_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientInitializeIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_initialize_identity(args.profile_id, args.anonymous_id, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_InitializeIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientInitializeIdentityResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_InitializeIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_InitializeIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_update<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientUpdateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_update(args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_Update", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientUpdateResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_Update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_Update", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_enable_logging<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientEnableLoggingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_enable_logging(args.enable, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_EnableLogging", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientEnableLoggingResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_EnableLogging", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_EnableLogging", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_reset_communication<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientResetCommunicationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_reset_communication(args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_ResetCommunication", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientResetCommunicationResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_ResetCommunication", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_ResetCommunication", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_set_packet_timeouts<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientSetPacketTimeoutsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_set_packet_timeouts(args.timeouts, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_SetPacketTimeouts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientSetPacketTimeoutsResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_SetPacketTimeouts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_SetPacketTimeouts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_set_packet_timeouts_to_default<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_set_packet_timeouts_to_default(args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_SetPacketTimeoutsToDefault", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientSetPacketTimeoutsToDefaultResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_SetPacketTimeoutsToDefault", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_SetPacketTimeoutsToDefault", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_get_packet_timeouts<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientGetPacketTimeoutsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_get_packet_timeouts(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_GetPacketTimeouts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientGetPacketTimeoutsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_GetPacketTimeouts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_GetPacketTimeouts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_set_authentication_packet_timeout<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_set_authentication_packet_timeout(args.timeout_secs, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_SetAuthenticationPacketTimeout", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientSetAuthenticationPacketTimeoutResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_SetAuthenticationPacketTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_SetAuthenticationPacketTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_get_authentication_packet_timeout<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_get_authentication_packet_timeout(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_GetAuthenticationPacketTimeout", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientGetAuthenticationPacketTimeoutResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_GetAuthenticationPacketTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_GetAuthenticationPacketTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_get_upload_low_transfer_rate_timeout<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_get_upload_low_transfer_rate_timeout(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateTimeout", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_set_upload_low_transfer_rate_timeout<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_set_upload_low_transfer_rate_timeout(args.timeout_secs, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateTimeout", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateTimeout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_get_upload_low_transfer_rate_threshold<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_get_upload_low_transfer_rate_threshold(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateThreshold", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientGetUploadLowTransferRateThresholdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateThreshold", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_GetUploadLowTransferRateThreshold", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_set_upload_low_transfer_rate_threshold<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_set_upload_low_transfer_rate_threshold(args.bytes_per_sec, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateThreshold", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientSetUploadLowTransferRateThresholdResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateThreshold", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_SetUploadLowTransferRateThreshold", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_enable_network_error_message_caching<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_enable_network_error_message_caching(args.enabled, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_EnableNetworkErrorMessageCaching", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientEnableNetworkErrorMessageCachingResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_EnableNetworkErrorMessageCaching", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_EnableNetworkErrorMessageCaching", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_retry_cached_messages<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientRetryCachedMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_retry_cached_messages(args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_RetryCachedMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientRetryCachedMessagesResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_RetryCachedMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_RetryCachedMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_flush_cached_messages<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientFlushCachedMessagesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_flush_cached_messages(args.send_api_error_callbacks, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_FlushCachedMessages", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientFlushCachedMessagesResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_FlushCachedMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_FlushCachedMessages", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_insert_end_of_message_bundle_marker<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_insert_end_of_message_bundle_marker(args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_InsertEndOfMessageBundleMarker", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_InsertEndOfMessageBundleMarker", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_InsertEndOfMessageBundleMarker", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_override_country_code<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientOverrideCountryCodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_override_country_code(args.country_code, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_OverrideCountryCode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientOverrideCountryCodeResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_OverrideCountryCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_OverrideCountryCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_client_override_language_code<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceClientOverrideLanguageCodeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_client_override_language_code(args.language_code, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("Client_OverrideLanguageCode", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceClientOverrideLanguageCodeResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Client_OverrideLanguageCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Client_OverrideLanguageCode", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_data_stream_custom_page_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceDataStreamCustomPageEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_data_stream_custom_page_event(args.event_name, args.json_event_properties, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DataStream_CustomPageEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceDataStreamCustomPageEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DataStream_CustomPageEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("DataStream_CustomPageEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_data_stream_custom_screen_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceDataStreamCustomScreenEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_data_stream_custom_screen_event(args.event_name, args.json_event_properties, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DataStream_CustomScreenEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceDataStreamCustomScreenEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DataStream_CustomScreenEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("DataStream_CustomScreenEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_data_stream_custom_track_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceDataStreamCustomTrackEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_data_stream_custom_track_event(args.event_name, args.json_event_properties, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("DataStream_CustomTrackEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceDataStreamCustomTrackEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("DataStream_CustomTrackEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("DataStream_CustomTrackEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_create_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityCreateEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_create_entity(args.entity_type, args.json_entity_data, args.json_entity_acl, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_CreateEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityCreateEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_CreateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_CreateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_entities_by_type<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetEntitiesByTypeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_entities_by_type(args.entity_type, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetEntitiesByType", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetEntitiesByTypeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetEntitiesByType", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetEntitiesByType", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_update_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityUpdateEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_update_entity(args.entity_id, args.entity_type, args.json_entity_data, args.json_entity_acl, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_UpdateEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityUpdateEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_UpdateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_UpdateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_update_shared_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityUpdateSharedEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_update_shared_entity(args.entity_id, args.target_profile_id, args.entity_type, args.json_entity_data, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_UpdateSharedEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityUpdateSharedEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_UpdateSharedEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_UpdateSharedEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_delete_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityDeleteEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_delete_entity(args.entity_id, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_DeleteEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityDeleteEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_DeleteEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_DeleteEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_update_singleton<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityUpdateSingletonArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_update_singleton(args.entity_type, args.json_entity_data, args.json_entity_acl, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_UpdateSingleton", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityUpdateSingletonResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_UpdateSingleton", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_UpdateSingleton", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_delete_singleton<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityDeleteSingletonArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_delete_singleton(args.entity_type, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_DeleteSingleton", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityDeleteSingletonResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_DeleteSingleton", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_DeleteSingleton", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_entity(args.entity_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_singleton<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetSingletonArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_singleton(args.entity_type, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetSingleton", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetSingletonResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetSingleton", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetSingleton", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_shared_entity_for_profile_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetSharedEntityForProfileIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_shared_entity_for_profile_id(args.profile_id, args.entity_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetSharedEntityForProfileId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetSharedEntityForProfileIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetSharedEntityForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetSharedEntityForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_shared_entities_for_profile_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_shared_entities_for_profile_id(args.profile_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesForProfileId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_list<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_list(args.where_json, args.order_by_json, args.max_return, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetListResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_shared_entities_list_for_profile_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_shared_entities_list_for_profile_id(args.profile_id, args.where_json, args.order_by_json, args.max_return, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesListForProfileId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesListForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetSharedEntitiesListForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_list_count<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetListCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_list_count(args.where_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetListCount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetListCountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetListCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetListCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_page<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetPageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_page(args.json_context, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetPage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetPageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_get_page_offset<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityGetPageOffsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_get_page_offset(args.context, args.page_offset, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_GetPageOffset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityGetPageOffsetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_GetPageOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_GetPageOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_increment_user_entity_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityIncrementUserEntityDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_increment_user_entity_data(args.entity_id, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_IncrementUserEntityData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityIncrementUserEntityDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_IncrementUserEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_IncrementUserEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_entity_increment_shared_user_entity_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEntityIncrementSharedUserEntityDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_entity_increment_shared_user_entity_data(args.entity_id, args.target_profile_id, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Entity_IncrementSharedUserEntityData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEntityIncrementSharedUserEntityDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Entity_IncrementSharedUserEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Entity_IncrementSharedUserEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_event_send_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEventSendEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_event_send_event(args.to_profile_id, args.event_type, args.json_event_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Event_SendEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEventSendEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Event_SendEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Event_SendEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_event_update_incoming_event_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEventUpdateIncomingEventDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_event_update_incoming_event_data(args.ev_id, args.json_event_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Event_UpdateIncomingEventData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEventUpdateIncomingEventDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Event_UpdateIncomingEventData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Event_UpdateIncomingEventData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_event_delete_incoming_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEventDeleteIncomingEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_event_delete_incoming_event(args.ev_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Event_DeleteIncomingEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEventDeleteIncomingEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Event_DeleteIncomingEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Event_DeleteIncomingEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_event_get_events<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceEventGetEventsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_event_get_events(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Event_GetEvents", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceEventGetEventsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Event_GetEvents", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Event_GetEvents", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_upload_file<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileUploadFileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_upload_file(args.cloud_path, args.cloud_filename, args.shareable, args.replace_if_exists, args.local_path, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_UploadFile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileUploadFileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_UploadFile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_UploadFile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_cancel_upload<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileCancelUploadArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_cancel_upload(args.upload_id, args.client_index) {
      Ok(_) => {
        let message_ident = TMessageIdentifier::new("File_CancelUpload", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileCancelUploadResult {  };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_CancelUpload", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_CancelUpload", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_get_upload_progress<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileGetUploadProgressArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_get_upload_progress(args.upload_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_GetUploadProgress", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileGetUploadProgressResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_GetUploadProgress", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_GetUploadProgress", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_get_upload_bytes_transferred<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileGetUploadBytesTransferredArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_get_upload_bytes_transferred(args.upload_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_GetUploadBytesTransferred", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileGetUploadBytesTransferredResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_GetUploadBytesTransferred", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_GetUploadBytesTransferred", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_get_upload_total_bytes_to_transfer<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileGetUploadTotalBytesToTransferArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_get_upload_total_bytes_to_transfer(args.upload_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_GetUploadTotalBytesToTransfer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileGetUploadTotalBytesToTransferResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_GetUploadTotalBytesToTransfer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_GetUploadTotalBytesToTransfer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_list_user_files_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileListUserFilesSFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_list_user_files_s_f_o(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_ListUserFiles_SFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileListUserFilesSFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_ListUserFiles_SFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_ListUserFiles_SFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_list_user_files_s_n_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileListUserFilesSNSFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_list_user_files_s_n_s_f_o(args.cloud_path, args.recurse, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_ListUserFiles_SNSFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileListUserFilesSNSFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_ListUserFiles_SNSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_ListUserFiles_SNSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_delete_user_file<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileDeleteUserFileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_delete_user_file(args.cloud_path, args.cloud_file_name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_DeleteUserFile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileDeleteUserFileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_DeleteUserFile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_DeleteUserFile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_delete_user_files<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileDeleteUserFilesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_delete_user_files(args.cloud_path, args.recurse, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_DeleteUserFiles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileDeleteUserFilesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_DeleteUserFiles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_DeleteUserFiles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_get_c_d_n_url<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileGetCDNUrlArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_get_c_d_n_url(args.cloud_path, args.cloud_filename, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_GetCDNUrl", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileGetCDNUrlResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_GetCDNUrl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_GetCDNUrl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_find_user_by_universal_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendFindUserByUniversalIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_find_user_by_universal_id(args.search_text, args.max_results, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_FindUserByUniversalId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendFindUserByUniversalIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_FindUserByUniversalId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_FindUserByUniversalId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_read_friend_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendReadFriendEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_read_friend_entity(args.entity_id, args.friend_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_ReadFriendEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendReadFriendEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_ReadFriendEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_ReadFriendEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_read_friends_entities<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendReadFriendsEntitiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_read_friends_entities(args.entity_type, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_ReadFriendsEntities", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendReadFriendsEntitiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_ReadFriendsEntities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_ReadFriendsEntities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_read_friend_user_state<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendReadFriendUserStateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_read_friend_user_state(args.friend_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_ReadFriendUserState", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendReadFriendUserStateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_ReadFriendUserState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_ReadFriendUserState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_get_summary_data_for_profile_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendGetSummaryDataForProfileIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_get_summary_data_for_profile_id(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendGetSummaryDataForProfileIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_get_summary_data_for_profile_ids<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_get_summary_data_for_profile_ids(args.player_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileIds", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendGetSummaryDataForProfileIdsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForProfileIds", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_get_summary_data_for_friends<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendGetSummaryDataForFriendsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_get_summary_data_for_friends(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForFriends", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendGetSummaryDataForFriendsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_get_summary_data_for_recently_met_players<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_get_summary_data_for_recently_met_players(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForRecentlyMetPlayers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForRecentlyMetPlayers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_GetSummaryDataForRecentlyMetPlayers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_find_users_by_exact_name<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendFindUsersByExactNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_find_users_by_exact_name(args.search_text, args.max_results, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_FindUsersByExactName", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendFindUsersByExactNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_FindUsersByExactName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_FindUsersByExactName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_find_users_by_substr_name<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendFindUsersBySubstrNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_find_users_by_substr_name(args.search_text, args.max_results, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_FindUsersBySubstrName", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendFindUsersBySubstrNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_FindUsersBySubstrName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_FindUsersBySubstrName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_list_friends<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendListFriendsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_list_friends(args.friend_platform, args.include_summary_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_ListFriends", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendListFriendsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_ListFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_ListFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_add_friends<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendAddFriendsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_add_friends(args.profile_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_AddFriends", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendAddFriendsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_AddFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_AddFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_remove_friends<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendRemoveFriendsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_remove_friends(args.profile_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_RemoveFriends", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendRemoveFriendsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_RemoveFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_RemoveFriends", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_get_users_online_status<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendGetUsersOnlineStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_get_users_online_status(args.profile_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_GetUsersOnlineStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendGetUsersOnlineStatusResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_GetUsersOnlineStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_GetUsersOnlineStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_send_friend_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendSendFriendInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_send_friend_invitation(args.to_player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_SendFriendInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendSendFriendInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_SendFriendInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_SendFriendInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_list_friend_invitations_received<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendListFriendInvitationsReceivedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_list_friend_invitations_received(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsReceived", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendListFriendInvitationsReceivedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsReceived", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsReceived", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_list_friend_invitations_sent<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendListFriendInvitationsSentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_list_friend_invitations_sent(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsSent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendListFriendInvitationsSentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsSent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_ListFriendInvitationsSent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_accept_friend_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendAcceptFriendInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_accept_friend_invitation(args.from_player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_AcceptFriendInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendAcceptFriendInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_AcceptFriendInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_AcceptFriendInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_reject_friend_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendRejectFriendInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_reject_friend_invitation(args.from_player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_RejectFriendInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendRejectFriendInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_RejectFriendInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_RejectFriendInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_friend_remove_friend<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFriendRemoveFriendArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_friend_remove_friend(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Friend_RemoveFriend", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFriendRemoveFriendResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Friend_RemoveFriend", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Friend_RemoveFriend", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_all_gamification<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadAllGamificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_all_gamification(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadAllGamification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadAllGamificationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadAllGamification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadAllGamification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_milestones<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadMilestonesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_milestones(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadMilestones", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadMilestonesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_achievements<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadAchievementsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_achievements(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadAchievements", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadAchievementsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadAchievements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadAchievements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_xp_levels_meta_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadXpLevelsMetaDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_xp_levels_meta_data(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadXpLevelsMetaData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadXpLevelsMetaDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadXpLevelsMetaData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadXpLevelsMetaData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_achieved_achievements<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadAchievedAchievementsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_achieved_achievements(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadAchievedAchievements", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadAchievedAchievementsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadAchievedAchievements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadAchievedAchievements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_completed_milestones<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadCompletedMilestonesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_completed_milestones(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedMilestones", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadCompletedMilestonesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_in_progress_milestones<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadInProgressMilestonesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_in_progress_milestones(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressMilestones", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadInProgressMilestonesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_milestones_by_category<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadMilestonesByCategoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_milestones_by_category(args.category, args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadMilestonesByCategory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadMilestonesByCategoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadMilestonesByCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadMilestonesByCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_award_achievements<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationAwardAchievementsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_award_achievements(args.achievement_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_AwardAchievements", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationAwardAchievementsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_AwardAchievements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_AwardAchievements", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_quests<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadQuestsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_quests(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuests", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadQuestsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_completed_quests<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadCompletedQuestsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_completed_quests(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedQuests", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadCompletedQuestsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadCompletedQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_in_progress_quests<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadInProgressQuestsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_in_progress_quests(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressQuests", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadInProgressQuestsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadInProgressQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_not_started_quests<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadNotStartedQuestsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_not_started_quests(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadNotStartedQuests", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadNotStartedQuestsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadNotStartedQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadNotStartedQuests", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_quests_with_status<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadQuestsWithStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_quests_with_status(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadQuestsWithStatusResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_quests_with_basic_percentage<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_quests_with_basic_percentage(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithBasicPercentage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithBasicPercentage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithBasicPercentage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_quests_with_complex_percentage<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_quests_with_complex_percentage(args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithComplexPercentage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithComplexPercentage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsWithComplexPercentage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_read_quests_by_category<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationReadQuestsByCategoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_read_quests_by_category(args.category, args.include_meta_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsByCategory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationReadQuestsByCategoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsByCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ReadQuestsByCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_gamification_reset_milestones<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGamificationResetMilestonesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_gamification_reset_milestones(args.milestone_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Gamification_ResetMilestones", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGamificationResetMilestonesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Gamification_ResetMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Gamification_ResetMilestones", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_app_read_properties<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalAppReadPropertiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_app_read_properties(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalApp_ReadProperties", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalAppReadPropertiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalApp_ReadProperties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalApp_ReadProperties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_create_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityCreateEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_create_entity(args.entity_type, args.time_to_live, args.json_entity_acl, args.json_entity_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityCreateEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_create_entity_with_indexed_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_create_entity_with_indexed_id(args.entity_type, args.indexed_id, args.time_to_live, args.json_entity_acl, args.json_entity_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntityWithIndexedId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntityWithIndexedId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_CreateEntityWithIndexedId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_update_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityUpdateEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_update_entity(args.entity_id, args.version, args.json_entity_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityUpdateEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_update_entity_acl<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityUpdateEntityAclArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_update_entity_acl(args.entity_id, args.version, args.json_entity_acl, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityAcl", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityUpdateEntityAclResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityAcl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityAcl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_update_entity_time_to_live<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_update_entity_time_to_live(args.entity_id, args.version, args.time_to_live, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityTimeToLive", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityTimeToLive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityTimeToLive", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_delete_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityDeleteEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_delete_entity(args.entity_id, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_DeleteEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityDeleteEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_DeleteEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_DeleteEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_read_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityReadEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_read_entity(args.entity_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_ReadEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityReadEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_ReadEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_ReadEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_get_list<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityGetListArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_get_list(args.where_json, args.order_by_json, args.max_return, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetList", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityGetListResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetList", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_get_list_by_indexed_id<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityGetListByIndexedIdArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_get_list_by_indexed_id(args.entity_indexed_id, args.max_return, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetListByIndexedId", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityGetListByIndexedIdResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetListByIndexedId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetListByIndexedId", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_get_list_count<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityGetListCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_get_list_count(args.where_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetListCount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityGetListCountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetListCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetListCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_get_page<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityGetPageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_get_page(args.json_context, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetPage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityGetPageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_get_page_offset<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityGetPageOffsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_get_page_offset(args.context, args.page_offset, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetPageOffset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityGetPageOffsetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetPageOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetPageOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_increment_global_entity_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_increment_global_entity_data(args.entity_id, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_IncrementGlobalEntityData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_IncrementGlobalEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_IncrementGlobalEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_get_random_entities_matching<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_get_random_entities_matching(args.where_json, args.max_return, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_GetRandomEntitiesMatching", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetRandomEntitiesMatching", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_GetRandomEntitiesMatching", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_update_entity_owner_and_acl<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_update_entity_owner_and_acl(args.entity_id, args.version, args.owner_id, args.acl, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityOwnerAndAcl", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityOwnerAndAcl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_UpdateEntityOwnerAndAcl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_entity_make_system_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalEntityMakeSystemEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_entity_make_system_entity(args.entity_id, args.version, args.acl, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalEntity_MakeSystemEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalEntityMakeSystemEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalEntity_MakeSystemEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalEntity_MakeSystemEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_statistics_read_all_global_stats<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_statistics_read_all_global_stats(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadAllGlobalStats", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadAllGlobalStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadAllGlobalStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_statistics_read_global_stats_subset<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_statistics_read_global_stats_subset(args.global_stats, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsSubset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsSubset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsSubset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_statistics_read_global_stats_for_category<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_statistics_read_global_stats_for_category(args.category, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsForCategory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsForCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ReadGlobalStatsForCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_statistics_increment_global_stats<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_statistics_increment_global_stats(args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalStatistics_IncrementGlobalStats", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalStatistics_IncrementGlobalStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalStatistics_IncrementGlobalStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_global_statistics_process_statistics<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGlobalStatisticsProcessStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_global_statistics_process_statistics(args.statistics_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("GlobalStatistics_ProcessStatistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGlobalStatisticsProcessStatisticsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ProcessStatistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("GlobalStatistics_ProcessStatistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_accept_group_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupAcceptGroupInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_accept_group_invitation(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_AcceptGroupInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupAcceptGroupInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_AcceptGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_AcceptGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_add_group_member<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupAddGroupMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_add_group_member(args.group_id, args.profile_id, args.role, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_AddGroupMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupAddGroupMemberResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_AddGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_AddGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_approve_group_join_request<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupApproveGroupJoinRequestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_approve_group_join_request(args.group_id, args.profile_id, args.role, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ApproveGroupJoinRequest", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupApproveGroupJoinRequestResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ApproveGroupJoinRequest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ApproveGroupJoinRequest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_auto_join_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupAutoJoinGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_auto_join_group(args.group_type, args.auto_join_strategy, args.data_query_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_AutoJoinGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupAutoJoinGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_AutoJoinGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_AutoJoinGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_cancel_group_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupCancelGroupInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_cancel_group_invitation(args.group_id, args.profile_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_CancelGroupInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupCancelGroupInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_CancelGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_CancelGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_create_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupCreateGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_create_group(args.name, args.group_type, args.is_open_group, args.acl, args.json_data, args.json_owner_attributes, args.json_default_member_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_CreateGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupCreateGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_CreateGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_CreateGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_create_group_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupCreateGroupEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_create_group_entity(args.group_id, args.entity_type, args.is_owned_by_group_member, args.acl, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_CreateGroupEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupCreateGroupEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_CreateGroupEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_CreateGroupEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_delete_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupDeleteGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_delete_group(args.group_id, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_DeleteGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupDeleteGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_DeleteGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_DeleteGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_delete_group_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupDeleteGroupEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_delete_group_entity(args.group_id, args.entity_id, args.version, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_DeleteGroupEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupDeleteGroupEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_DeleteGroupEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_DeleteGroupEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_get_my_groups<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupGetMyGroupsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_get_my_groups(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_GetMyGroups", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupGetMyGroupsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_GetMyGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_GetMyGroups", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_increment_group_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupIncrementGroupDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_increment_group_data(args.group_id, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_IncrementGroupData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupIncrementGroupDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_IncrementGroupData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_IncrementGroupData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_increment_group_entity_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupIncrementGroupEntityDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_increment_group_entity_data(args.group_id, args.entity_id, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_IncrementGroupEntityData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupIncrementGroupEntityDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_IncrementGroupEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_IncrementGroupEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_invite_group_member<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupInviteGroupMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_invite_group_member(args.group_id, args.profile_id, args.role, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_InviteGroupMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupInviteGroupMemberResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_InviteGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_InviteGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_join_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupJoinGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_join_group(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_JoinGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupJoinGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_JoinGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_JoinGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_leave_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupLeaveGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_leave_group(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_LeaveGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupLeaveGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_LeaveGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_LeaveGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_list_groups_page<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupListGroupsPageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_list_groups_page(args.json_context, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ListGroupsPage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupListGroupsPageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ListGroupsPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ListGroupsPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_list_groups_page_by_offset<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupListGroupsPageByOffsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_list_groups_page_by_offset(args.context, args.page_offset, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ListGroupsPageByOffset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupListGroupsPageByOffsetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ListGroupsPageByOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ListGroupsPageByOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_list_groups_with_member<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupListGroupsWithMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_list_groups_with_member(args.profile_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ListGroupsWithMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupListGroupsWithMemberResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ListGroupsWithMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ListGroupsWithMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_read_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupReadGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_read_group(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ReadGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupReadGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ReadGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ReadGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_read_group_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupReadGroupDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_read_group_data(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ReadGroupData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupReadGroupDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ReadGroupData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ReadGroupData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_read_group_entities_page<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupReadGroupEntitiesPageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_read_group_entities_page(args.json_context, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupReadGroupEntitiesPageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_read_group_entities_page_by_offset<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_read_group_entities_page_by_offset(args.encoded_context, args.page_offset, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPageByOffset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPageByOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ReadGroupEntitiesPageByOffset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_read_group_entity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupReadGroupEntityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_read_group_entity(args.group_id, args.entity_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ReadGroupEntity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupReadGroupEntityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ReadGroupEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ReadGroupEntity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_read_group_members<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupReadGroupMembersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_read_group_members(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_ReadGroupMembers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupReadGroupMembersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_ReadGroupMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_ReadGroupMembers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_reject_group_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupRejectGroupInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_reject_group_invitation(args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_RejectGroupInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupRejectGroupInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_RejectGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_RejectGroupInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_reject_group_join_request<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupRejectGroupJoinRequestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_reject_group_join_request(args.group_id, args.profile_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_RejectGroupJoinRequest", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupRejectGroupJoinRequestResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_RejectGroupJoinRequest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_RejectGroupJoinRequest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_remove_group_member<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupRemoveGroupMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_remove_group_member(args.group_id, args.profile_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_RemoveGroupMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupRemoveGroupMemberResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_RemoveGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_RemoveGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_update_group_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupUpdateGroupDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_update_group_data(args.group_id, args.version, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupUpdateGroupDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_update_group_entity_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupUpdateGroupEntityDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_update_group_entity_data(args.group_id, args.entity_id, args.version, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupEntityData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupUpdateGroupEntityDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupEntityData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_update_group_member<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupUpdateGroupMemberArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_update_group_member(args.group_id, args.profile_id, args.role, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupMember", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupUpdateGroupMemberResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupMember", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_group_update_group_name<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceGroupUpdateGroupNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_group_update_group_name(args.group_id, args.name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Group_UpdateGroupName", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceGroupUpdateGroupNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Group_UpdateGroupName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_attach_email_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityAttachEmailIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_attach_email_identity(args.email, args.password, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_AttachEmailIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityAttachEmailIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_AttachEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_AttachEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_merge_email_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityMergeEmailIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_merge_email_identity(args.email, args.password, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_MergeEmailIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityMergeEmailIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_MergeEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_MergeEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_detach_email_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityDetachEmailIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_detach_email_identity(args.email, args.continue_anon, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_DetachEmailIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityDetachEmailIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_DetachEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_DetachEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_attach_universal_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityAttachUniversalIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_attach_universal_identity(args.user_id, args.password, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_AttachUniversalIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityAttachUniversalIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_AttachUniversalIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_AttachUniversalIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_merge_universal_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityMergeUniversalIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_merge_universal_identity(args.user_id, args.password, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_MergeUniversalIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityMergeUniversalIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_MergeUniversalIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_MergeUniversalIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_detach_universal_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityDetachUniversalIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_detach_universal_identity(args.user_id, args.continue_anon, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_DetachUniversalIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityDetachUniversalIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_DetachUniversalIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_DetachUniversalIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_switch_to_child_profile<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentitySwitchToChildProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_switch_to_child_profile(args.child_profile_id, args.child_app_id, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_SwitchToChildProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentitySwitchToChildProfileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_SwitchToChildProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_SwitchToChildProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_switch_to_singleton_child_profile<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_switch_to_singleton_child_profile(args.child_app_id, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_SwitchToSingletonChildProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentitySwitchToSingletonChildProfileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_SwitchToSingletonChildProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_SwitchToSingletonChildProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_attach_parent_with_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityAttachParentWithIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_attach_parent_with_identity(args.external_id, args.authentication_token, args.authentication_type, args.external_auth_name, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_AttachParentWithIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityAttachParentWithIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_AttachParentWithIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_AttachParentWithIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_switch_to_parent_profile<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentitySwitchToParentProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_switch_to_parent_profile(args.parent_level_name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_SwitchToParentProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentitySwitchToParentProfileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_SwitchToParentProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_SwitchToParentProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_detach_parent<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityDetachParentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_detach_parent(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_DetachParent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityDetachParentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_DetachParent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_DetachParent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_get_child_profiles<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityGetChildProfilesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_get_child_profiles(args.include_summary_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_GetChildProfiles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityGetChildProfilesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_GetChildProfiles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_GetChildProfiles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_get_identities<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityGetIdentitiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_get_identities(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_GetIdentities", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityGetIdentitiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_GetIdentities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_GetIdentities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_get_expired_identities<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityGetExpiredIdentitiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_get_expired_identities(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_GetExpiredIdentities", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityGetExpiredIdentitiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_GetExpiredIdentities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_GetExpiredIdentities", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_refresh_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityRefreshIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_refresh_identity(args.external_id, args.authentication_token, args.authentication_type, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_RefreshIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityRefreshIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_RefreshIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_RefreshIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_change_email_identity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityChangeEmailIdentityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_change_email_identity(args.old_email_address, args.password, args.new_email_address, args.update_contact_email, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_ChangeEmailIdentity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityChangeEmailIdentityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_ChangeEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_ChangeEmailIdentity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_attach_peer_profile<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityAttachPeerProfileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_attach_peer_profile(args.peer, args.external_id, args.authentication_token, args.authentication_type, args.external_auth_name, args.force_create, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_AttachPeerProfile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityAttachPeerProfileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_AttachPeerProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_AttachPeerProfile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_detach_peer<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityDetachPeerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_detach_peer(args.peer, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_DetachPeer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityDetachPeerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_DetachPeer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_DetachPeer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_identity_get_peer_profiles<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceIdentityGetPeerProfilesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_identity_get_peer_profiles(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Identity_GetPeerProfiles", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceIdentityGetPeerProfilesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Identity_GetPeerProfiles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Identity_GetPeerProfiles", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mail_send_basic_email<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMailSendBasicEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mail_send_basic_email(args.profile_id, args.subject, args.body, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Mail_SendBasicEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMailSendBasicEmailResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Mail_SendBasicEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Mail_SendBasicEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mail_send_advanced_email<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMailSendAdvancedEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mail_send_advanced_email(args.profile_id, args.json_service_params, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMailSendAdvancedEmailResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_mail_send_advanced_email_by_address<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMailSendAdvancedEmailByAddressArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_mail_send_advanced_email_by_address(args.email_address, args.json_service_params, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmailByAddress", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMailSendAdvancedEmailByAddressResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmailByAddress", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Mail_SendAdvancedEmailByAddress", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_read<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingReadArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_read(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_Read", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingReadResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_Read", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_Read", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_set_player_rating<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingSetPlayerRatingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_set_player_rating(args.player_rating, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_SetPlayerRating", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingSetPlayerRatingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_SetPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_SetPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_reset_player_rating<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingResetPlayerRatingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_reset_player_rating(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_ResetPlayerRating", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingResetPlayerRatingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_ResetPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_ResetPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_increment_player_rating<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingIncrementPlayerRatingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_increment_player_rating(args.increment, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_IncrementPlayerRating", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingIncrementPlayerRatingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_IncrementPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_IncrementPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_decrement_player_rating<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingDecrementPlayerRatingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_decrement_player_rating(args.decrement, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_DecrementPlayerRating", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingDecrementPlayerRatingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_DecrementPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_DecrementPlayerRating", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_turn_shield_on<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingTurnShieldOnArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_turn_shield_on(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOn", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingTurnShieldOnResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOn", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_turn_shield_on_for<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingTurnShieldOnForArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_turn_shield_on_for(args.minutes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOnFor", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingTurnShieldOnForResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOnFor", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOnFor", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_turn_shield_off<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingTurnShieldOffArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_turn_shield_off(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOff", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingTurnShieldOffResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOff", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_TurnShieldOff", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_increment_shield_on_for<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingIncrementShieldOnForArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_increment_shield_on_for(args.minutes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_IncrementShieldOnFor", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingIncrementShieldOnForResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_IncrementShieldOnFor", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_IncrementShieldOnFor", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_get_shield_expiry<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingGetShieldExpiryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_get_shield_expiry(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_GetShieldExpiry", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingGetShieldExpiryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_GetShieldExpiry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_GetShieldExpiry", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_find_players<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingFindPlayersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_find_players(args.range_delta, args.num_matches, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingFindPlayersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_find_players_with_attributes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_find_players_with_attributes(args.range_delta, args.num_matches, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingFindPlayersWithAttributesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_find_players_using_filter<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_find_players_using_filter(args.range_delta, args.num_matches, args.json_extra_parms, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersUsingFilter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingFindPlayersUsingFilterResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersUsingFilter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersUsingFilter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_find_players_with_attributes_using_filter<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_find_players_with_attributes_using_filter(args.range_delta, args.num_matches, args.json_attributes, args.json_extra_parms, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributesUsingFilter", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributesUsingFilter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_FindPlayersWithAttributesUsingFilter", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_enable_match_making<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingEnableMatchMakingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_enable_match_making(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_EnableMatchMaking", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingEnableMatchMakingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_EnableMatchMaking", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_EnableMatchMaking", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_match_making_disable_match_making<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceMatchMakingDisableMatchMakingArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_match_making_disable_match_making(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("MatchMaking_DisableMatchMaking", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceMatchMakingDisableMatchMakingResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("MatchMaking_DisableMatchMaking", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("MatchMaking_DisableMatchMaking", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_one_way_match_start_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceOneWayMatchStartMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_one_way_match_start_match(args.other_player_id, args.range_delta, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("OneWayMatch_StartMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceOneWayMatchStartMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("OneWayMatch_StartMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("OneWayMatch_StartMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_one_way_match_cancel_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceOneWayMatchCancelMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_one_way_match_cancel_match(args.playback_stream_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("OneWayMatch_CancelMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceOneWayMatchCancelMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("OneWayMatch_CancelMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("OneWayMatch_CancelMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_one_way_match_complete_match<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceOneWayMatchCompleteMatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_one_way_match_complete_match(args.playback_stream_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("OneWayMatch_CompleteMatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceOneWayMatchCompleteMatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("OneWayMatch_CompleteMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("OneWayMatch_CompleteMatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_start_stream<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamStartStreamArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_start_stream(args.target_player_id, args.include_shared_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_StartStream", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamStartStreamResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_StartStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_StartStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_read_stream<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamReadStreamArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_read_stream(args.playback_stream_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_ReadStream", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamReadStreamResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_ReadStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_ReadStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_end_stream<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamEndStreamArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_end_stream(args.playback_stream_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_EndStream", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamEndStreamResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_EndStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_EndStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_delete_stream<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamDeleteStreamArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_delete_stream(args.playback_stream_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_DeleteStream", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamDeleteStreamResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_DeleteStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_DeleteStream", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_add_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamAddEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_add_event(args.playback_stream_id, args.event_data, args.summary, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_AddEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamAddEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_AddEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_AddEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_get_recent_streams_for_initiating_player<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_get_recent_streams_for_initiating_player(args.initiating_player_id, args.max_num_streams, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForInitiatingPlayer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForInitiatingPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForInitiatingPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_playback_stream_get_recent_streams_for_target_player<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_playback_stream_get_recent_streams_for_target_player(args.target_player_id, args.max_num_streams, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForTargetPlayer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForTargetPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlaybackStream_GetRecentStreamsForTargetPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_read_user_state<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateReadUserStateArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_read_user_state(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_ReadUserState", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateReadUserStateResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_ReadUserState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_ReadUserState", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_delete_user<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateDeleteUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_delete_user(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_DeleteUser", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateDeleteUserResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_DeleteUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_DeleteUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_reset_user<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateResetUserArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_reset_user(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_ResetUser", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateResetUserResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_ResetUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_ResetUser", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_logout<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateLogoutArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_logout(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_Logout", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateLogoutResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_Logout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_Logout", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_update_user_name<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateUpdateUserNameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_update_user_name(args.user_name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserName", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateUpdateUserNameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserName", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_update_summary_friend_data<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_update_summary_friend_data(args.json_summary_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateSummaryFriendData", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateUpdateSummaryFriendDataResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateSummaryFriendData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateSummaryFriendData", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_get_attributes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateGetAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_get_attributes(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_GetAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateGetAttributesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_GetAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_GetAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_update_attributes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateUpdateAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_update_attributes(args.json_attributes, args.wipe_existing, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateUpdateAttributesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_remove_attributes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateRemoveAttributesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_remove_attributes(args.attribute_names, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_RemoveAttributes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateRemoveAttributesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_RemoveAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_RemoveAttributes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_update_user_picture_url<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateUpdateUserPictureUrlArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_update_user_picture_url(args.picture_url, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserPictureUrl", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateUpdateUserPictureUrlResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserPictureUrl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateUserPictureUrl", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_state_update_contact_email<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStateUpdateContactEmailArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_state_update_contact_email(args.contact_email, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerState_UpdateContactEmail", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStateUpdateContactEmailResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateContactEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerState_UpdateContactEmail", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_read_all_user_stats<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsReadAllUserStatsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_read_all_user_stats(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadAllUserStats", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsReadAllUserStatsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadAllUserStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadAllUserStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_read_user_stats_subset<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_read_user_stats_subset(args.player_stats, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsSubset", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsSubset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsSubset", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_read_user_stats_for_category<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_read_user_stats_for_category(args.category, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsForCategory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsForCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ReadUserStatsForCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_reset_all_user_stats<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsResetAllUserStatsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_reset_all_user_stats(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ResetAllUserStats", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsResetAllUserStatsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ResetAllUserStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ResetAllUserStats", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_increment_user_stats_s_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_increment_user_stats_s_s_f_o(args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_SSFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_SSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_SSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_increment_user_stats_d_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_increment_user_stats_d_s_f_o(args.dict_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_DSFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_DSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementUserStats_DSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_process_statistics<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsProcessStatisticsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_process_statistics(args.statistics_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_ProcessStatistics", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsProcessStatisticsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ProcessStatistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_ProcessStatistics", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_get_next_experience_level<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_get_next_experience_level(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_GetNextExperienceLevel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_GetNextExperienceLevel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_GetNextExperienceLevel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_increment_experience_points<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_increment_experience_points(args.xp_value, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementExperiencePoints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementExperiencePoints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_IncrementExperiencePoints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_set_experience_points<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsSetExperiencePointsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_set_experience_points(args.xp_value, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatistics_SetExperiencePoints", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsSetExperiencePointsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatistics_SetExperiencePoints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatistics_SetExperiencePoints", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_event_trigger_stats_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_event_trigger_stats_event(args.event_name, args.event_multiplier, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_player_statistics_event_trigger_stats_events<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_player_statistics_event_trigger_stats_events(args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvents", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvents", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvents", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_product_get_currency<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProductGetCurrencyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_product_get_currency(args.currency_type, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Product_GetCurrency", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProductGetCurrencyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Product_GetCurrency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Product_GetCurrency", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_product_get_sales_inventory<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProductGetSalesInventoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_product_get_sales_inventory(args.platform, args.user_currency, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Product_GetSalesInventory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProductGetSalesInventoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Product_GetSalesInventory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Product_GetSalesInventory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_product_get_sales_inventory_by_category<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProductGetSalesInventoryByCategoryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_product_get_sales_inventory_by_category(args.platform, args.user_currency, args.category, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Product_GetSalesInventoryByCategory", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProductGetSalesInventoryByCategoryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Product_GetSalesInventoryByCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Product_GetSalesInventoryByCategory", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_product_verify_microsoft_receipt<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProductVerifyMicrosoftReceiptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_product_verify_microsoft_receipt(args.receipt, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Product_VerifyMicrosoftReceipt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProductVerifyMicrosoftReceiptResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Product_VerifyMicrosoftReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Product_VerifyMicrosoftReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_product_get_eligible_promotions<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProductGetEligiblePromotionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_product_get_eligible_promotions(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Product_GetEligiblePromotions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProductGetEligiblePromotionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Product_GetEligiblePromotions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Product_GetEligiblePromotions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_product_verify_itunes_receipt<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProductVerifyItunesReceiptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_product_verify_itunes_receipt(args.base64_enc_receipt_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Product_VerifyItunesReceipt", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProductVerifyItunesReceiptResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Product_VerifyItunesReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Product_VerifyItunesReceipt", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_profanity_profanity_check<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProfanityProfanityCheckArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_profanity_profanity_check(args.text, args.languages, args.flag_email, args.flag_phone, args.flag_urls, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Profanity_ProfanityCheck", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProfanityProfanityCheckResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Profanity_ProfanityCheck", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Profanity_ProfanityCheck", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_profanity_profanity_replace_text<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProfanityProfanityReplaceTextArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_profanity_profanity_replace_text(args.text, args.replace_symbol, args.languages, args.flag_email, args.flag_phone, args.flag_urls, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Profanity_ProfanityReplaceText", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProfanityProfanityReplaceTextResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Profanity_ProfanityReplaceText", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Profanity_ProfanityReplaceText", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_profanity_profanity_identify_bad_words<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_profanity_profanity_identify_bad_words(args.text, args.languages, args.flag_email, args.flag_phone, args.flag_urls, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Profanity_ProfanityIdentifyBadWords", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceProfanityProfanityIdentifyBadWordsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Profanity_ProfanityIdentifyBadWords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Profanity_ProfanityIdentifyBadWords", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_deregister_all_push_notification_device_tokens<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_deregister_all_push_notification_device_tokens(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_DeregisterAllPushNotificationDeviceTokens", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_DeregisterAllPushNotificationDeviceTokens", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_DeregisterAllPushNotificationDeviceTokens", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_deregister_push_notification_device_token<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_deregister_push_notification_device_token(args.platform, args.token, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_DeregisterPushNotificationDeviceToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_DeregisterPushNotificationDeviceToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_DeregisterPushNotificationDeviceToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_register_push_notification_device_token<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_register_push_notification_device_token(args.platform, args.token, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_RegisterPushNotificationDeviceToken", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_RegisterPushNotificationDeviceToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_RegisterPushNotificationDeviceToken", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_simple_push_notification<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendSimplePushNotificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_simple_push_notification(args.to_profile_id, args.message, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendSimplePushNotification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendSimplePushNotificationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendSimplePushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendSimplePushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_rich_push_notification<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendRichPushNotificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_rich_push_notification(args.to_profile_id, args.notification_template_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendRichPushNotificationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_rich_push_notification_with_params<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_rich_push_notification_with_params(args.to_profile_id, args.notification_template_id, args.substitution_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotificationWithParams", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotificationWithParams", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendRichPushNotificationWithParams", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_templated_push_notification_to_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_templated_push_notification_to_group(args.group_id, args.notification_template_id, args.substitutions_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendTemplatedPushNotificationToGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendTemplatedPushNotificationToGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendTemplatedPushNotificationToGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_normalized_push_notification_to_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_normalized_push_notification_to_group(args.group_id, args.alert_content_json, args.custom_data_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationToGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationToGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationToGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_schedule_raw_push_notification_u_t_c<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_schedule_raw_push_notification_u_t_c(args.profile_id, args.fcm_content, args.ios_content, args.facebook_content, args.start_time, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationUTC", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_schedule_raw_push_notification_minutes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_schedule_raw_push_notification_minutes(args.profile_id, args.fcm_content, args.ios_content, args.facebook_content, args.minutes_from_now, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationMinutes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRawPushNotificationMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_raw_push_notification<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendRawPushNotificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_raw_push_notification(args.to_profile_id, args.fcm_content, args.ios_content, args.facebook_content, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendRawPushNotificationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_raw_push_notification_batch<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_raw_push_notification_batch(args.profile_ids, args.fcm_content, args.ios_content, args.facebook_content, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationBatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendRawPushNotificationBatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationBatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationBatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_raw_push_notification_to_group<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_raw_push_notification_to_group(args.group_id, args.fcm_content, args.ios_content, args.facebook_content, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationToGroup", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationToGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendRawPushNotificationToGroup", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_schedule_normalized_push_notification_u_t_c<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_schedule_normalized_push_notification_u_t_c(args.profile_id, args.alert_content_json, args.custom_data_json, args.start_time, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationUTC", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_schedule_normalized_push_notification_minutes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_schedule_normalized_push_notification_minutes(args.profile_id, args.alert_content_json, args.custom_data_json, args.minutes_from_now, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationMinutes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_schedule_rich_push_notification_u_t_c<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_schedule_rich_push_notification_u_t_c(args.profile_id, args.notification_template_id, args.substitutions_json, args.start_time, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationUTC", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_schedule_rich_push_notification_minutes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_schedule_rich_push_notification_minutes(args.profile_id, args.notification_template_id, args.substitutions_json, args.minutes_from_now, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationMinutes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_ScheduleRichPushNotificationMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_normalized_push_notification<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_normalized_push_notification(args.to_profile_id, args.alert_content_json, args.custom_data_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotification", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotification", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_push_notification_send_normalized_push_notification_batch<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_push_notification_send_normalized_push_notification_batch(args.profile_ids, args.alert_content_json, args.custom_data_json, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationBatch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationBatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("PushNotification_SendNormalizedPushNotificationBatch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_run_script<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptRunScriptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_run_script(args.script_name, args.json_script_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_RunScript", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptRunScriptResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_RunScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_RunScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_schedule_run_script_u_t_c<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptScheduleRunScriptUTCArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_schedule_run_script_u_t_c(args.script_name, args.json_script_data, args.start_date_in_u_t_c, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptUTC", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptScheduleRunScriptUTCResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptUTC", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_schedule_run_script_minutes<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptScheduleRunScriptMinutesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_schedule_run_script_minutes(args.script_name, args.json_script_data, args.minutes_from_now, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptMinutes", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptScheduleRunScriptMinutesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_ScheduleRunScriptMinutes", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_run_parent_script<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptRunParentScriptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_run_parent_script(args.script_name, args.json_script_data, args.parent_level, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_RunParentScript", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptRunParentScriptResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_RunParentScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_RunParentScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_cancel_scheduled_script<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptCancelScheduledScriptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_cancel_scheduled_script(args.job_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_CancelScheduledScript", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptCancelScheduledScriptResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_CancelScheduledScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_CancelScheduledScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_run_peer_script<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptRunPeerScriptArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_run_peer_script(args.script_name, args.json_script_data, args.peer, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_RunPeerScript", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptRunPeerScriptResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_RunPeerScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_RunPeerScript", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_script_run_peer_script_asynch<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceScriptRunPeerScriptAsynchArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_script_run_peer_script_asynch(args.script_name, args.json_script_data, args.peer, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Script_RunPeerScriptAsynch", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceScriptRunPeerScriptAsynchResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Script_RunPeerScriptAsynch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Script_RunPeerScriptAsynch", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_social_leaderboard<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_social_leaderboard(args.leaderboard_id, args.replace_name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetSocialLeaderboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_multi_social_leaderboard<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_multi_social_leaderboard(args.leaderboard_ids, args.leaderboard_result_count, args.replace_name, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetMultiSocialLeaderboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetMultiSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetMultiSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_page<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_page(args.leaderboard_id, args.sort, args.start_index, args.end_index, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPage", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPage", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_page_by_version<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_page_by_version(args.leaderboard_id, args.sort, args.start_index, args.end_index, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPageByVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPageByVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPageByVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_view<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_view(args.leaderboard_id, args.sort, args.before_count, args.after_count, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardView", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardView", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardView", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_view_by_version<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_view_by_version(args.leaderboard_id, args.sort, args.before_count, args.after_count, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardViewByVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardViewByVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardViewByVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_versions<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_versions(args.leaderboard_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardVersions", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardVersions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardVersions", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_group_social_leaderboard<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_group_social_leaderboard(args.leaderboard_id, args.group_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGroupSocialLeaderboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGroupSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGroupSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_post_score_to_leaderboard<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_post_score_to_leaderboard(args.leaderboard_id, args.score, args.json_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToLeaderboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_remove_player_score<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_remove_player_score(args.leaderboard_id, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_RemovePlayerScore", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_RemovePlayerScore", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_RemovePlayerScore", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_post_score_to_dynamic_leaderboard<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_post_score_to_dynamic_leaderboard(args.leaderboard_id, args.score, args.json_data, args.leaderboard_type, args.rotation_type, args.rotation_reset, args.retained_count, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_post_score_to_dynamic_leaderboard_days<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_post_score_to_dynamic_leaderboard_days(args.leaderboard_id, args.score, args.json_data, args.leaderboard_type, args.rotation_reset, args.retained_count, args.num_days_to_rotate, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboardDays", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboardDays", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboardDays", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_players_social_leaderboard<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_players_social_leaderboard(args.leaderboard_id, args.profile_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayersSocialLeaderboard", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayersSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayersSocialLeaderboard", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_list_leaderboards<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardListLeaderboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_list_leaderboards(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_ListLeaderboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardListLeaderboardsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_ListLeaderboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_ListLeaderboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_entry_count<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_entry_count(args.leaderboard_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCount", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCount", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_global_leaderboard_entry_count_by_version<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_global_leaderboard_entry_count_by_version(args.leaderboard_id, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_player_score<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_player_score(args.leaderboard_id, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScore", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetPlayerScoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScore", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScore", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_leaderboard_get_player_scores_from_leaderboards<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_leaderboard_get_player_scores_from_leaderboards(args.leaderboard_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScoresFromLeaderboards", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScoresFromLeaderboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialLeaderboard_GetPlayerScoresFromLeaderboards", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_time_read_server_time<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTimeReadServerTimeArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_time_read_server_time(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Time_ReadServerTime", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTimeReadServerTimeResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Time_ReadServerTime", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Time_ReadServerTime", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_claim_tournament_reward<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentClaimTournamentRewardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_claim_tournament_reward(args.leaderboard_id, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_ClaimTournamentReward", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentClaimTournamentRewardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_ClaimTournamentReward", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_ClaimTournamentReward", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_get_tournament_status<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentGetTournamentStatusArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_get_tournament_status(args.leaderboard_id, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_GetTournamentStatus", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentGetTournamentStatusResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_GetTournamentStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_GetTournamentStatus", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_join_tournament<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentJoinTournamentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_join_tournament(args.leaderboard_id, args.tournament_code, args.initial_score, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_JoinTournament", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentJoinTournamentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_JoinTournament", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_JoinTournament", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_leave_tournament<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentLeaveTournamentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_leave_tournament(args.leaderboard_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_LeaveTournament", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentLeaveTournamentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_LeaveTournament", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_LeaveTournament", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_post_tournament_score<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentPostTournamentScoreArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_post_tournament_score(args.leaderboard_id, args.score, args.json_data, args.round_started_time, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScore", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentPostTournamentScoreResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScore", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScore", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_post_tournament_score_with_results<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_post_tournament_score_with_results(args.leaderboard_id, args.score, args.json_data, args.round_started_time, args.sort, args.before_count, args.after_count, args.initial_score, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScoreWithResults", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentPostTournamentScoreWithResultsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScoreWithResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_PostTournamentScoreWithResults", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_view_current_reward<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentViewCurrentRewardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_view_current_reward(args.leaderboard_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_ViewCurrentReward", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentViewCurrentRewardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_ViewCurrentReward", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_ViewCurrentReward", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_tournament_view_reward<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTournamentViewRewardArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_tournament_view_reward(args.leaderboard_id, args.version_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Tournament_ViewReward", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTournamentViewRewardResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Tournament_ViewReward", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Tournament_ViewReward", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_create_lobby<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyCreateLobbyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_create_lobby(args.lobby_type, args.max_slots, args.is_open, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_CreateLobby", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyCreateLobbyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_CreateLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_CreateLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_open_lobby<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyOpenLobbyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_open_lobby(args.lobby_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_OpenLobby", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyOpenLobbyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_OpenLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_OpenLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_close_lobby<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyCloseLobbyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_close_lobby(args.lobby_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_CloseLobby", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyCloseLobbyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_CloseLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_CloseLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_find_lobbies<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyFindLobbiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_find_lobbies(args.free_slots, args.max_results, args.json_attributes, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_FindLobbies", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyFindLobbiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_FindLobbies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_FindLobbies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_find_friends_lobbies<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyFindFriendsLobbiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_find_friends_lobbies(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_FindFriendsLobbies", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyFindFriendsLobbiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_FindFriendsLobbies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_FindFriendsLobbies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_join_lobby<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyJoinLobbyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_join_lobby(args.lobby_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_JoinLobby", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyJoinLobbyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_JoinLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_JoinLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_leave_lobby<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyLeaveLobbyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_leave_lobby(args.lobby_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_LeaveLobby", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyLeaveLobbyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_LeaveLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_LeaveLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_destroy_lobby<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyDestroyLobbyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_destroy_lobby(args.lobby_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_DestroyLobby", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyDestroyLobbyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_DestroyLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_DestroyLobby", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_start_game<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyStartGameArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_start_game(args.lobby_id, args.connection_string, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_StartGame", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyStartGameResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_StartGame", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_StartGame", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_lobby_get_my_lobbies<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceLobbyGetMyLobbiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_lobby_get_my_lobbies(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Lobby_GetMyLobbies", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceLobbyGetMyLobbiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Lobby_GetMyLobbies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Lobby_GetMyLobbies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_accept_party_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyAcceptPartyInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_accept_party_invitation(args.party_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_AcceptPartyInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyAcceptPartyInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_AcceptPartyInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_AcceptPartyInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_get_party_info<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyGetPartyInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_get_party_info(args.party_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_GetPartyInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyGetPartyInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_GetPartyInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_GetPartyInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_join_party<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyJoinPartyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_join_party(args.party_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_JoinParty", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyJoinPartyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_JoinParty", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_JoinParty", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_leave_party<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyLeavePartyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_leave_party(args.party_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_LeaveParty", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyLeavePartyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_LeaveParty", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_LeaveParty", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_reject_party_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyRejectPartyInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_reject_party_invitation(args.party_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_RejectPartyInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyRejectPartyInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_RejectPartyInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_RejectPartyInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_send_party_invitation<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartySendPartyInvitationArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_send_party_invitation(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_SendPartyInvitation", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartySendPartyInvitationResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_SendPartyInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_SendPartyInvitation", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_list_party_invitations<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyListPartyInvitationsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_list_party_invitations(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_ListPartyInvitations", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyListPartyInvitationsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_ListPartyInvitations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_ListPartyInvitations", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_get_friends_parties<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyGetFriendsPartiesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_get_friends_parties(args.max_results, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_GetFriendsParties", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyGetFriendsPartiesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_GetFriendsParties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_GetFriendsParties", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_party_get_my_party<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePartyGetMyPartyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_party_get_my_party(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Party_GetMyParty", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePartyGetMyPartyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Party_GetMyParty", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Party_GetMyParty", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_patch_get_game_manifest<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServicePatchGetGameManifestArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_patch_get_game_manifest(args.game_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Patch_GetGameManifest", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServicePatchGetGameManifestResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Patch_GetGameManifest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Patch_GetGameManifest", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_add_to_cart_s_i_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingAddToCartSISFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_add_to_cart_s_i_s_f_o(args.product_id, args.quantity, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_AddToCart_SISFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingAddToCartSISFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_AddToCart_SISFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_AddToCart_SISFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_add_to_cart_i_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingAddToCartISFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_add_to_cart_i_s_f_o(args.product_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_AddToCart_ISFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingAddToCartISFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_AddToCart_ISFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_AddToCart_ISFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_empty_cart<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingEmptyCartArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_empty_cart(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_EmptyCart", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingEmptyCartResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_EmptyCart", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_EmptyCart", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_cart<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetCartArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_cart(args.include_details, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetCart", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetCartResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetCart", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetCart", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_remove_from_cart<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingRemoveFromCartArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_remove_from_cart(args.product_id, args.quantity, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_RemoveFromCart", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingRemoveFromCartResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_RemoveFromCart", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_RemoveFromCart", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_add_to_wishlist<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingAddToWishlistArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_add_to_wishlist(args.product_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_AddToWishlist", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingAddToWishlistResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_AddToWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_AddToWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_empty_wishlist<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingEmptyWishlistArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_empty_wishlist(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_EmptyWishlist", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingEmptyWishlistResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_EmptyWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_EmptyWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_my_wishlist<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetMyWishlistArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_my_wishlist(args.include_details, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetMyWishlist", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetMyWishlistResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetMyWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetMyWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_wishlist<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetWishlistArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_wishlist(args.player_id, args.include_details, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetWishlist", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetWishlistResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetWishlist", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_remove_from_wishlist_s_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_remove_from_wishlist_s_s_f_o(args.product_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_SSFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingRemoveFromWishlistSSFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_SSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_SSFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_remove_from_wishlist_i_s_f_o<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingRemoveFromWishlistISFOArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_remove_from_wishlist_i_s_f_o(args.product_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_ISFO", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingRemoveFromWishlistISFOResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_ISFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_RemoveFromWishlist_ISFO", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_user_reviews<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetUserReviewsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_user_reviews(args.product_id, args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetUserReviews", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetUserReviewsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetUserReviews", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetUserReviews", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_submit_user_review<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingSubmitUserReviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_submit_user_review(args.product_id, args.review_text, args.positive, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_SubmitUserReview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingSubmitUserReviewResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_SubmitUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_SubmitUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_like_user_review<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingLikeUserReviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_like_user_review(args.product_id, args.review_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_LikeUserReview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingLikeUserReviewResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_LikeUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_LikeUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_unlike_user_review<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingUnlikeUserReviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_unlike_user_review(args.product_id, args.review_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_UnlikeUserReview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingUnlikeUserReviewResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_UnlikeUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_UnlikeUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_funny_user_review<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingFunnyUserReviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_funny_user_review(args.product_id, args.review_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_FunnyUserReview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingFunnyUserReviewResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_FunnyUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_FunnyUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_unfunny_user_review<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingUnfunnyUserReviewArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_unfunny_user_review(args.product_id, args.review_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_UnfunnyUserReview", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingUnfunnyUserReviewResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_UnfunnyUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_UnfunnyUserReview", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_recently_created_products<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_recently_created_products(args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyCreatedProducts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetRecentlyCreatedProductsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyCreatedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyCreatedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_recently_updated_products<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_recently_updated_products(args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyUpdatedProducts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyUpdatedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetRecentlyUpdatedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_featured_products<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetFeaturedProductsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_featured_products(args.include_details, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetFeaturedProducts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetFeaturedProductsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetFeaturedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetFeaturedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_popular_products<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetPopularProductsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_popular_products(args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetPopularProducts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetPopularProductsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetPopularProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetPopularProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_special_offers<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetSpecialOffersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_special_offers(args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetSpecialOffers", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetSpecialOffersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetSpecialOffers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetSpecialOffers", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_my_library<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetMyLibraryArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_my_library(args.include_details, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetMyLibrary", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetMyLibraryResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetMyLibrary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetMyLibrary", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_popular_tags<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetPopularTagsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_popular_tags(args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetPopularTags", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetPopularTagsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetPopularTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetPopularTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_products_by_tag<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetProductsByTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_products_by_tag(args.tag, args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetProductsByTagResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_products_by_tags<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetProductsByTagsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_products_by_tags(args.tags, args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTags", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetProductsByTagsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetProductsByTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_recommended_products<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetRecommendedProductsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_recommended_products(args.count, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetRecommendedProducts", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetRecommendedProductsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetRecommendedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetRecommendedProducts", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_my_orders<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetMyOrdersArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_my_orders(args.include_completed, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetMyOrders", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetMyOrdersResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetMyOrders", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetMyOrders", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_product<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetProductArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_product(args.product_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetProduct", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetProductResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetProduct", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_user_tags<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetUserTagsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_user_tags(args.product_id, args.page, args.page_size, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetUserTags", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetUserTagsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetUserTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetUserTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_my_user_tags<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetMyUserTagsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_my_user_tags(args.product_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetMyUserTags", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetMyUserTagsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetMyUserTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetMyUserTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_submit_user_tag<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingSubmitUserTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_submit_user_tag(args.product_id, args.tag, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingSubmitUserTagResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_submit_user_tags<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingSubmitUserTagsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_submit_user_tags(args.product_id, args.tags, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTags", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingSubmitUserTagsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_SubmitUserTags", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_remove_user_tag<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingRemoveUserTagArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_remove_user_tag(args.product_id, args.tag, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_RemoveUserTag", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingRemoveUserTagResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_RemoveUserTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_RemoveUserTag", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_shopping_get_build_details<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceShoppingGetBuildDetailsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_shopping_get_build_details(args.product_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Shopping_GetBuildDetails", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceShoppingGetBuildDetailsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Shopping_GetBuildDetails", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Shopping_GetBuildDetails", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_video<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareVideoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_video(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareVideo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareVideoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareVideo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareVideo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_screenshot<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareScreenshotArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_screenshot(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareScreenshot", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareScreenshotResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareScreenshot", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareScreenshot", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_achievement<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareAchievementArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_achievement(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareAchievement", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareAchievementResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareAchievement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareAchievement", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_app<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareAppArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_app(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareApp", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareAppResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareApp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareApp", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_channel<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareChannelArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_channel(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareChannel", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareChannelResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareChannel", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_link<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareLinkArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_link(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareLink", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareLinkResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareLink", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareLink", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_share_game_guide<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedShareGameGuideArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_share_game_guide(args.timestamp, args.resource, args.tagged, args.show, args.block, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ShareGameGuide", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedShareGameGuideResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareGameGuide", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ShareGameGuide", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_read_social_feed<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedReadSocialFeedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_read_social_feed(args.skip, args.limit, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadSocialFeed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedReadSocialFeedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadSocialFeed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadSocialFeed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_read_filtered_social_feed<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_read_filtered_social_feed(args.skip, args.limit, args.player_ids, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadFilteredSocialFeed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedReadFilteredSocialFeedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadFilteredSocialFeed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadFilteredSocialFeed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_read_friends_social_feed<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_read_friends_social_feed(args.skip, args.limit, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadFriendsSocialFeed", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedReadFriendsSocialFeedResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadFriendsSocialFeed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadFriendsSocialFeed", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_post_comment<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedPostCommentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_post_comment(args.timestamp, args.parent_id, args.content, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_PostComment", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedPostCommentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_PostComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_PostComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_post_comment_reply<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedPostCommentReplyArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_post_comment_reply(args.timestamp, args.parent_id, args.content, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_PostCommentReply", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedPostCommentReplyResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_PostCommentReply", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_PostCommentReply", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_read_comments<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedReadCommentsArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_read_comments(args.skip, args.limit, args.parent_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadComments", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedReadCommentsResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadComments", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadComments", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_read_comment_replies<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedReadCommentRepliesArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_read_comment_replies(args.skip, args.limit, args.parent_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_ReadCommentReplies", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedReadCommentRepliesResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadCommentReplies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_ReadCommentReplies", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_like_comment<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedLikeCommentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_like_comment(args.social_feed_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_LikeComment", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedLikeCommentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_LikeComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_LikeComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_like_activity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedLikeActivityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_like_activity(args.social_feed_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_LikeActivity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedLikeActivityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_LikeActivity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_LikeActivity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_unlike_comment<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedUnlikeCommentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_unlike_comment(args.social_feed_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeComment", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedUnlikeCommentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_unlike_activity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedUnlikeActivityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_unlike_activity(args.social_feed_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeActivity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedUnlikeActivityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeActivity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_UnlikeActivity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_set_feed_visibility<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedSetFeedVisibilityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_set_feed_visibility(args.visibility, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_SetFeedVisibility", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedSetFeedVisibilityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_SetFeedVisibility", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_SetFeedVisibility", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_block_player<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedBlockPlayerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_block_player(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_BlockPlayer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedBlockPlayerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_BlockPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_BlockPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_hide_player<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedHidePlayerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_hide_player(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_HidePlayer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedHidePlayerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_HidePlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_HidePlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_unblock_player<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedUnblockPlayerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_unblock_player(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_UnblockPlayer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedUnblockPlayerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_UnblockPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_UnblockPlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_unhide_player<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedUnhidePlayerArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_unhide_player(args.player_id, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_UnhidePlayer", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedUnhidePlayerResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_UnhidePlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_UnhidePlayer", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_get_activity<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedGetActivityArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_get_activity(args.social_feed_id, args.depth, args.skip, args.limit, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_GetActivity", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedGetActivityResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_GetActivity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_GetActivity", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_social_feed_get_comment<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceSocialFeedGetCommentArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_social_feed_get_comment(args.social_feed_id, args.depth, args.skip, args.limit, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("SocialFeed_GetComment", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceSocialFeedGetCommentResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("SocialFeed_GetComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("SocialFeed_GetComment", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_telemetry_start_telemetry_session<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTelemetryStartTelemetrySessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_telemetry_start_telemetry_session(args.timestamp, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetrySession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTelemetryStartTelemetrySessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetrySession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetrySession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_telemetry_end_telemetry_session<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTelemetryEndTelemetrySessionArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_telemetry_end_telemetry_session(args.telemetry_session_id, args.timestamp, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetrySession", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTelemetryEndTelemetrySessionResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetrySession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetrySession", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_telemetry_log_telemetry_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTelemetryLogTelemetryEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_telemetry_log_telemetry_event(args.telemetry_session_id, args.timestamp, args.event_type, args.participant_id, args.custom_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Telemetry_LogTelemetryEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTelemetryLogTelemetryEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Telemetry_LogTelemetryEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Telemetry_LogTelemetryEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_telemetry_start_telemetry_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTelemetryStartTelemetryEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_telemetry_start_telemetry_event(args.telemetry_session_id, args.timestamp, args.event_type, args.participant_id, args.custom_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetryEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTelemetryStartTelemetryEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetryEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Telemetry_StartTelemetryEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_telemetry_end_telemetry_event<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceTelemetryEndTelemetryEventArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_telemetry_end_telemetry_event(args.telemetry_session_id, args.timestamp, args.event_type, args.participant_id, args.custom_data, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetryEvent", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceTelemetryEndTelemetryEventResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetryEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Telemetry_EndTelemetryEvent", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_authentication_get_we_chat_q_r_page_u_r_l<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_authentication_get_we_chat_q_r_page_u_r_l(args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("Authentication_GetWeChatQRPageURL", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceAuthenticationGetWeChatQRPageURLResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("Authentication_GetWeChatQRPageURL", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("Authentication_GetWeChatQRPageURL", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_download_file<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileDownloadFileArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_download_file(args.cloud_path, args.cloud_filename, args.replace_if_exists, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_DownloadFile", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileDownloadFileResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_DownloadFile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_DownloadFile", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_get_download_info<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileGetDownloadInfoArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_get_download_info(args.cloud_path, args.cloud_filename, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_GetDownloadInfo", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileGetDownloadInfoResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_GetDownloadInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_GetDownloadInfo", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
  pub fn process_file_cancel_download<H: BrainCloudServiceSyncHandler>(handler: &H, incoming_sequence_number: i32, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let args = BrainCloudServiceFileCancelDownloadArgs::read_from_in_protocol(i_prot)?;
    match handler.handle_file_cancel_download(args.cloud_path, args.cloud_filename, args.client_index) {
      Ok(handler_return) => {
        let message_ident = TMessageIdentifier::new("File_CancelDownload", TMessageType::Reply, incoming_sequence_number);
        o_prot.write_message_begin(&message_ident)?;
        let ret = BrainCloudServiceFileCancelDownloadResult { result_value: Some(handler_return) };
        ret.write_to_out_protocol(o_prot)?;
        o_prot.write_message_end()?;
        o_prot.flush()
      },
      Err(e) => {
        match e {
          thrift::Error::Application(app_err) => {
            let message_ident = TMessageIdentifier::new("File_CancelDownload", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&app_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
          _ => {
            let ret_err = {
              ApplicationError::new(
                ApplicationErrorKind::Unknown,
                e.description()
              )
            };
            let message_ident = TMessageIdentifier::new("File_CancelDownload", TMessageType::Exception, incoming_sequence_number);
            o_prot.write_message_begin(&message_ident)?;
            thrift::Error::write_application_error_to_out_protocol(&ret_err, o_prot)?;
            o_prot.write_message_end()?;
            o_prot.flush()
          },
        }
      },
    }
  }
}

impl <H: BrainCloudServiceSyncHandler> TProcessor for BrainCloudServiceSyncProcessor<H> {
  fn process(&self, i_prot: &mut TInputProtocol, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let message_ident = i_prot.read_message_begin()?;
    let res = match &*message_ident.name {
      "AsyncMatch_CreateMatch" => {
        self.process_async_match_create_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_CreateMatchWithInitialTurn" => {
        self.process_async_match_create_match_with_initial_turn(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_SubmitTurn" => {
        self.process_async_match_submit_turn(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_UpdateMatchSummaryData" => {
        self.process_async_match_update_match_summary_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_CompleteMatch" => {
        self.process_async_match_complete_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_ReadMatch" => {
        self.process_async_match_read_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_ReadMatchHistory" => {
        self.process_async_match_read_match_history(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_FindMatches" => {
        self.process_async_match_find_matches(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_FindCompleteMatches" => {
        self.process_async_match_find_complete_matches(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_AbandonMatch" => {
        self.process_async_match_abandon_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "AsyncMatch_DeleteMatch" => {
        self.process_async_match_delete_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_GenerateAnonymousId" => {
        self.process_authentication_generate_anonymous_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_Initialize" => {
        self.process_authentication_initialize(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_ClearSavedProfileID" => {
        self.process_authentication_clear_saved_profile_i_d(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_AuthenticateAnonymous" => {
        self.process_authentication_authenticate_anonymous(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_AuthenticateEmailPassword" => {
        self.process_authentication_authenticate_email_password(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_AuthenticateUniversal" => {
        self.process_authentication_authenticate_universal(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_AuthenticateExternal" => {
        self.process_authentication_authenticate_external(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_AuthenticatePhone" => {
        self.process_authentication_authenticate_phone(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_AuthenticateWechat" => {
        self.process_authentication_authenticate_wechat(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_ResetEmailPassword" => {
        self.process_authentication_reset_email_password(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_RequestSmsCode" => {
        self.process_authentication_request_sms_code(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_CheckUsernameExists" => {
        self.process_authentication_check_username_exists(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_ChangeUniversalPassword" => {
        self.process_authentication_change_universal_password(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_GetSessionId" => {
        self.process_client_get_session_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_IsAuthenticated" => {
        self.process_client_is_authenticated(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_IsInitialized" => {
        self.process_client_is_initialized(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_Initialize_SSS" => {
        self.process_client_initialize_s_s_s(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_Initialize_SSSS" => {
        self.process_client_initialize_s_s_s_s(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_InitializeIdentity" => {
        self.process_client_initialize_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_Update" => {
        self.process_client_update(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_EnableLogging" => {
        self.process_client_enable_logging(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_ResetCommunication" => {
        self.process_client_reset_communication(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_SetPacketTimeouts" => {
        self.process_client_set_packet_timeouts(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_SetPacketTimeoutsToDefault" => {
        self.process_client_set_packet_timeouts_to_default(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_GetPacketTimeouts" => {
        self.process_client_get_packet_timeouts(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_SetAuthenticationPacketTimeout" => {
        self.process_client_set_authentication_packet_timeout(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_GetAuthenticationPacketTimeout" => {
        self.process_client_get_authentication_packet_timeout(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_GetUploadLowTransferRateTimeout" => {
        self.process_client_get_upload_low_transfer_rate_timeout(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_SetUploadLowTransferRateTimeout" => {
        self.process_client_set_upload_low_transfer_rate_timeout(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_GetUploadLowTransferRateThreshold" => {
        self.process_client_get_upload_low_transfer_rate_threshold(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_SetUploadLowTransferRateThreshold" => {
        self.process_client_set_upload_low_transfer_rate_threshold(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_EnableNetworkErrorMessageCaching" => {
        self.process_client_enable_network_error_message_caching(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_RetryCachedMessages" => {
        self.process_client_retry_cached_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_FlushCachedMessages" => {
        self.process_client_flush_cached_messages(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_InsertEndOfMessageBundleMarker" => {
        self.process_client_insert_end_of_message_bundle_marker(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_OverrideCountryCode" => {
        self.process_client_override_country_code(message_ident.sequence_number, i_prot, o_prot)
      },
      "Client_OverrideLanguageCode" => {
        self.process_client_override_language_code(message_ident.sequence_number, i_prot, o_prot)
      },
      "DataStream_CustomPageEvent" => {
        self.process_data_stream_custom_page_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "DataStream_CustomScreenEvent" => {
        self.process_data_stream_custom_screen_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "DataStream_CustomTrackEvent" => {
        self.process_data_stream_custom_track_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_CreateEntity" => {
        self.process_entity_create_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetEntitiesByType" => {
        self.process_entity_get_entities_by_type(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_UpdateEntity" => {
        self.process_entity_update_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_UpdateSharedEntity" => {
        self.process_entity_update_shared_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_DeleteEntity" => {
        self.process_entity_delete_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_UpdateSingleton" => {
        self.process_entity_update_singleton(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_DeleteSingleton" => {
        self.process_entity_delete_singleton(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetEntity" => {
        self.process_entity_get_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetSingleton" => {
        self.process_entity_get_singleton(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetSharedEntityForProfileId" => {
        self.process_entity_get_shared_entity_for_profile_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetSharedEntitiesForProfileId" => {
        self.process_entity_get_shared_entities_for_profile_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetList" => {
        self.process_entity_get_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetSharedEntitiesListForProfileId" => {
        self.process_entity_get_shared_entities_list_for_profile_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetListCount" => {
        self.process_entity_get_list_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetPage" => {
        self.process_entity_get_page(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_GetPageOffset" => {
        self.process_entity_get_page_offset(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_IncrementUserEntityData" => {
        self.process_entity_increment_user_entity_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Entity_IncrementSharedUserEntityData" => {
        self.process_entity_increment_shared_user_entity_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Event_SendEvent" => {
        self.process_event_send_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "Event_UpdateIncomingEventData" => {
        self.process_event_update_incoming_event_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Event_DeleteIncomingEvent" => {
        self.process_event_delete_incoming_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "Event_GetEvents" => {
        self.process_event_get_events(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_UploadFile" => {
        self.process_file_upload_file(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_CancelUpload" => {
        self.process_file_cancel_upload(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_GetUploadProgress" => {
        self.process_file_get_upload_progress(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_GetUploadBytesTransferred" => {
        self.process_file_get_upload_bytes_transferred(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_GetUploadTotalBytesToTransfer" => {
        self.process_file_get_upload_total_bytes_to_transfer(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_ListUserFiles_SFO" => {
        self.process_file_list_user_files_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_ListUserFiles_SNSFO" => {
        self.process_file_list_user_files_s_n_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_DeleteUserFile" => {
        self.process_file_delete_user_file(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_DeleteUserFiles" => {
        self.process_file_delete_user_files(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_GetCDNUrl" => {
        self.process_file_get_c_d_n_url(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_FindUserByUniversalId" => {
        self.process_friend_find_user_by_universal_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_ReadFriendEntity" => {
        self.process_friend_read_friend_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_ReadFriendsEntities" => {
        self.process_friend_read_friends_entities(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_ReadFriendUserState" => {
        self.process_friend_read_friend_user_state(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_GetSummaryDataForProfileId" => {
        self.process_friend_get_summary_data_for_profile_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_GetSummaryDataForProfileIds" => {
        self.process_friend_get_summary_data_for_profile_ids(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_GetSummaryDataForFriends" => {
        self.process_friend_get_summary_data_for_friends(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_GetSummaryDataForRecentlyMetPlayers" => {
        self.process_friend_get_summary_data_for_recently_met_players(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_FindUsersByExactName" => {
        self.process_friend_find_users_by_exact_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_FindUsersBySubstrName" => {
        self.process_friend_find_users_by_substr_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_ListFriends" => {
        self.process_friend_list_friends(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_AddFriends" => {
        self.process_friend_add_friends(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_RemoveFriends" => {
        self.process_friend_remove_friends(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_GetUsersOnlineStatus" => {
        self.process_friend_get_users_online_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_SendFriendInvitation" => {
        self.process_friend_send_friend_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_ListFriendInvitationsReceived" => {
        self.process_friend_list_friend_invitations_received(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_ListFriendInvitationsSent" => {
        self.process_friend_list_friend_invitations_sent(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_AcceptFriendInvitation" => {
        self.process_friend_accept_friend_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_RejectFriendInvitation" => {
        self.process_friend_reject_friend_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Friend_RemoveFriend" => {
        self.process_friend_remove_friend(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadAllGamification" => {
        self.process_gamification_read_all_gamification(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadMilestones" => {
        self.process_gamification_read_milestones(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadAchievements" => {
        self.process_gamification_read_achievements(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadXpLevelsMetaData" => {
        self.process_gamification_read_xp_levels_meta_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadAchievedAchievements" => {
        self.process_gamification_read_achieved_achievements(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadCompletedMilestones" => {
        self.process_gamification_read_completed_milestones(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadInProgressMilestones" => {
        self.process_gamification_read_in_progress_milestones(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadMilestonesByCategory" => {
        self.process_gamification_read_milestones_by_category(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_AwardAchievements" => {
        self.process_gamification_award_achievements(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadQuests" => {
        self.process_gamification_read_quests(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadCompletedQuests" => {
        self.process_gamification_read_completed_quests(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadInProgressQuests" => {
        self.process_gamification_read_in_progress_quests(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadNotStartedQuests" => {
        self.process_gamification_read_not_started_quests(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadQuestsWithStatus" => {
        self.process_gamification_read_quests_with_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadQuestsWithBasicPercentage" => {
        self.process_gamification_read_quests_with_basic_percentage(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadQuestsWithComplexPercentage" => {
        self.process_gamification_read_quests_with_complex_percentage(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ReadQuestsByCategory" => {
        self.process_gamification_read_quests_by_category(message_ident.sequence_number, i_prot, o_prot)
      },
      "Gamification_ResetMilestones" => {
        self.process_gamification_reset_milestones(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalApp_ReadProperties" => {
        self.process_global_app_read_properties(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_CreateEntity" => {
        self.process_global_entity_create_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_CreateEntityWithIndexedId" => {
        self.process_global_entity_create_entity_with_indexed_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_UpdateEntity" => {
        self.process_global_entity_update_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_UpdateEntityAcl" => {
        self.process_global_entity_update_entity_acl(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_UpdateEntityTimeToLive" => {
        self.process_global_entity_update_entity_time_to_live(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_DeleteEntity" => {
        self.process_global_entity_delete_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_ReadEntity" => {
        self.process_global_entity_read_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_GetList" => {
        self.process_global_entity_get_list(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_GetListByIndexedId" => {
        self.process_global_entity_get_list_by_indexed_id(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_GetListCount" => {
        self.process_global_entity_get_list_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_GetPage" => {
        self.process_global_entity_get_page(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_GetPageOffset" => {
        self.process_global_entity_get_page_offset(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_IncrementGlobalEntityData" => {
        self.process_global_entity_increment_global_entity_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_GetRandomEntitiesMatching" => {
        self.process_global_entity_get_random_entities_matching(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_UpdateEntityOwnerAndAcl" => {
        self.process_global_entity_update_entity_owner_and_acl(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalEntity_MakeSystemEntity" => {
        self.process_global_entity_make_system_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalStatistics_ReadAllGlobalStats" => {
        self.process_global_statistics_read_all_global_stats(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalStatistics_ReadGlobalStatsSubset" => {
        self.process_global_statistics_read_global_stats_subset(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalStatistics_ReadGlobalStatsForCategory" => {
        self.process_global_statistics_read_global_stats_for_category(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalStatistics_IncrementGlobalStats" => {
        self.process_global_statistics_increment_global_stats(message_ident.sequence_number, i_prot, o_prot)
      },
      "GlobalStatistics_ProcessStatistics" => {
        self.process_global_statistics_process_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_AcceptGroupInvitation" => {
        self.process_group_accept_group_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_AddGroupMember" => {
        self.process_group_add_group_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ApproveGroupJoinRequest" => {
        self.process_group_approve_group_join_request(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_AutoJoinGroup" => {
        self.process_group_auto_join_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_CancelGroupInvitation" => {
        self.process_group_cancel_group_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_CreateGroup" => {
        self.process_group_create_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_CreateGroupEntity" => {
        self.process_group_create_group_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_DeleteGroup" => {
        self.process_group_delete_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_DeleteGroupEntity" => {
        self.process_group_delete_group_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_GetMyGroups" => {
        self.process_group_get_my_groups(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_IncrementGroupData" => {
        self.process_group_increment_group_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_IncrementGroupEntityData" => {
        self.process_group_increment_group_entity_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_InviteGroupMember" => {
        self.process_group_invite_group_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_JoinGroup" => {
        self.process_group_join_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_LeaveGroup" => {
        self.process_group_leave_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ListGroupsPage" => {
        self.process_group_list_groups_page(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ListGroupsPageByOffset" => {
        self.process_group_list_groups_page_by_offset(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ListGroupsWithMember" => {
        self.process_group_list_groups_with_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ReadGroup" => {
        self.process_group_read_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ReadGroupData" => {
        self.process_group_read_group_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ReadGroupEntitiesPage" => {
        self.process_group_read_group_entities_page(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ReadGroupEntitiesPageByOffset" => {
        self.process_group_read_group_entities_page_by_offset(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ReadGroupEntity" => {
        self.process_group_read_group_entity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_ReadGroupMembers" => {
        self.process_group_read_group_members(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_RejectGroupInvitation" => {
        self.process_group_reject_group_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_RejectGroupJoinRequest" => {
        self.process_group_reject_group_join_request(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_RemoveGroupMember" => {
        self.process_group_remove_group_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_UpdateGroupData" => {
        self.process_group_update_group_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_UpdateGroupEntityData" => {
        self.process_group_update_group_entity_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_UpdateGroupMember" => {
        self.process_group_update_group_member(message_ident.sequence_number, i_prot, o_prot)
      },
      "Group_UpdateGroupName" => {
        self.process_group_update_group_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_AttachEmailIdentity" => {
        self.process_identity_attach_email_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_MergeEmailIdentity" => {
        self.process_identity_merge_email_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_DetachEmailIdentity" => {
        self.process_identity_detach_email_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_AttachUniversalIdentity" => {
        self.process_identity_attach_universal_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_MergeUniversalIdentity" => {
        self.process_identity_merge_universal_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_DetachUniversalIdentity" => {
        self.process_identity_detach_universal_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_SwitchToChildProfile" => {
        self.process_identity_switch_to_child_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_SwitchToSingletonChildProfile" => {
        self.process_identity_switch_to_singleton_child_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_AttachParentWithIdentity" => {
        self.process_identity_attach_parent_with_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_SwitchToParentProfile" => {
        self.process_identity_switch_to_parent_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_DetachParent" => {
        self.process_identity_detach_parent(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_GetChildProfiles" => {
        self.process_identity_get_child_profiles(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_GetIdentities" => {
        self.process_identity_get_identities(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_GetExpiredIdentities" => {
        self.process_identity_get_expired_identities(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_RefreshIdentity" => {
        self.process_identity_refresh_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_ChangeEmailIdentity" => {
        self.process_identity_change_email_identity(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_AttachPeerProfile" => {
        self.process_identity_attach_peer_profile(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_DetachPeer" => {
        self.process_identity_detach_peer(message_ident.sequence_number, i_prot, o_prot)
      },
      "Identity_GetPeerProfiles" => {
        self.process_identity_get_peer_profiles(message_ident.sequence_number, i_prot, o_prot)
      },
      "Mail_SendBasicEmail" => {
        self.process_mail_send_basic_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "Mail_SendAdvancedEmail" => {
        self.process_mail_send_advanced_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "Mail_SendAdvancedEmailByAddress" => {
        self.process_mail_send_advanced_email_by_address(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_Read" => {
        self.process_match_making_read(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_SetPlayerRating" => {
        self.process_match_making_set_player_rating(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_ResetPlayerRating" => {
        self.process_match_making_reset_player_rating(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_IncrementPlayerRating" => {
        self.process_match_making_increment_player_rating(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_DecrementPlayerRating" => {
        self.process_match_making_decrement_player_rating(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_TurnShieldOn" => {
        self.process_match_making_turn_shield_on(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_TurnShieldOnFor" => {
        self.process_match_making_turn_shield_on_for(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_TurnShieldOff" => {
        self.process_match_making_turn_shield_off(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_IncrementShieldOnFor" => {
        self.process_match_making_increment_shield_on_for(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_GetShieldExpiry" => {
        self.process_match_making_get_shield_expiry(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_FindPlayers" => {
        self.process_match_making_find_players(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_FindPlayersWithAttributes" => {
        self.process_match_making_find_players_with_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_FindPlayersUsingFilter" => {
        self.process_match_making_find_players_using_filter(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_FindPlayersWithAttributesUsingFilter" => {
        self.process_match_making_find_players_with_attributes_using_filter(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_EnableMatchMaking" => {
        self.process_match_making_enable_match_making(message_ident.sequence_number, i_prot, o_prot)
      },
      "MatchMaking_DisableMatchMaking" => {
        self.process_match_making_disable_match_making(message_ident.sequence_number, i_prot, o_prot)
      },
      "OneWayMatch_StartMatch" => {
        self.process_one_way_match_start_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "OneWayMatch_CancelMatch" => {
        self.process_one_way_match_cancel_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "OneWayMatch_CompleteMatch" => {
        self.process_one_way_match_complete_match(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_StartStream" => {
        self.process_playback_stream_start_stream(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_ReadStream" => {
        self.process_playback_stream_read_stream(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_EndStream" => {
        self.process_playback_stream_end_stream(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_DeleteStream" => {
        self.process_playback_stream_delete_stream(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_AddEvent" => {
        self.process_playback_stream_add_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_GetRecentStreamsForInitiatingPlayer" => {
        self.process_playback_stream_get_recent_streams_for_initiating_player(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlaybackStream_GetRecentStreamsForTargetPlayer" => {
        self.process_playback_stream_get_recent_streams_for_target_player(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_ReadUserState" => {
        self.process_player_state_read_user_state(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_DeleteUser" => {
        self.process_player_state_delete_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_ResetUser" => {
        self.process_player_state_reset_user(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_Logout" => {
        self.process_player_state_logout(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_UpdateUserName" => {
        self.process_player_state_update_user_name(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_UpdateSummaryFriendData" => {
        self.process_player_state_update_summary_friend_data(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_GetAttributes" => {
        self.process_player_state_get_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_UpdateAttributes" => {
        self.process_player_state_update_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_RemoveAttributes" => {
        self.process_player_state_remove_attributes(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_UpdateUserPictureUrl" => {
        self.process_player_state_update_user_picture_url(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerState_UpdateContactEmail" => {
        self.process_player_state_update_contact_email(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_ReadAllUserStats" => {
        self.process_player_statistics_read_all_user_stats(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_ReadUserStatsSubset" => {
        self.process_player_statistics_read_user_stats_subset(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_ReadUserStatsForCategory" => {
        self.process_player_statistics_read_user_stats_for_category(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_ResetAllUserStats" => {
        self.process_player_statistics_reset_all_user_stats(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_IncrementUserStats_SSFO" => {
        self.process_player_statistics_increment_user_stats_s_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_IncrementUserStats_DSFO" => {
        self.process_player_statistics_increment_user_stats_d_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_ProcessStatistics" => {
        self.process_player_statistics_process_statistics(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_GetNextExperienceLevel" => {
        self.process_player_statistics_get_next_experience_level(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_IncrementExperiencePoints" => {
        self.process_player_statistics_increment_experience_points(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatistics_SetExperiencePoints" => {
        self.process_player_statistics_set_experience_points(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatisticsEvent_TriggerStatsEvent" => {
        self.process_player_statistics_event_trigger_stats_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "PlayerStatisticsEvent_TriggerStatsEvents" => {
        self.process_player_statistics_event_trigger_stats_events(message_ident.sequence_number, i_prot, o_prot)
      },
      "Product_GetCurrency" => {
        self.process_product_get_currency(message_ident.sequence_number, i_prot, o_prot)
      },
      "Product_GetSalesInventory" => {
        self.process_product_get_sales_inventory(message_ident.sequence_number, i_prot, o_prot)
      },
      "Product_GetSalesInventoryByCategory" => {
        self.process_product_get_sales_inventory_by_category(message_ident.sequence_number, i_prot, o_prot)
      },
      "Product_VerifyMicrosoftReceipt" => {
        self.process_product_verify_microsoft_receipt(message_ident.sequence_number, i_prot, o_prot)
      },
      "Product_GetEligiblePromotions" => {
        self.process_product_get_eligible_promotions(message_ident.sequence_number, i_prot, o_prot)
      },
      "Product_VerifyItunesReceipt" => {
        self.process_product_verify_itunes_receipt(message_ident.sequence_number, i_prot, o_prot)
      },
      "Profanity_ProfanityCheck" => {
        self.process_profanity_profanity_check(message_ident.sequence_number, i_prot, o_prot)
      },
      "Profanity_ProfanityReplaceText" => {
        self.process_profanity_profanity_replace_text(message_ident.sequence_number, i_prot, o_prot)
      },
      "Profanity_ProfanityIdentifyBadWords" => {
        self.process_profanity_profanity_identify_bad_words(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_DeregisterAllPushNotificationDeviceTokens" => {
        self.process_push_notification_deregister_all_push_notification_device_tokens(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_DeregisterPushNotificationDeviceToken" => {
        self.process_push_notification_deregister_push_notification_device_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_RegisterPushNotificationDeviceToken" => {
        self.process_push_notification_register_push_notification_device_token(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendSimplePushNotification" => {
        self.process_push_notification_send_simple_push_notification(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendRichPushNotification" => {
        self.process_push_notification_send_rich_push_notification(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendRichPushNotificationWithParams" => {
        self.process_push_notification_send_rich_push_notification_with_params(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendTemplatedPushNotificationToGroup" => {
        self.process_push_notification_send_templated_push_notification_to_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendNormalizedPushNotificationToGroup" => {
        self.process_push_notification_send_normalized_push_notification_to_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_ScheduleRawPushNotificationUTC" => {
        self.process_push_notification_schedule_raw_push_notification_u_t_c(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_ScheduleRawPushNotificationMinutes" => {
        self.process_push_notification_schedule_raw_push_notification_minutes(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendRawPushNotification" => {
        self.process_push_notification_send_raw_push_notification(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendRawPushNotificationBatch" => {
        self.process_push_notification_send_raw_push_notification_batch(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendRawPushNotificationToGroup" => {
        self.process_push_notification_send_raw_push_notification_to_group(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_ScheduleNormalizedPushNotificationUTC" => {
        self.process_push_notification_schedule_normalized_push_notification_u_t_c(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_ScheduleNormalizedPushNotificationMinutes" => {
        self.process_push_notification_schedule_normalized_push_notification_minutes(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_ScheduleRichPushNotificationUTC" => {
        self.process_push_notification_schedule_rich_push_notification_u_t_c(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_ScheduleRichPushNotificationMinutes" => {
        self.process_push_notification_schedule_rich_push_notification_minutes(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendNormalizedPushNotification" => {
        self.process_push_notification_send_normalized_push_notification(message_ident.sequence_number, i_prot, o_prot)
      },
      "PushNotification_SendNormalizedPushNotificationBatch" => {
        self.process_push_notification_send_normalized_push_notification_batch(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_RunScript" => {
        self.process_script_run_script(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_ScheduleRunScriptUTC" => {
        self.process_script_schedule_run_script_u_t_c(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_ScheduleRunScriptMinutes" => {
        self.process_script_schedule_run_script_minutes(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_RunParentScript" => {
        self.process_script_run_parent_script(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_CancelScheduledScript" => {
        self.process_script_cancel_scheduled_script(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_RunPeerScript" => {
        self.process_script_run_peer_script(message_ident.sequence_number, i_prot, o_prot)
      },
      "Script_RunPeerScriptAsynch" => {
        self.process_script_run_peer_script_asynch(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetSocialLeaderboard" => {
        self.process_social_leaderboard_get_social_leaderboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetMultiSocialLeaderboard" => {
        self.process_social_leaderboard_get_multi_social_leaderboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardPage" => {
        self.process_social_leaderboard_get_global_leaderboard_page(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardPageByVersion" => {
        self.process_social_leaderboard_get_global_leaderboard_page_by_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardView" => {
        self.process_social_leaderboard_get_global_leaderboard_view(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardViewByVersion" => {
        self.process_social_leaderboard_get_global_leaderboard_view_by_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardVersions" => {
        self.process_social_leaderboard_get_global_leaderboard_versions(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGroupSocialLeaderboard" => {
        self.process_social_leaderboard_get_group_social_leaderboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_PostScoreToLeaderboard" => {
        self.process_social_leaderboard_post_score_to_leaderboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_RemovePlayerScore" => {
        self.process_social_leaderboard_remove_player_score(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_PostScoreToDynamicLeaderboard" => {
        self.process_social_leaderboard_post_score_to_dynamic_leaderboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_PostScoreToDynamicLeaderboardDays" => {
        self.process_social_leaderboard_post_score_to_dynamic_leaderboard_days(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetPlayersSocialLeaderboard" => {
        self.process_social_leaderboard_get_players_social_leaderboard(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_ListLeaderboards" => {
        self.process_social_leaderboard_list_leaderboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardEntryCount" => {
        self.process_social_leaderboard_get_global_leaderboard_entry_count(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion" => {
        self.process_social_leaderboard_get_global_leaderboard_entry_count_by_version(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetPlayerScore" => {
        self.process_social_leaderboard_get_player_score(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialLeaderboard_GetPlayerScoresFromLeaderboards" => {
        self.process_social_leaderboard_get_player_scores_from_leaderboards(message_ident.sequence_number, i_prot, o_prot)
      },
      "Time_ReadServerTime" => {
        self.process_time_read_server_time(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_ClaimTournamentReward" => {
        self.process_tournament_claim_tournament_reward(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_GetTournamentStatus" => {
        self.process_tournament_get_tournament_status(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_JoinTournament" => {
        self.process_tournament_join_tournament(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_LeaveTournament" => {
        self.process_tournament_leave_tournament(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_PostTournamentScore" => {
        self.process_tournament_post_tournament_score(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_PostTournamentScoreWithResults" => {
        self.process_tournament_post_tournament_score_with_results(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_ViewCurrentReward" => {
        self.process_tournament_view_current_reward(message_ident.sequence_number, i_prot, o_prot)
      },
      "Tournament_ViewReward" => {
        self.process_tournament_view_reward(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_CreateLobby" => {
        self.process_lobby_create_lobby(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_OpenLobby" => {
        self.process_lobby_open_lobby(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_CloseLobby" => {
        self.process_lobby_close_lobby(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_FindLobbies" => {
        self.process_lobby_find_lobbies(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_FindFriendsLobbies" => {
        self.process_lobby_find_friends_lobbies(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_JoinLobby" => {
        self.process_lobby_join_lobby(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_LeaveLobby" => {
        self.process_lobby_leave_lobby(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_DestroyLobby" => {
        self.process_lobby_destroy_lobby(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_StartGame" => {
        self.process_lobby_start_game(message_ident.sequence_number, i_prot, o_prot)
      },
      "Lobby_GetMyLobbies" => {
        self.process_lobby_get_my_lobbies(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_AcceptPartyInvitation" => {
        self.process_party_accept_party_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_GetPartyInfo" => {
        self.process_party_get_party_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_JoinParty" => {
        self.process_party_join_party(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_LeaveParty" => {
        self.process_party_leave_party(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_RejectPartyInvitation" => {
        self.process_party_reject_party_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_SendPartyInvitation" => {
        self.process_party_send_party_invitation(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_ListPartyInvitations" => {
        self.process_party_list_party_invitations(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_GetFriendsParties" => {
        self.process_party_get_friends_parties(message_ident.sequence_number, i_prot, o_prot)
      },
      "Party_GetMyParty" => {
        self.process_party_get_my_party(message_ident.sequence_number, i_prot, o_prot)
      },
      "Patch_GetGameManifest" => {
        self.process_patch_get_game_manifest(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_AddToCart_SISFO" => {
        self.process_shopping_add_to_cart_s_i_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_AddToCart_ISFO" => {
        self.process_shopping_add_to_cart_i_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_EmptyCart" => {
        self.process_shopping_empty_cart(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetCart" => {
        self.process_shopping_get_cart(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_RemoveFromCart" => {
        self.process_shopping_remove_from_cart(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_AddToWishlist" => {
        self.process_shopping_add_to_wishlist(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_EmptyWishlist" => {
        self.process_shopping_empty_wishlist(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetMyWishlist" => {
        self.process_shopping_get_my_wishlist(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetWishlist" => {
        self.process_shopping_get_wishlist(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_RemoveFromWishlist_SSFO" => {
        self.process_shopping_remove_from_wishlist_s_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_RemoveFromWishlist_ISFO" => {
        self.process_shopping_remove_from_wishlist_i_s_f_o(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetUserReviews" => {
        self.process_shopping_get_user_reviews(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_SubmitUserReview" => {
        self.process_shopping_submit_user_review(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_LikeUserReview" => {
        self.process_shopping_like_user_review(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_UnlikeUserReview" => {
        self.process_shopping_unlike_user_review(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_FunnyUserReview" => {
        self.process_shopping_funny_user_review(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_UnfunnyUserReview" => {
        self.process_shopping_unfunny_user_review(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetRecentlyCreatedProducts" => {
        self.process_shopping_get_recently_created_products(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetRecentlyUpdatedProducts" => {
        self.process_shopping_get_recently_updated_products(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetFeaturedProducts" => {
        self.process_shopping_get_featured_products(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetPopularProducts" => {
        self.process_shopping_get_popular_products(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetSpecialOffers" => {
        self.process_shopping_get_special_offers(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetMyLibrary" => {
        self.process_shopping_get_my_library(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetPopularTags" => {
        self.process_shopping_get_popular_tags(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetProductsByTag" => {
        self.process_shopping_get_products_by_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetProductsByTags" => {
        self.process_shopping_get_products_by_tags(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetRecommendedProducts" => {
        self.process_shopping_get_recommended_products(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetMyOrders" => {
        self.process_shopping_get_my_orders(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetProduct" => {
        self.process_shopping_get_product(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetUserTags" => {
        self.process_shopping_get_user_tags(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetMyUserTags" => {
        self.process_shopping_get_my_user_tags(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_SubmitUserTag" => {
        self.process_shopping_submit_user_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_SubmitUserTags" => {
        self.process_shopping_submit_user_tags(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_RemoveUserTag" => {
        self.process_shopping_remove_user_tag(message_ident.sequence_number, i_prot, o_prot)
      },
      "Shopping_GetBuildDetails" => {
        self.process_shopping_get_build_details(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareVideo" => {
        self.process_social_feed_share_video(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareScreenshot" => {
        self.process_social_feed_share_screenshot(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareAchievement" => {
        self.process_social_feed_share_achievement(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareApp" => {
        self.process_social_feed_share_app(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareChannel" => {
        self.process_social_feed_share_channel(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareLink" => {
        self.process_social_feed_share_link(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ShareGameGuide" => {
        self.process_social_feed_share_game_guide(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ReadSocialFeed" => {
        self.process_social_feed_read_social_feed(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ReadFilteredSocialFeed" => {
        self.process_social_feed_read_filtered_social_feed(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ReadFriendsSocialFeed" => {
        self.process_social_feed_read_friends_social_feed(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_PostComment" => {
        self.process_social_feed_post_comment(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_PostCommentReply" => {
        self.process_social_feed_post_comment_reply(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ReadComments" => {
        self.process_social_feed_read_comments(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_ReadCommentReplies" => {
        self.process_social_feed_read_comment_replies(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_LikeComment" => {
        self.process_social_feed_like_comment(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_LikeActivity" => {
        self.process_social_feed_like_activity(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_UnlikeComment" => {
        self.process_social_feed_unlike_comment(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_UnlikeActivity" => {
        self.process_social_feed_unlike_activity(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_SetFeedVisibility" => {
        self.process_social_feed_set_feed_visibility(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_BlockPlayer" => {
        self.process_social_feed_block_player(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_HidePlayer" => {
        self.process_social_feed_hide_player(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_UnblockPlayer" => {
        self.process_social_feed_unblock_player(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_UnhidePlayer" => {
        self.process_social_feed_unhide_player(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_GetActivity" => {
        self.process_social_feed_get_activity(message_ident.sequence_number, i_prot, o_prot)
      },
      "SocialFeed_GetComment" => {
        self.process_social_feed_get_comment(message_ident.sequence_number, i_prot, o_prot)
      },
      "Telemetry_StartTelemetrySession" => {
        self.process_telemetry_start_telemetry_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "Telemetry_EndTelemetrySession" => {
        self.process_telemetry_end_telemetry_session(message_ident.sequence_number, i_prot, o_prot)
      },
      "Telemetry_LogTelemetryEvent" => {
        self.process_telemetry_log_telemetry_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "Telemetry_StartTelemetryEvent" => {
        self.process_telemetry_start_telemetry_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "Telemetry_EndTelemetryEvent" => {
        self.process_telemetry_end_telemetry_event(message_ident.sequence_number, i_prot, o_prot)
      },
      "Authentication_GetWeChatQRPageURL" => {
        self.process_authentication_get_we_chat_q_r_page_u_r_l(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_DownloadFile" => {
        self.process_file_download_file(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_GetDownloadInfo" => {
        self.process_file_get_download_info(message_ident.sequence_number, i_prot, o_prot)
      },
      "File_CancelDownload" => {
        self.process_file_cancel_download(message_ident.sequence_number, i_prot, o_prot)
      },
      method => {
        Err(
          thrift::Error::Application(
            ApplicationError::new(
              ApplicationErrorKind::UnknownMethod,
              format!("unknown method {}", method)
            )
          )
        )
      },
    };
    thrift::server::handle_process_result(&message_ident, res, o_prot)
  }
}

//
// BrainCloudServiceAsyncMatchCreateMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchCreateMatchArgs {
  /// JSON string identifying the opponent platform and id for this match.
  /// 
  /// Platforms are identified as:
  /// BC - a brainCloud profile id
  /// FB - a Facebook id
  /// 
  /// An exmaple of this string would be:
  /// [
  ///     {
  ///         "platform": "BC",
  ///         "id": "some-braincloud-profile"
  ///     },
  ///     {
  ///         "platform": "FB",
  ///         "id": "some-facebook-id"
  ///     }
  /// ]
  json_opponent_ids: String,
  /// Optional push notification message to send to the other party.
  /// Refer to the Push Notification functions for the syntax required.
  push_notification_message: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchCreateMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchCreateMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchArgs.json_opponent_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchArgs.push_notification_message", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAsyncMatchCreateMatchArgs {
      json_opponent_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      push_notification_message: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_CreateMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonOpponentIds", TType::String, 1))?;
    o_prot.write_string(&self.json_opponent_ids)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pushNotificationMessage", TType::String, 2))?;
    o_prot.write_string(&self.push_notification_message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchCreateMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchCreateMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchCreateMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchCreateMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchCreateMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchCreateMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchCreateMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs {
  /// JSON string identifying the opponent platform and id for this match.
  /// 
  /// Platforms are identified as:
  /// BC - a brainCloud profile id
  /// FB - a Facebook id
  /// 
  /// An exmaple of this string would be:
  /// [
  ///     {
  ///         "platform": "BC",
  ///         "id": "some-braincloud-profile"
  ///     },
  ///     {
  ///         "platform": "FB",
  ///         "id": "some-facebook-id"
  ///     }
  /// ]
  json_opponent_ids: String,
  /// JSON string blob provided by the caller
  json_match_state: String,
  /// Optional push notification message to send to the other party.
  /// Refer to the Push Notification functions for the syntax required.
  push_notification_message: String,
  /// Optionally, force the next player player to be a specific player
  next_player: String,
  /// Optional JSON string defining what the other player will see as a summary of the game when listing their games
  json_summary: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs.json_opponent_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs.json_match_state", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs.push_notification_message", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs.next_player", &f_4)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs.json_summary", &f_5)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnArgs {
      json_opponent_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_match_state: f_2.expect("auto-generated code should have checked for presence of required fields"),
      push_notification_message: f_3.expect("auto-generated code should have checked for presence of required fields"),
      next_player: f_4.expect("auto-generated code should have checked for presence of required fields"),
      json_summary: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_CreateMatchWithInitialTurn_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonOpponentIds", TType::String, 1))?;
    o_prot.write_string(&self.json_opponent_ids)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonMatchState", TType::String, 2))?;
    o_prot.write_string(&self.json_match_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pushNotificationMessage", TType::String, 3))?;
    o_prot.write_string(&self.push_notification_message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nextPlayer", TType::String, 4))?;
    o_prot.write_string(&self.next_player)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonSummary", TType::String, 5))?;
    o_prot.write_string(&self.json_summary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchCreateMatchWithInitialTurnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchCreateMatchWithInitialTurn"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchSubmitTurnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchSubmitTurnArgs {
  /// Match owner identfier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// Game state version to ensure turns are submitted once and in order
  version: i64,
  /// JSON string blob provided by the caller
  json_match_state: String,
  /// Optional push notification message to send to the other party.
  /// Refer to the Push Notification functions for the syntax required.
  push_notification_message: String,
  /// Optionally, force the next player player to be a specific player
  next_player: String,
  /// Optional JSON string that other players will see as a summary of the game when listing their games
  json_summary: String,
  /// Optional JSON string blob provided by the caller
  json_statistics: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchSubmitTurnArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchSubmitTurnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<String> = None;
    let mut f_9: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.version", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.json_match_state", &f_4)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.push_notification_message", &f_5)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.next_player", &f_6)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.json_summary", &f_7)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.json_statistics", &f_8)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchSubmitTurnArgs.client_index", &f_9)?;
    let ret = BrainCloudServiceAsyncMatchSubmitTurnArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_match_state: f_4.expect("auto-generated code should have checked for presence of required fields"),
      push_notification_message: f_5.expect("auto-generated code should have checked for presence of required fields"),
      next_player: f_6.expect("auto-generated code should have checked for presence of required fields"),
      json_summary: f_7.expect("auto-generated code should have checked for presence of required fields"),
      json_statistics: f_8.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_SubmitTurn_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonMatchState", TType::String, 4))?;
    o_prot.write_string(&self.json_match_state)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pushNotificationMessage", TType::String, 5))?;
    o_prot.write_string(&self.push_notification_message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("nextPlayer", TType::String, 6))?;
    o_prot.write_string(&self.next_player)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonSummary", TType::String, 7))?;
    o_prot.write_string(&self.json_summary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonStatistics", TType::String, 8))?;
    o_prot.write_string(&self.json_statistics)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 9))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchSubmitTurnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchSubmitTurnResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchSubmitTurnResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchSubmitTurnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchSubmitTurnResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchSubmitTurnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchSubmitTurn"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs {
  /// Match owner identfier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// Game state version to ensure turns are submitted once and in order
  version: i64,
  /// JSON string provided by the caller that other players will see as a summary of the game when listing their games
  json_summary: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs.version", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs.json_summary", &f_4)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceAsyncMatchUpdateMatchSummaryDataArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_summary: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_UpdateMatchSummaryData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonSummary", TType::String, 4))?;
    o_prot.write_string(&self.json_summary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchUpdateMatchSummaryDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchUpdateMatchSummaryData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchCompleteMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchCompleteMatchArgs {
  /// Match owner identifier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchCompleteMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchCompleteMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCompleteMatchArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCompleteMatchArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchCompleteMatchArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAsyncMatchCompleteMatchArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_CompleteMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchCompleteMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchCompleteMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchCompleteMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchCompleteMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchCompleteMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchCompleteMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchCompleteMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchReadMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchReadMatchArgs {
  /// Match owner identifier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchReadMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchReadMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchReadMatchArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchReadMatchArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchReadMatchArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAsyncMatchReadMatchArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_ReadMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchReadMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchReadMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchReadMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchReadMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchReadMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchReadMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchReadMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchReadMatchHistoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchReadMatchHistoryArgs {
  /// Match owner identifier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchReadMatchHistoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchReadMatchHistoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchReadMatchHistoryArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchReadMatchHistoryArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchReadMatchHistoryArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAsyncMatchReadMatchHistoryArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_ReadMatchHistory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchReadMatchHistoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchReadMatchHistoryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchReadMatchHistoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchReadMatchHistoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchReadMatchHistoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchReadMatchHistoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchReadMatchHistory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchFindMatchesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchFindMatchesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchFindMatchesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchFindMatchesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchFindMatchesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceAsyncMatchFindMatchesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_FindMatches_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchFindMatchesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchFindMatchesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchFindMatchesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchFindMatchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchFindMatchesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchFindMatchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchFindMatches"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchFindCompleteMatchesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchFindCompleteMatchesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchFindCompleteMatchesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchFindCompleteMatchesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchFindCompleteMatchesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceAsyncMatchFindCompleteMatchesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_FindCompleteMatches_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchFindCompleteMatchesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchFindCompleteMatchesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchFindCompleteMatchesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchFindCompleteMatchesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchFindCompleteMatchesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchFindCompleteMatchesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchFindCompleteMatches"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchAbandonMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchAbandonMatchArgs {
  /// Match owner identifier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchAbandonMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchAbandonMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchAbandonMatchArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchAbandonMatchArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchAbandonMatchArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAsyncMatchAbandonMatchArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_AbandonMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchAbandonMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchAbandonMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchAbandonMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchAbandonMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchAbandonMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchAbandonMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchAbandonMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAsyncMatchDeleteMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchDeleteMatchArgs {
  /// Match owner identifier
  owner_id: String,
  /// Match identifier
  match_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAsyncMatchDeleteMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchDeleteMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchDeleteMatchArgs.owner_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchDeleteMatchArgs.match_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAsyncMatchDeleteMatchArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAsyncMatchDeleteMatchArgs {
      owner_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      match_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("AsyncMatch_DeleteMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 1))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("matchId", TType::String, 2))?;
    o_prot.write_string(&self.match_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAsyncMatchDeleteMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAsyncMatchDeleteMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAsyncMatchDeleteMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAsyncMatchDeleteMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAsyncMatchDeleteMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAsyncMatchDeleteMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAsyncMatchDeleteMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationGenerateAnonymousIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationGenerateAnonymousIdArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationGenerateAnonymousIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationGenerateAnonymousIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationGenerateAnonymousIdArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceAuthenticationGenerateAnonymousIdArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_GenerateAnonymousId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationGenerateAnonymousIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationGenerateAnonymousIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationGenerateAnonymousIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationGenerateAnonymousIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationGenerateAnonymousIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationGenerateAnonymousIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationGenerateAnonymousId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationInitializeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationInitializeArgs {
  /// The id of the profile id that was most recently used by the app (on this device)
  profile_id: String,
  /// The anonymous installation id that was generated for this device
  anonymous_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationInitializeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationInitializeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationInitializeArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationInitializeArgs.anonymous_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationInitializeArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAuthenticationInitializeArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      anonymous_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_Initialize_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("anonymousId", TType::String, 2))?;
    o_prot.write_string(&self.anonymous_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationInitializeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationInitializeResult {
}

impl BrainCloudServiceAuthenticationInitializeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationInitializeResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationInitializeResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationInitializeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceAuthenticationClearSavedProfileIDArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationClearSavedProfileIDArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationClearSavedProfileIDArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationClearSavedProfileIDArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationClearSavedProfileIDArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceAuthenticationClearSavedProfileIDArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_ClearSavedProfileID_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationClearSavedProfileIDResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationClearSavedProfileIDResult {
}

impl BrainCloudServiceAuthenticationClearSavedProfileIDResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationClearSavedProfileIDResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationClearSavedProfileIDResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationClearSavedProfileIDResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateAnonymousArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateAnonymousArgs {
  /// Should a new profile be created if it does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationAuthenticateAnonymousArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateAnonymousArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateAnonymousArgs.force_create", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateAnonymousArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceAuthenticationAuthenticateAnonymousArgs {
      force_create: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_AuthenticateAnonymous_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 1))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateAnonymousResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateAnonymousResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationAuthenticateAnonymousResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateAnonymousResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationAuthenticateAnonymousResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationAuthenticateAnonymousResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationAuthenticateAnonymous"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs {
  /// The e-mail address of the user
  email: String,
  /// The password of the user
  password: String,
  /// Should a new profile be created for this user if the account does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs.email", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs.force_create", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceAuthenticationAuthenticateEmailPasswordArgs {
      email: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_AuthenticateEmailPassword_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 1))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 3))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationAuthenticateEmailPasswordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationAuthenticateEmailPassword"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateUniversalArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateUniversalArgs {
  user_id: String,
  /// The password of the user
  password: String,
  /// Should a new profile be created for this user if the account does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationAuthenticateUniversalArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateUniversalArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateUniversalArgs.user_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateUniversalArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateUniversalArgs.force_create", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateUniversalArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceAuthenticationAuthenticateUniversalArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_AuthenticateUniversal_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 3))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateUniversalResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateUniversalResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationAuthenticateUniversalResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateUniversalResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationAuthenticateUniversalResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationAuthenticateUniversalResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationAuthenticateUniversal"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateExternalArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateExternalArgs {
  /// The user id
  user_id: String,
  /// The user token (password etc)
  token: String,
  /// The name of the cloud script to call for external authentication
  external_auth_name: String,
  /// Should a new profile be created for this user if the account does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationAuthenticateExternalArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateExternalArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateExternalArgs.user_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateExternalArgs.token", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateExternalArgs.external_auth_name", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateExternalArgs.force_create", &f_4)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateExternalArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceAuthenticationAuthenticateExternalArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      external_auth_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_AuthenticateExternal_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
    o_prot.write_string(&self.token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalAuthName", TType::String, 3))?;
    o_prot.write_string(&self.external_auth_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 4))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateExternalResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateExternalResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationAuthenticateExternalResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateExternalResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationAuthenticateExternalResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationAuthenticateExternalResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationAuthenticateExternal"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationAuthenticatePhoneArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticatePhoneArgs {
  /// The phone number to authenticate with
  phone_number: String,
  /// The code sent to the mobile phone
  auth_code: String,
  /// Should a new profile be created for this user if the account does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationAuthenticatePhoneArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticatePhoneArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticatePhoneArgs.phone_number", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticatePhoneArgs.auth_code", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticatePhoneArgs.force_create", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticatePhoneArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceAuthenticationAuthenticatePhoneArgs {
      phone_number: f_1.expect("auto-generated code should have checked for presence of required fields"),
      auth_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_AuthenticatePhone_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phoneNumber", TType::String, 1))?;
    o_prot.write_string(&self.phone_number)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authCode", TType::String, 2))?;
    o_prot.write_string(&self.auth_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 3))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationAuthenticatePhoneResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticatePhoneResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationAuthenticatePhoneResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticatePhoneResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationAuthenticatePhoneResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationAuthenticatePhoneResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationAuthenticatePhone"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateWechatArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateWechatArgs {
  /// The open id passed from wechat
  open_id: String,
  /// The access token passed from wechat
  token: String,
  /// Should a new profile be created for this user if the account does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationAuthenticateWechatArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateWechatArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateWechatArgs.open_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateWechatArgs.token", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateWechatArgs.force_create", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationAuthenticateWechatArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceAuthenticationAuthenticateWechatArgs {
      open_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_AuthenticateWechat_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("openId", TType::String, 1))?;
    o_prot.write_string(&self.open_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
    o_prot.write_string(&self.token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 3))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationAuthenticateWechatResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationAuthenticateWechatResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationAuthenticateWechatResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationAuthenticateWechatResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationAuthenticateWechatResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationAuthenticateWechatResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationAuthenticateWechat"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationResetEmailPasswordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationResetEmailPasswordArgs {
  /// The email address to send the reset email to.
  external_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationResetEmailPasswordArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationResetEmailPasswordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationResetEmailPasswordArgs.external_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationResetEmailPasswordArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceAuthenticationResetEmailPasswordArgs {
      external_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_ResetEmailPassword_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalId", TType::String, 1))?;
    o_prot.write_string(&self.external_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationResetEmailPasswordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationResetEmailPasswordResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationResetEmailPasswordResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationResetEmailPasswordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationResetEmailPasswordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationResetEmailPasswordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationResetEmailPassword"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationRequestSmsCodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationRequestSmsCodeArgs {
  /// The phone number to send the code to.
  phone_number: String,
  /// Whether or not to create a new player if they don't exist.
  force_create: bool,
  is_international: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationRequestSmsCodeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationRequestSmsCodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationRequestSmsCodeArgs.phone_number", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationRequestSmsCodeArgs.force_create", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationRequestSmsCodeArgs.is_international", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationRequestSmsCodeArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceAuthenticationRequestSmsCodeArgs {
      phone_number: f_1.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_international: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_RequestSmsCode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("phoneNumber", TType::String, 1))?;
    o_prot.write_string(&self.phone_number)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 2))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isInternational", TType::Bool, 3))?;
    o_prot.write_bool(self.is_international)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationRequestSmsCodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationRequestSmsCodeResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationRequestSmsCodeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationRequestSmsCodeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationRequestSmsCodeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationRequestSmsCodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationRequestSmsCode"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationCheckUsernameExistsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationCheckUsernameExistsArgs {
  game_id: String,
  player_name: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationCheckUsernameExistsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationCheckUsernameExistsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationCheckUsernameExistsArgs.game_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationCheckUsernameExistsArgs.player_name", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationCheckUsernameExistsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceAuthenticationCheckUsernameExistsArgs {
      game_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      player_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_CheckUsernameExists_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gameId", TType::String, 1))?;
    o_prot.write_string(&self.game_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerName", TType::String, 2))?;
    o_prot.write_string(&self.player_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationCheckUsernameExistsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationCheckUsernameExistsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationCheckUsernameExistsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationCheckUsernameExistsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationCheckUsernameExistsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationCheckUsernameExistsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationCheckUsernameExists"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationChangeUniversalPasswordArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationChangeUniversalPasswordArgs {
  game_id: String,
  player_id: String,
  old_password: String,
  new_password: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationChangeUniversalPasswordArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationChangeUniversalPasswordArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationChangeUniversalPasswordArgs.game_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationChangeUniversalPasswordArgs.player_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationChangeUniversalPasswordArgs.old_password", &f_3)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationChangeUniversalPasswordArgs.new_password", &f_4)?;
    verify_required_field_exists("BrainCloudServiceAuthenticationChangeUniversalPasswordArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceAuthenticationChangeUniversalPasswordArgs {
      game_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      player_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      old_password: f_3.expect("auto-generated code should have checked for presence of required fields"),
      new_password: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_ChangeUniversalPassword_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gameId", TType::String, 1))?;
    o_prot.write_string(&self.game_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 2))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("oldPassword", TType::String, 3))?;
    o_prot.write_string(&self.old_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("newPassword", TType::String, 4))?;
    o_prot.write_string(&self.new_password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationChangeUniversalPasswordResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationChangeUniversalPasswordResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationChangeUniversalPasswordResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationChangeUniversalPasswordResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationChangeUniversalPasswordResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationChangeUniversalPasswordResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationChangeUniversalPassword"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientGetSessionIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetSessionIdArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientGetSessionIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetSessionIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientGetSessionIdArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientGetSessionIdArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_GetSessionId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientGetSessionIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetSessionIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceClientGetSessionIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetSessionIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientGetSessionIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientGetSessionIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientGetSessionId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientIsAuthenticatedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientIsAuthenticatedArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientIsAuthenticatedArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientIsAuthenticatedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientIsAuthenticatedArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientIsAuthenticatedArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_IsAuthenticated_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientIsAuthenticatedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientIsAuthenticatedResult {
  result_value: Option<bool>,
}

impl BrainCloudServiceClientIsAuthenticatedResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientIsAuthenticatedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientIsAuthenticatedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientIsAuthenticatedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientIsAuthenticated"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientIsInitializedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientIsInitializedArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientIsInitializedArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientIsInitializedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientIsInitializedArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientIsInitializedArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_IsInitialized_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientIsInitializedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientIsInitializedResult {
  result_value: Option<bool>,
}

impl BrainCloudServiceClientIsInitializedResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientIsInitializedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<bool> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_bool()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientIsInitializedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientIsInitializedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Bool, 0))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<bool> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientIsInitialized"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientInitializeSSSArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInitializeSSSArgs {
  /// The secret key for your app
  secret_key: String,
  app_id: String,
  /// The app version
  app_version: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientInitializeSSSArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInitializeSSSArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSArgs.secret_key", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSArgs.app_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSArgs.app_version", &f_3)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceClientInitializeSSSArgs {
      secret_key: f_1.expect("auto-generated code should have checked for presence of required fields"),
      app_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      app_version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_Initialize_SSS_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secretKey", TType::String, 1))?;
    o_prot.write_string(&self.secret_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appId", TType::String, 2))?;
    o_prot.write_string(&self.app_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appVersion", TType::String, 3))?;
    o_prot.write_string(&self.app_version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientInitializeSSSResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInitializeSSSResult {
}

impl BrainCloudServiceClientInitializeSSSResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInitializeSSSResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientInitializeSSSResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientInitializeSSSResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientInitializeSSSSArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInitializeSSSSArgs {
  /// The URL to the brainCloud server
  server_u_r_l: String,
  /// The secret key for your app
  secret_key: String,
  /// The app id
  app_id: String,
  /// The app version
  app_version: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientInitializeSSSSArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInitializeSSSSArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSSArgs.server_u_r_l", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSSArgs.secret_key", &f_2)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSSArgs.app_id", &f_3)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSSArgs.app_version", &f_4)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeSSSSArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceClientInitializeSSSSArgs {
      server_u_r_l: f_1.expect("auto-generated code should have checked for presence of required fields"),
      secret_key: f_2.expect("auto-generated code should have checked for presence of required fields"),
      app_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      app_version: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_Initialize_SSSS_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("serverURL", TType::String, 1))?;
    o_prot.write_string(&self.server_u_r_l)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("secretKey", TType::String, 2))?;
    o_prot.write_string(&self.secret_key)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appId", TType::String, 3))?;
    o_prot.write_string(&self.app_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("appVersion", TType::String, 4))?;
    o_prot.write_string(&self.app_version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientInitializeSSSSResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInitializeSSSSResult {
}

impl BrainCloudServiceClientInitializeSSSSResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInitializeSSSSResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientInitializeSSSSResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientInitializeSSSSResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientInitializeIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInitializeIdentityArgs {
  /// The profile id
  profile_id: String,
  /// The anonymous id
  anonymous_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientInitializeIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInitializeIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientInitializeIdentityArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeIdentityArgs.anonymous_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceClientInitializeIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceClientInitializeIdentityArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      anonymous_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_InitializeIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("anonymousId", TType::String, 2))?;
    o_prot.write_string(&self.anonymous_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientInitializeIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInitializeIdentityResult {
}

impl BrainCloudServiceClientInitializeIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInitializeIdentityResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientInitializeIdentityResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientInitializeIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientUpdateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientUpdateArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientUpdateArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientUpdateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientUpdateArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientUpdateArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_Update_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientUpdateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientUpdateResult {
}

impl BrainCloudServiceClientUpdateResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientUpdateResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientUpdateResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientUpdateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientEnableLoggingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientEnableLoggingArgs {
  /// True if logging is to be enabled
  enable: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientEnableLoggingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientEnableLoggingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientEnableLoggingArgs.enable", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientEnableLoggingArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientEnableLoggingArgs {
      enable: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_EnableLogging_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("enable", TType::Bool, 1))?;
    o_prot.write_bool(self.enable)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientEnableLoggingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientEnableLoggingResult {
}

impl BrainCloudServiceClientEnableLoggingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientEnableLoggingResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientEnableLoggingResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientEnableLoggingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientResetCommunicationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientResetCommunicationArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientResetCommunicationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientResetCommunicationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientResetCommunicationArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientResetCommunicationArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_ResetCommunication_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientResetCommunicationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientResetCommunicationResult {
}

impl BrainCloudServiceClientResetCommunicationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientResetCommunicationResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientResetCommunicationResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientResetCommunicationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientSetPacketTimeoutsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetPacketTimeoutsArgs {
  /// An array of packet timeouts.
  timeouts: Vec<i32>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientSetPacketTimeoutsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetPacketTimeoutsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<i32>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = i_prot.read_i32()?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientSetPacketTimeoutsArgs.timeouts", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientSetPacketTimeoutsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientSetPacketTimeoutsArgs {
      timeouts: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_SetPacketTimeouts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeouts", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::I32, self.timeouts.len() as i32))?;
    for e in &self.timeouts {
      o_prot.write_i32(*e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientSetPacketTimeoutsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetPacketTimeoutsResult {
}

impl BrainCloudServiceClientSetPacketTimeoutsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetPacketTimeoutsResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientSetPacketTimeoutsResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientSetPacketTimeoutsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientSetPacketTimeoutsToDefaultArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_SetPacketTimeoutsToDefault_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientSetPacketTimeoutsToDefaultResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetPacketTimeoutsToDefaultResult {
}

impl BrainCloudServiceClientSetPacketTimeoutsToDefaultResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetPacketTimeoutsToDefaultResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientSetPacketTimeoutsToDefaultResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientSetPacketTimeoutsToDefaultResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientGetPacketTimeoutsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetPacketTimeoutsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientGetPacketTimeoutsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetPacketTimeoutsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientGetPacketTimeoutsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientGetPacketTimeoutsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_GetPacketTimeouts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientGetPacketTimeoutsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetPacketTimeoutsResult {
  result_value: Option<Vec<i32>>,
}

impl BrainCloudServiceClientGetPacketTimeoutsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetPacketTimeoutsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<Vec<i32>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<i32> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = i_prot.read_i32()?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientGetPacketTimeoutsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientGetPacketTimeoutsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::List, 0))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::I32, fld_var.len() as i32))?;
      for e in fld_var {
        o_prot.write_i32(*e)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<Vec<i32>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientGetPacketTimeouts"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs {
  timeout_secs: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs.timeout_secs", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientSetAuthenticationPacketTimeoutArgs {
      timeout_secs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_SetAuthenticationPacketTimeout_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeoutSecs", TType::I32, 1))?;
    o_prot.write_i32(self.timeout_secs)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientSetAuthenticationPacketTimeoutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetAuthenticationPacketTimeoutResult {
}

impl BrainCloudServiceClientSetAuthenticationPacketTimeoutResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetAuthenticationPacketTimeoutResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientSetAuthenticationPacketTimeoutResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientSetAuthenticationPacketTimeoutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientGetAuthenticationPacketTimeoutArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_GetAuthenticationPacketTimeout_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientGetAuthenticationPacketTimeoutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetAuthenticationPacketTimeoutResult {
  result_value: Option<i32>,
}

impl BrainCloudServiceClientGetAuthenticationPacketTimeoutResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetAuthenticationPacketTimeoutResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientGetAuthenticationPacketTimeoutResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientGetAuthenticationPacketTimeoutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientGetAuthenticationPacketTimeout"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientGetUploadLowTransferRateTimeoutArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_GetUploadLowTransferRateTimeout_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult {
  result_value: Option<i32>,
}

impl BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientGetUploadLowTransferRateTimeoutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientGetUploadLowTransferRateTimeout"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs {
  timeout_secs: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs.timeout_secs", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientSetUploadLowTransferRateTimeoutArgs {
      timeout_secs: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_SetUploadLowTransferRateTimeout_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeoutSecs", TType::I32, 1))?;
    o_prot.write_i32(self.timeout_secs)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult {
}

impl BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientSetUploadLowTransferRateTimeoutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientGetUploadLowTransferRateThresholdArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_GetUploadLowTransferRateThreshold_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientGetUploadLowTransferRateThresholdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientGetUploadLowTransferRateThresholdResult {
  result_value: Option<i32>,
}

impl BrainCloudServiceClientGetUploadLowTransferRateThresholdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientGetUploadLowTransferRateThresholdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i32()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientGetUploadLowTransferRateThresholdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientGetUploadLowTransferRateThresholdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I32, 0))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i32> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceClientGetUploadLowTransferRateThreshold"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs {
  /// The low transfer rate threshold in bytes/sec
  bytes_per_sec: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs.bytes_per_sec", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientSetUploadLowTransferRateThresholdArgs {
      bytes_per_sec: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_SetUploadLowTransferRateThreshold_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("bytesPerSec", TType::I32, 1))?;
    o_prot.write_i32(self.bytes_per_sec)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientSetUploadLowTransferRateThresholdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientSetUploadLowTransferRateThresholdResult {
}

impl BrainCloudServiceClientSetUploadLowTransferRateThresholdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientSetUploadLowTransferRateThresholdResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientSetUploadLowTransferRateThresholdResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientSetUploadLowTransferRateThresholdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs {
  /// True if message should be cached on timeout
  enabled: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs.enabled", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientEnableNetworkErrorMessageCachingArgs {
      enabled: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_EnableNetworkErrorMessageCaching_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("enabled", TType::Bool, 1))?;
    o_prot.write_bool(self.enabled)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientEnableNetworkErrorMessageCachingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientEnableNetworkErrorMessageCachingResult {
}

impl BrainCloudServiceClientEnableNetworkErrorMessageCachingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientEnableNetworkErrorMessageCachingResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientEnableNetworkErrorMessageCachingResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientEnableNetworkErrorMessageCachingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientRetryCachedMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientRetryCachedMessagesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientRetryCachedMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientRetryCachedMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientRetryCachedMessagesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientRetryCachedMessagesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_RetryCachedMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientRetryCachedMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientRetryCachedMessagesResult {
}

impl BrainCloudServiceClientRetryCachedMessagesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientRetryCachedMessagesResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientRetryCachedMessagesResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientRetryCachedMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientFlushCachedMessagesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientFlushCachedMessagesArgs {
  /// If set to true API error callbacks will
  /// be called for every cached message with statusCode CLIENT_NETWORK_ERROR and reasonCode CLIENT_NETWORK_ERROR_TIMEOUT.
  send_api_error_callbacks: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientFlushCachedMessagesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientFlushCachedMessagesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientFlushCachedMessagesArgs.send_api_error_callbacks", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientFlushCachedMessagesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientFlushCachedMessagesArgs {
      send_api_error_callbacks: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_FlushCachedMessages_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sendApiErrorCallbacks", TType::Bool, 1))?;
    o_prot.write_bool(self.send_api_error_callbacks)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientFlushCachedMessagesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientFlushCachedMessagesResult {
}

impl BrainCloudServiceClientFlushCachedMessagesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientFlushCachedMessagesResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientFlushCachedMessagesResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientFlushCachedMessagesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceClientInsertEndOfMessageBundleMarkerArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_InsertEndOfMessageBundleMarker_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult {
}

impl BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientInsertEndOfMessageBundleMarkerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientOverrideCountryCodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientOverrideCountryCodeArgs {
  /// ISO 3166-1 two-letter country code
  country_code: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientOverrideCountryCodeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientOverrideCountryCodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientOverrideCountryCodeArgs.country_code", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientOverrideCountryCodeArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientOverrideCountryCodeArgs {
      country_code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_OverrideCountryCode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("countryCode", TType::String, 1))?;
    o_prot.write_string(&self.country_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientOverrideCountryCodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientOverrideCountryCodeResult {
}

impl BrainCloudServiceClientOverrideCountryCodeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientOverrideCountryCodeResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientOverrideCountryCodeResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientOverrideCountryCodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceClientOverrideLanguageCodeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientOverrideLanguageCodeArgs {
  /// ISO 639-1 two-letter language code
  language_code: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceClientOverrideLanguageCodeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientOverrideLanguageCodeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceClientOverrideLanguageCodeArgs.language_code", &f_1)?;
    verify_required_field_exists("BrainCloudServiceClientOverrideLanguageCodeArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceClientOverrideLanguageCodeArgs {
      language_code: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Client_OverrideLanguageCode_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("languageCode", TType::String, 1))?;
    o_prot.write_string(&self.language_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceClientOverrideLanguageCodeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceClientOverrideLanguageCodeResult {
}

impl BrainCloudServiceClientOverrideLanguageCodeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceClientOverrideLanguageCodeResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceClientOverrideLanguageCodeResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceClientOverrideLanguageCodeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceDataStreamCustomPageEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceDataStreamCustomPageEventArgs {
  /// The name of the event
  event_name: String,
  /// The properties of the event
  json_event_properties: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceDataStreamCustomPageEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceDataStreamCustomPageEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomPageEventArgs.event_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomPageEventArgs.json_event_properties", &f_2)?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomPageEventArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceDataStreamCustomPageEventArgs {
      event_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_event_properties: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataStream_CustomPageEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventName", TType::String, 1))?;
    o_prot.write_string(&self.event_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEventProperties", TType::String, 2))?;
    o_prot.write_string(&self.json_event_properties)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceDataStreamCustomPageEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceDataStreamCustomPageEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceDataStreamCustomPageEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceDataStreamCustomPageEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceDataStreamCustomPageEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceDataStreamCustomPageEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceDataStreamCustomPageEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceDataStreamCustomScreenEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceDataStreamCustomScreenEventArgs {
  /// The name of the event
  event_name: String,
  /// The properties of the event
  json_event_properties: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceDataStreamCustomScreenEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceDataStreamCustomScreenEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomScreenEventArgs.event_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomScreenEventArgs.json_event_properties", &f_2)?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomScreenEventArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceDataStreamCustomScreenEventArgs {
      event_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_event_properties: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataStream_CustomScreenEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventName", TType::String, 1))?;
    o_prot.write_string(&self.event_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEventProperties", TType::String, 2))?;
    o_prot.write_string(&self.json_event_properties)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceDataStreamCustomScreenEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceDataStreamCustomScreenEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceDataStreamCustomScreenEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceDataStreamCustomScreenEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceDataStreamCustomScreenEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceDataStreamCustomScreenEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceDataStreamCustomScreenEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceDataStreamCustomTrackEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceDataStreamCustomTrackEventArgs {
  /// The name of the event
  event_name: String,
  /// The properties of the event
  json_event_properties: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceDataStreamCustomTrackEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceDataStreamCustomTrackEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomTrackEventArgs.event_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomTrackEventArgs.json_event_properties", &f_2)?;
    verify_required_field_exists("BrainCloudServiceDataStreamCustomTrackEventArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceDataStreamCustomTrackEventArgs {
      event_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_event_properties: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("DataStream_CustomTrackEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventName", TType::String, 1))?;
    o_prot.write_string(&self.event_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEventProperties", TType::String, 2))?;
    o_prot.write_string(&self.json_event_properties)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceDataStreamCustomTrackEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceDataStreamCustomTrackEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceDataStreamCustomTrackEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceDataStreamCustomTrackEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceDataStreamCustomTrackEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceDataStreamCustomTrackEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceDataStreamCustomTrackEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityCreateEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityCreateEntityArgs {
  /// The entity type as defined by the user
  entity_type: String,
  /// The entity's data as a json string
  json_entity_data: String,
  /// The entity's access control list as json. A null acl implies default
  /// permissions which make the entity readable/writeable by only the user.
  json_entity_acl: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityCreateEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityCreateEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityCreateEntityArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityCreateEntityArgs.json_entity_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityCreateEntityArgs.json_entity_acl", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityCreateEntityArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceEntityCreateEntityArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_acl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_CreateEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 2))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityAcl", TType::String, 3))?;
    o_prot.write_string(&self.json_entity_acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityCreateEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityCreateEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityCreateEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityCreateEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityCreateEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityCreateEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityCreateEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetEntitiesByTypeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetEntitiesByTypeArgs {
  /// The entity type to search for
  entity_type: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetEntitiesByTypeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetEntitiesByTypeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetEntitiesByTypeArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetEntitiesByTypeArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEntityGetEntitiesByTypeArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetEntitiesByType_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetEntitiesByTypeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetEntitiesByTypeResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetEntitiesByTypeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetEntitiesByTypeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetEntitiesByTypeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetEntitiesByTypeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetEntitiesByType"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityUpdateEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityUpdateEntityArgs {
  /// The id of the entity to update
  entity_id: String,
  /// The entity type as defined by the user
  entity_type: String,
  /// The entity's data as a json string.
  json_entity_data: String,
  /// The entity's access control list as json. A null acl implies default
  /// permissions which make the entity readable/writeable by only the user.
  json_entity_acl: String,
  /// Current version of the entity. If the version of the
  /// entity on the server does not match the version passed in, the
  /// server operation will fail. Use -1 to skip version checking.
  version: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityUpdateEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityUpdateEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateEntityArgs.entity_type", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateEntityArgs.json_entity_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateEntityArgs.json_entity_acl", &f_4)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateEntityArgs.version", &f_5)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateEntityArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceEntityUpdateEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_acl: f_4.expect("auto-generated code should have checked for presence of required fields"),
      version: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_UpdateEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 2))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 3))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityAcl", TType::String, 4))?;
    o_prot.write_string(&self.json_entity_acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 5))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityUpdateEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityUpdateEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityUpdateEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityUpdateEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityUpdateEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityUpdateEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityUpdateEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityUpdateSharedEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityUpdateSharedEntityArgs {
  /// The id of the entity to update
  entity_id: String,
  /// The id of the entity's owner
  target_profile_id: String,
  /// The entity type as defined by the user
  entity_type: String,
  /// The entity's data as a json string.
  json_entity_data: String,
  /// Current version of the entity. If the version of the
  /// entity on the server does not match the version passed in, the
  /// server operation will fail. Use -1 to skip version checking.
  version: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityUpdateSharedEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityUpdateSharedEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSharedEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSharedEntityArgs.target_profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSharedEntityArgs.entity_type", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSharedEntityArgs.json_entity_data", &f_4)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSharedEntityArgs.version", &f_5)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSharedEntityArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceEntityUpdateSharedEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      target_profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      entity_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      version: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_UpdateSharedEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("targetProfileId", TType::String, 2))?;
    o_prot.write_string(&self.target_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 3))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 4))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 5))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityUpdateSharedEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityUpdateSharedEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityUpdateSharedEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityUpdateSharedEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityUpdateSharedEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityUpdateSharedEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityUpdateSharedEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityDeleteEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityDeleteEntityArgs {
  /// The id of the entity to update
  entity_id: String,
  /// Current version of the entity. If the version of the
  /// entity on the server does not match the version passed in, the
  /// server operation will fail. Use -1 to skip version checking.
  version: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityDeleteEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityDeleteEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityDeleteEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityDeleteEntityArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityDeleteEntityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceEntityDeleteEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_DeleteEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityDeleteEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityDeleteEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityDeleteEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityDeleteEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityDeleteEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityDeleteEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityDeleteEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityUpdateSingletonArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityUpdateSingletonArgs {
  /// The entity type as defined by the user
  entity_type: String,
  /// The entity's data as a json string.
  json_entity_data: String,
  /// The entity's access control list as json. A null acl implies default
  json_entity_acl: String,
  /// Current version of the entity. If the version of the
  /// entity on the server does not match the version passed in, the
  /// server operation will fail. Use -1 to skip version checking.
  version: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityUpdateSingletonArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityUpdateSingletonArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSingletonArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSingletonArgs.json_entity_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSingletonArgs.json_entity_acl", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSingletonArgs.version", &f_4)?;
    verify_required_field_exists("BrainCloudServiceEntityUpdateSingletonArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceEntityUpdateSingletonArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_acl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      version: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_UpdateSingleton_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 2))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityAcl", TType::String, 3))?;
    o_prot.write_string(&self.json_entity_acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 4))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityUpdateSingletonResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityUpdateSingletonResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityUpdateSingletonResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityUpdateSingletonResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityUpdateSingletonResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityUpdateSingletonResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityUpdateSingleton"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityDeleteSingletonArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityDeleteSingletonArgs {
  /// The entity type as defined by the user
  entity_type: String,
  /// Current version of the entity. If the version of the
  /// entity on the server does not match the version passed in, the
  /// server operation will fail. Use -1 to skip version checking.
  version: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityDeleteSingletonArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityDeleteSingletonArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityDeleteSingletonArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityDeleteSingletonArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityDeleteSingletonArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceEntityDeleteSingletonArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_DeleteSingleton_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityDeleteSingletonResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityDeleteSingletonResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityDeleteSingletonResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityDeleteSingletonResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityDeleteSingletonResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityDeleteSingletonResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityDeleteSingleton"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetEntityArgs {
  /// The id of the entity
  entity_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetEntityArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEntityGetEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetSingletonArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSingletonArgs {
  /// The entity type as defined by the user
  entity_type: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetSingletonArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSingletonArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetSingletonArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSingletonArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEntityGetSingletonArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetSingleton_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetSingletonResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSingletonResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetSingletonResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSingletonResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetSingletonResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetSingletonResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetSingleton"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetSharedEntityForProfileIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSharedEntityForProfileIdArgs {
  /// The the profile ID of the user who owns the entity
  profile_id: String,
  /// The ID of the entity that will be retrieved
  entity_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetSharedEntityForProfileIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSharedEntityForProfileIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntityForProfileIdArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntityForProfileIdArgs.entity_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntityForProfileIdArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceEntityGetSharedEntityForProfileIdArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetSharedEntityForProfileId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 2))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetSharedEntityForProfileIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSharedEntityForProfileIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetSharedEntityForProfileIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSharedEntityForProfileIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetSharedEntityForProfileIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetSharedEntityForProfileIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetSharedEntityForProfileId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs {
  /// The profile id to retrieve shared entities for
  profile_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEntityGetSharedEntitiesForProfileIdArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetSharedEntitiesForProfileId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetSharedEntitiesForProfileIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetSharedEntitiesForProfileId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetListArgs {
  /// Mongo style query string
  where_json: String,
  /// Sort order
  order_by_json: String,
  /// The maximum number of entities to return
  max_return: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetListArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetListArgs.where_json", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetListArgs.order_by_json", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityGetListArgs.max_return", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityGetListArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceEntityGetListArgs {
      where_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
      order_by_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_return: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("whereJson", TType::String, 1))?;
    o_prot.write_string(&self.where_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("orderByJson", TType::String, 2))?;
    o_prot.write_string(&self.order_by_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxReturn", TType::I32, 3))?;
    o_prot.write_i32(self.max_return)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetListResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetListResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetListResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetList"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs {
  /// The profile ID to retrieve shared entities for
  profile_id: String,
  /// Mongo style query string
  where_json: String,
  /// Sort order
  order_by_json: String,
  /// The maximum number of entities to return
  max_return: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs.where_json", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs.order_by_json", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs.max_return", &f_4)?;
    verify_required_field_exists("BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceEntityGetSharedEntitiesListForProfileIdArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      where_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      order_by_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      max_return: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetSharedEntitiesListForProfileId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("whereJson", TType::String, 2))?;
    o_prot.write_string(&self.where_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("orderByJson", TType::String, 3))?;
    o_prot.write_string(&self.order_by_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxReturn", TType::I32, 4))?;
    o_prot.write_i32(self.max_return)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetSharedEntitiesListForProfileIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetSharedEntitiesListForProfileId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetListCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetListCountArgs {
  /// Mongo style query string
  where_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetListCountArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetListCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetListCountArgs.where_json", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetListCountArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEntityGetListCountArgs {
      where_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetListCount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("whereJson", TType::String, 1))?;
    o_prot.write_string(&self.where_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetListCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetListCountResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetListCountResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetListCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetListCountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetListCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetListCount"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetPageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetPageArgs {
  /// The json context for the page request.
  /// See the portal appendix documentation for format
  json_context: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetPageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetPageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetPageArgs.json_context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetPageArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEntityGetPageArgs {
      json_context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetPage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonContext", TType::String, 1))?;
    o_prot.write_string(&self.json_context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetPageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetPageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetPageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetPageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetPageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetPageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetPage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityGetPageOffsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetPageOffsetArgs {
  /// The context string returned from the server from a previous call
  /// to GetPage() or GetPageOffset()
  context: String,
  /// The positive or negative page offset to fetch. Uses the last page
  /// retrieved using the context string to determine a starting point.
  page_offset: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityGetPageOffsetArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetPageOffsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityGetPageOffsetArgs.context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityGetPageOffsetArgs.page_offset", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityGetPageOffsetArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceEntityGetPageOffsetArgs {
      context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_offset: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_GetPageOffset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("context", TType::String, 1))?;
    o_prot.write_string(&self.context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageOffset", TType::I32, 2))?;
    o_prot.write_i32(self.page_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityGetPageOffsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityGetPageOffsetResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityGetPageOffsetResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityGetPageOffsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityGetPageOffsetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityGetPageOffsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityGetPageOffset"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityIncrementUserEntityDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityIncrementUserEntityDataArgs {
  /// The entity to increment
  entity_id: String,
  /// The subset of data to increment
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityIncrementUserEntityDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityIncrementUserEntityDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementUserEntityDataArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementUserEntityDataArgs.json_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementUserEntityDataArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceEntityIncrementUserEntityDataArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_IncrementUserEntityData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 2))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityIncrementUserEntityDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityIncrementUserEntityDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityIncrementUserEntityDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityIncrementUserEntityDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityIncrementUserEntityDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityIncrementUserEntityDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityIncrementUserEntityData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEntityIncrementSharedUserEntityDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityIncrementSharedUserEntityDataArgs {
  /// The entity to increment
  entity_id: String,
  /// Profile ID of the entity owner
  target_profile_id: String,
  /// The subset of data to increment
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEntityIncrementSharedUserEntityDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityIncrementSharedUserEntityDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementSharedUserEntityDataArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementSharedUserEntityDataArgs.target_profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementSharedUserEntityDataArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEntityIncrementSharedUserEntityDataArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceEntityIncrementSharedUserEntityDataArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      target_profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Entity_IncrementSharedUserEntityData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("targetProfileId", TType::String, 2))?;
    o_prot.write_string(&self.target_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEntityIncrementSharedUserEntityDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEntityIncrementSharedUserEntityDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEntityIncrementSharedUserEntityDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEntityIncrementSharedUserEntityDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEntityIncrementSharedUserEntityDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEntityIncrementSharedUserEntityDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEntityIncrementSharedUserEntityData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEventSendEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventSendEventArgs {
  /// The id of the user who is being sent the event
  to_profile_id: String,
  /// The user-defined type of the event.
  event_type: String,
  /// The user-defined data for this event encoded in JSON.
  json_event_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEventSendEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventSendEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEventSendEventArgs.to_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEventSendEventArgs.event_type", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEventSendEventArgs.json_event_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceEventSendEventArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceEventSendEventArgs {
      to_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_event_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Event_SendEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toProfileId", TType::String, 1))?;
    o_prot.write_string(&self.to_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::String, 2))?;
    o_prot.write_string(&self.event_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEventData", TType::String, 3))?;
    o_prot.write_string(&self.json_event_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEventSendEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventSendEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEventSendEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventSendEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEventSendEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEventSendEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEventSendEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEventUpdateIncomingEventDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventUpdateIncomingEventDataArgs {
  /// The event id
  ev_id: String,
  /// The user-defined data for this event encoded in JSON.
  json_event_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEventUpdateIncomingEventDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventUpdateIncomingEventDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEventUpdateIncomingEventDataArgs.ev_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEventUpdateIncomingEventDataArgs.json_event_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceEventUpdateIncomingEventDataArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceEventUpdateIncomingEventDataArgs {
      ev_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_event_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Event_UpdateIncomingEventData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("evId", TType::String, 1))?;
    o_prot.write_string(&self.ev_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEventData", TType::String, 2))?;
    o_prot.write_string(&self.json_event_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEventUpdateIncomingEventDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventUpdateIncomingEventDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEventUpdateIncomingEventDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventUpdateIncomingEventDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEventUpdateIncomingEventDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEventUpdateIncomingEventDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEventUpdateIncomingEventData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEventDeleteIncomingEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventDeleteIncomingEventArgs {
  /// The event id
  ev_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEventDeleteIncomingEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventDeleteIncomingEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEventDeleteIncomingEventArgs.ev_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceEventDeleteIncomingEventArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceEventDeleteIncomingEventArgs {
      ev_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Event_DeleteIncomingEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("evId", TType::String, 1))?;
    o_prot.write_string(&self.ev_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEventDeleteIncomingEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventDeleteIncomingEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEventDeleteIncomingEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventDeleteIncomingEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEventDeleteIncomingEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEventDeleteIncomingEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEventDeleteIncomingEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceEventGetEventsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventGetEventsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceEventGetEventsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventGetEventsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceEventGetEventsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceEventGetEventsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Event_GetEvents_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceEventGetEventsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceEventGetEventsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceEventGetEventsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceEventGetEventsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceEventGetEventsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceEventGetEventsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceEventGetEvents"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileUploadFileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileUploadFileArgs {
  /// The desired cloud path of the file
  cloud_path: String,
  /// The desired cloud fileName of the file
  cloud_filename: String,
  /// True if the file is shareable
  shareable: bool,
  /// Whether to replace file if it exists
  replace_if_exists: bool,
  /// The path and fileName of the local file
  local_path: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileUploadFileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileUploadFileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileUploadFileArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileUploadFileArgs.cloud_filename", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileUploadFileArgs.shareable", &f_3)?;
    verify_required_field_exists("BrainCloudServiceFileUploadFileArgs.replace_if_exists", &f_4)?;
    verify_required_field_exists("BrainCloudServiceFileUploadFileArgs.local_path", &f_5)?;
    verify_required_field_exists("BrainCloudServiceFileUploadFileArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceFileUploadFileArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cloud_filename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      shareable: f_3.expect("auto-generated code should have checked for presence of required fields"),
      replace_if_exists: f_4.expect("auto-generated code should have checked for presence of required fields"),
      local_path: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_UploadFile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudFilename", TType::String, 2))?;
    o_prot.write_string(&self.cloud_filename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("shareable", TType::Bool, 3))?;
    o_prot.write_bool(self.shareable)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replaceIfExists", TType::Bool, 4))?;
    o_prot.write_bool(self.replace_if_exists)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("localPath", TType::String, 5))?;
    o_prot.write_string(&self.local_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileUploadFileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileUploadFileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileUploadFileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileUploadFileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileUploadFileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileUploadFileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileUploadFile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileCancelUploadArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileCancelUploadArgs {
  /// Upload ID of the file to cancel
  upload_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileCancelUploadArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileCancelUploadArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileCancelUploadArgs.upload_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileCancelUploadArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFileCancelUploadArgs {
      upload_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_CancelUpload_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uploadId", TType::String, 1))?;
    o_prot.write_string(&self.upload_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileCancelUploadResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileCancelUploadResult {
}

impl BrainCloudServiceFileCancelUploadResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileCancelUploadResult> {
    i_prot.read_struct_begin()?;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileCancelUploadResult {};
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileCancelUploadResult");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<()> {
    Ok(())
  }
}

//
// BrainCloudServiceFileGetUploadProgressArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetUploadProgressArgs {
  /// The id of the upload
  upload_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileGetUploadProgressArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetUploadProgressArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileGetUploadProgressArgs.upload_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileGetUploadProgressArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFileGetUploadProgressArgs {
      upload_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_GetUploadProgress_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uploadId", TType::String, 1))?;
    o_prot.write_string(&self.upload_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileGetUploadProgressResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetUploadProgressResult {
  result_value: Option<OrderedFloat<f64>>,
}

impl BrainCloudServiceFileGetUploadProgressResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetUploadProgressResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<OrderedFloat<f64>> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = OrderedFloat::from(i_prot.read_double()?);
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileGetUploadProgressResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileGetUploadProgressResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::Double, 0))?;
      o_prot.write_double(fld_var.into())?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<OrderedFloat<f64>> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileGetUploadProgress"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileGetUploadBytesTransferredArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetUploadBytesTransferredArgs {
  /// The id of the upload
  upload_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileGetUploadBytesTransferredArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetUploadBytesTransferredArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileGetUploadBytesTransferredArgs.upload_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileGetUploadBytesTransferredArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFileGetUploadBytesTransferredArgs {
      upload_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_GetUploadBytesTransferred_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uploadId", TType::String, 1))?;
    o_prot.write_string(&self.upload_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileGetUploadBytesTransferredResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetUploadBytesTransferredResult {
  result_value: Option<i64>,
}

impl BrainCloudServiceFileGetUploadBytesTransferredResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetUploadBytesTransferredResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileGetUploadBytesTransferredResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileGetUploadBytesTransferredResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileGetUploadBytesTransferred"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileGetUploadTotalBytesToTransferArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetUploadTotalBytesToTransferArgs {
  /// The id of the upload
  upload_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileGetUploadTotalBytesToTransferArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetUploadTotalBytesToTransferArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileGetUploadTotalBytesToTransferArgs.upload_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileGetUploadTotalBytesToTransferArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFileGetUploadTotalBytesToTransferArgs {
      upload_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_GetUploadTotalBytesToTransfer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("uploadId", TType::String, 1))?;
    o_prot.write_string(&self.upload_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileGetUploadTotalBytesToTransferResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetUploadTotalBytesToTransferResult {
  result_value: Option<i64>,
}

impl BrainCloudServiceFileGetUploadTotalBytesToTransferResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetUploadTotalBytesToTransferResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<i64> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_i64()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileGetUploadTotalBytesToTransferResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileGetUploadTotalBytesToTransferResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::I64, 0))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<i64> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileGetUploadTotalBytesToTransfer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileListUserFilesSFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileListUserFilesSFOArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileListUserFilesSFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileListUserFilesSFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileListUserFilesSFOArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceFileListUserFilesSFOArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_ListUserFiles_SFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileListUserFilesSFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileListUserFilesSFOResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileListUserFilesSFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileListUserFilesSFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileListUserFilesSFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileListUserFilesSFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileListUserFilesSFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileListUserFilesSNSFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileListUserFilesSNSFOArgs {
  /// File path
  cloud_path: String,
  /// Whether to recurse down the path
  recurse: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileListUserFilesSNSFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileListUserFilesSNSFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileListUserFilesSNSFOArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileListUserFilesSNSFOArgs.recurse", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileListUserFilesSNSFOArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFileListUserFilesSNSFOArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      recurse: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_ListUserFiles_SNSFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("recurse", TType::Bool, 2))?;
    o_prot.write_bool(self.recurse)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileListUserFilesSNSFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileListUserFilesSNSFOResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileListUserFilesSNSFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileListUserFilesSNSFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileListUserFilesSNSFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileListUserFilesSNSFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileListUserFilesSNSFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileDeleteUserFileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileDeleteUserFileArgs {
  /// File path
  cloud_path: String,
  cloud_file_name: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileDeleteUserFileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileDeleteUserFileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileDeleteUserFileArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileDeleteUserFileArgs.cloud_file_name", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileDeleteUserFileArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFileDeleteUserFileArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cloud_file_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_DeleteUserFile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudFileName", TType::String, 2))?;
    o_prot.write_string(&self.cloud_file_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileDeleteUserFileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileDeleteUserFileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileDeleteUserFileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileDeleteUserFileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileDeleteUserFileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileDeleteUserFileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileDeleteUserFile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileDeleteUserFilesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileDeleteUserFilesArgs {
  /// File path
  cloud_path: String,
  /// Whether to recurse down the path
  recurse: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileDeleteUserFilesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileDeleteUserFilesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileDeleteUserFilesArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileDeleteUserFilesArgs.recurse", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileDeleteUserFilesArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFileDeleteUserFilesArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      recurse: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_DeleteUserFiles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("recurse", TType::Bool, 2))?;
    o_prot.write_bool(self.recurse)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileDeleteUserFilesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileDeleteUserFilesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileDeleteUserFilesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileDeleteUserFilesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileDeleteUserFilesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileDeleteUserFilesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileDeleteUserFiles"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileGetCDNUrlArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetCDNUrlArgs {
  /// File path
  cloud_path: String,
  /// Name of file
  cloud_filename: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileGetCDNUrlArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetCDNUrlArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileGetCDNUrlArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileGetCDNUrlArgs.cloud_filename", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileGetCDNUrlArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFileGetCDNUrlArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cloud_filename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_GetCDNUrl_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudFilename", TType::String, 2))?;
    o_prot.write_string(&self.cloud_filename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileGetCDNUrlResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetCDNUrlResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileGetCDNUrlResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetCDNUrlResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileGetCDNUrlResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileGetCDNUrlResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileGetCDNUrl"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendFindUserByUniversalIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendFindUserByUniversalIdArgs {
  search_text: String,
  max_results: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendFindUserByUniversalIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendFindUserByUniversalIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendFindUserByUniversalIdArgs.search_text", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendFindUserByUniversalIdArgs.max_results", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFriendFindUserByUniversalIdArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFriendFindUserByUniversalIdArgs {
      search_text: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_results: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_FindUserByUniversalId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("searchText", TType::String, 1))?;
    o_prot.write_string(&self.search_text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxResults", TType::I32, 2))?;
    o_prot.write_i32(self.max_results)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendFindUserByUniversalIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendFindUserByUniversalIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendFindUserByUniversalIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendFindUserByUniversalIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendFindUserByUniversalIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendFindUserByUniversalIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendFindUserByUniversalId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendReadFriendEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendReadFriendEntityArgs {
  /// Id of entity to retrieve.
  entity_id: String,
  /// Profile Id of friend who owns entity.
  friend_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendReadFriendEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendReadFriendEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendEntityArgs.friend_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendEntityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFriendReadFriendEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      friend_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_ReadFriendEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("friendId", TType::String, 2))?;
    o_prot.write_string(&self.friend_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendReadFriendEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendReadFriendEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendReadFriendEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendReadFriendEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendReadFriendEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendReadFriendEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendReadFriendEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendReadFriendsEntitiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendReadFriendsEntitiesArgs {
  /// Types of entities to retrieve.
  entity_type: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendReadFriendsEntitiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendReadFriendsEntitiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendsEntitiesArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendsEntitiesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendReadFriendsEntitiesArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_ReadFriendsEntities_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendReadFriendsEntitiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendReadFriendsEntitiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendReadFriendsEntitiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendReadFriendsEntitiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendReadFriendsEntitiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendReadFriendsEntitiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendReadFriendsEntities"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendReadFriendUserStateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendReadFriendUserStateArgs {
  /// Profile Id of friend to retrieve user state for.
  friend_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendReadFriendUserStateArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendReadFriendUserStateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendUserStateArgs.friend_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendReadFriendUserStateArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendReadFriendUserStateArgs {
      friend_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_ReadFriendUserState_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("friendId", TType::String, 1))?;
    o_prot.write_string(&self.friend_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendReadFriendUserStateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendReadFriendUserStateResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendReadFriendUserStateResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendReadFriendUserStateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendReadFriendUserStateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendReadFriendUserStateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendReadFriendUserState"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForProfileIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForProfileIdArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendGetSummaryDataForProfileIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForProfileIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendGetSummaryDataForProfileIdArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendGetSummaryDataForProfileIdArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendGetSummaryDataForProfileIdArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_GetSummaryDataForProfileId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForProfileIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForProfileIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendGetSummaryDataForProfileIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForProfileIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendGetSummaryDataForProfileIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendGetSummaryDataForProfileIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendGetSummaryDataForProfileId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs {
  /// Player Ids of users to retrieve player state for.
  player_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_2 = i_prot.read_string()?;
            val.push(list_elem_2);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs.player_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendGetSummaryDataForProfileIdsArgs {
      player_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_GetSummaryDataForProfileIds_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.player_ids.len() as i32))?;
    for e in &self.player_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForProfileIdsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForProfileIdsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendGetSummaryDataForProfileIdsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForProfileIdsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendGetSummaryDataForProfileIdsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendGetSummaryDataForProfileIdsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendGetSummaryDataForProfileIds"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForFriendsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForFriendsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendGetSummaryDataForFriendsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForFriendsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendGetSummaryDataForFriendsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceFriendGetSummaryDataForFriendsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_GetSummaryDataForFriends_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForFriendsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForFriendsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendGetSummaryDataForFriendsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForFriendsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendGetSummaryDataForFriendsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendGetSummaryDataForFriendsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendGetSummaryDataForFriends"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_GetSummaryDataForRecentlyMetPlayers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendGetSummaryDataForRecentlyMetPlayers"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendFindUsersByExactNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendFindUsersByExactNameArgs {
  /// The string to search for.
  search_text: String,
  /// Maximum number of results to return.
  max_results: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendFindUsersByExactNameArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendFindUsersByExactNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendFindUsersByExactNameArgs.search_text", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendFindUsersByExactNameArgs.max_results", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFriendFindUsersByExactNameArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFriendFindUsersByExactNameArgs {
      search_text: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_results: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_FindUsersByExactName_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("searchText", TType::String, 1))?;
    o_prot.write_string(&self.search_text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxResults", TType::I32, 2))?;
    o_prot.write_i32(self.max_results)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendFindUsersByExactNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendFindUsersByExactNameResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendFindUsersByExactNameResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendFindUsersByExactNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendFindUsersByExactNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendFindUsersByExactNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendFindUsersByExactName"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendFindUsersBySubstrNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendFindUsersBySubstrNameArgs {
  /// The substring to search for. Minimum length of 3 characters.
  search_text: String,
  /// Maximum number of results to return.
  max_results: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendFindUsersBySubstrNameArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendFindUsersBySubstrNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendFindUsersBySubstrNameArgs.search_text", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendFindUsersBySubstrNameArgs.max_results", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFriendFindUsersBySubstrNameArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFriendFindUsersBySubstrNameArgs {
      search_text: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_results: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_FindUsersBySubstrName_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("searchText", TType::String, 1))?;
    o_prot.write_string(&self.search_text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxResults", TType::I32, 2))?;
    o_prot.write_i32(self.max_results)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendFindUsersBySubstrNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendFindUsersBySubstrNameResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendFindUsersBySubstrNameResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendFindUsersBySubstrNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendFindUsersBySubstrNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendFindUsersBySubstrNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendFindUsersBySubstrName"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendListFriendsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendListFriendsArgs {
  /// Friend platform to query.
  friend_platform: brain_cloud_service_s_d_k_data_types::FriendPlatform,
  /// True if including summary data; false otherwise.
  include_summary_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendListFriendsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendListFriendsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<brain_cloud_service_s_d_k_data_types::FriendPlatform> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = brain_cloud_service_s_d_k_data_types::FriendPlatform::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendListFriendsArgs.friend_platform", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendListFriendsArgs.include_summary_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFriendListFriendsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFriendListFriendsArgs {
      friend_platform: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_summary_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_ListFriends_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("friendPlatform", TType::I32, 1))?;
    self.friend_platform.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeSummaryData", TType::Bool, 2))?;
    o_prot.write_bool(self.include_summary_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendListFriendsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendListFriendsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendListFriendsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendListFriendsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendListFriendsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendListFriendsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendListFriends"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendAddFriendsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendAddFriendsArgs {
  /// Collection of profile IDs.
  profile_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendAddFriendsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendAddFriendsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_3 = i_prot.read_string()?;
            val.push(list_elem_3);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendAddFriendsArgs.profile_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendAddFriendsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendAddFriendsArgs {
      profile_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_AddFriends_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.profile_ids.len() as i32))?;
    for e in &self.profile_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendAddFriendsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendAddFriendsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendAddFriendsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendAddFriendsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendAddFriendsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendAddFriendsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendAddFriends"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendRemoveFriendsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendRemoveFriendsArgs {
  /// Collection of profile IDs.
  profile_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendRemoveFriendsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendRemoveFriendsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_4 = i_prot.read_string()?;
            val.push(list_elem_4);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendRemoveFriendsArgs.profile_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendRemoveFriendsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendRemoveFriendsArgs {
      profile_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_RemoveFriends_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.profile_ids.len() as i32))?;
    for e in &self.profile_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendRemoveFriendsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendRemoveFriendsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendRemoveFriendsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendRemoveFriendsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendRemoveFriendsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendRemoveFriendsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendRemoveFriends"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendGetUsersOnlineStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetUsersOnlineStatusArgs {
  /// Collection of profile IDs.
  profile_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendGetUsersOnlineStatusArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetUsersOnlineStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_5 = i_prot.read_string()?;
            val.push(list_elem_5);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendGetUsersOnlineStatusArgs.profile_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendGetUsersOnlineStatusArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendGetUsersOnlineStatusArgs {
      profile_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_GetUsersOnlineStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.profile_ids.len() as i32))?;
    for e in &self.profile_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendGetUsersOnlineStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendGetUsersOnlineStatusResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendGetUsersOnlineStatusResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendGetUsersOnlineStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendGetUsersOnlineStatusResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendGetUsersOnlineStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendGetUsersOnlineStatus"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendSendFriendInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendSendFriendInvitationArgs {
  to_player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendSendFriendInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendSendFriendInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendSendFriendInvitationArgs.to_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendSendFriendInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendSendFriendInvitationArgs {
      to_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_SendFriendInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.to_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendSendFriendInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendSendFriendInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendSendFriendInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendSendFriendInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendSendFriendInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendSendFriendInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendSendFriendInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendListFriendInvitationsReceivedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendListFriendInvitationsReceivedArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendListFriendInvitationsReceivedArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendListFriendInvitationsReceivedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendListFriendInvitationsReceivedArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceFriendListFriendInvitationsReceivedArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_ListFriendInvitationsReceived_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendListFriendInvitationsReceivedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendListFriendInvitationsReceivedResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendListFriendInvitationsReceivedResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendListFriendInvitationsReceivedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendListFriendInvitationsReceivedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendListFriendInvitationsReceivedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendListFriendInvitationsReceived"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendListFriendInvitationsSentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendListFriendInvitationsSentArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendListFriendInvitationsSentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendListFriendInvitationsSentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendListFriendInvitationsSentArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceFriendListFriendInvitationsSentArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_ListFriendInvitationsSent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendListFriendInvitationsSentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendListFriendInvitationsSentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendListFriendInvitationsSentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendListFriendInvitationsSentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendListFriendInvitationsSentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendListFriendInvitationsSentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendListFriendInvitationsSent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendAcceptFriendInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendAcceptFriendInvitationArgs {
  from_player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendAcceptFriendInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendAcceptFriendInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendAcceptFriendInvitationArgs.from_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendAcceptFriendInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendAcceptFriendInvitationArgs {
      from_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_AcceptFriendInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fromPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.from_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendAcceptFriendInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendAcceptFriendInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendAcceptFriendInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendAcceptFriendInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendAcceptFriendInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendAcceptFriendInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendAcceptFriendInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendRejectFriendInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendRejectFriendInvitationArgs {
  from_player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendRejectFriendInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendRejectFriendInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendRejectFriendInvitationArgs.from_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendRejectFriendInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendRejectFriendInvitationArgs {
      from_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_RejectFriendInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fromPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.from_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendRejectFriendInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendRejectFriendInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendRejectFriendInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendRejectFriendInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendRejectFriendInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendRejectFriendInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendRejectFriendInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFriendRemoveFriendArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendRemoveFriendArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFriendRemoveFriendArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendRemoveFriendArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFriendRemoveFriendArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFriendRemoveFriendArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceFriendRemoveFriendArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Friend_RemoveFriend_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFriendRemoveFriendResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFriendRemoveFriendResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFriendRemoveFriendResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFriendRemoveFriendResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFriendRemoveFriendResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFriendRemoveFriendResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFriendRemoveFriend"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadAllGamificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadAllGamificationArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadAllGamificationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadAllGamificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadAllGamificationArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadAllGamificationArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadAllGamificationArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadAllGamification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadAllGamificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadAllGamificationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadAllGamificationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadAllGamificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadAllGamificationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadAllGamificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadAllGamification"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadMilestonesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadMilestonesArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadMilestonesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadMilestonesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadMilestonesArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadMilestonesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadMilestonesArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadMilestones_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadMilestonesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadMilestonesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadMilestonesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadMilestonesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadMilestonesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadMilestonesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadMilestones"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadAchievementsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadAchievementsArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadAchievementsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadAchievementsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadAchievementsArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadAchievementsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadAchievementsArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadAchievements_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadAchievementsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadAchievementsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadAchievementsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadAchievementsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadAchievementsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadAchievementsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadAchievements"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadXpLevelsMetaDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadXpLevelsMetaDataArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadXpLevelsMetaDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadXpLevelsMetaDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadXpLevelsMetaDataArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceGamificationReadXpLevelsMetaDataArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadXpLevelsMetaData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadXpLevelsMetaDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadXpLevelsMetaDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadXpLevelsMetaDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadXpLevelsMetaDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadXpLevelsMetaDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadXpLevelsMetaDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadXpLevelsMetaData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadAchievedAchievementsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadAchievedAchievementsArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadAchievedAchievementsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadAchievedAchievementsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadAchievedAchievementsArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadAchievedAchievementsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadAchievedAchievementsArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadAchievedAchievements_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadAchievedAchievementsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadAchievedAchievementsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadAchievedAchievementsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadAchievedAchievementsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadAchievedAchievementsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadAchievedAchievementsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadAchievedAchievements"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadCompletedMilestonesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadCompletedMilestonesArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadCompletedMilestonesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadCompletedMilestonesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadCompletedMilestonesArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadCompletedMilestonesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadCompletedMilestonesArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadCompletedMilestones_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadCompletedMilestonesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadCompletedMilestonesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadCompletedMilestonesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadCompletedMilestonesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadCompletedMilestonesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadCompletedMilestonesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadCompletedMilestones"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadInProgressMilestonesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadInProgressMilestonesArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadInProgressMilestonesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadInProgressMilestonesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadInProgressMilestonesArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadInProgressMilestonesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadInProgressMilestonesArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadInProgressMilestones_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadInProgressMilestonesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadInProgressMilestonesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadInProgressMilestonesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadInProgressMilestonesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadInProgressMilestonesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadInProgressMilestonesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadInProgressMilestones"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadMilestonesByCategoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadMilestonesByCategoryArgs {
  /// The milestone category
  category: String,
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadMilestonesByCategoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadMilestonesByCategoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadMilestonesByCategoryArgs.category", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadMilestonesByCategoryArgs.include_meta_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadMilestonesByCategoryArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGamificationReadMilestonesByCategoryArgs {
      category: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_meta_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadMilestonesByCategory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 2))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadMilestonesByCategoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadMilestonesByCategoryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadMilestonesByCategoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadMilestonesByCategoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadMilestonesByCategoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadMilestonesByCategoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadMilestonesByCategory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationAwardAchievementsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationAwardAchievementsArgs {
  /// A collection of achievement ids to award
  achievement_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationAwardAchievementsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationAwardAchievementsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = i_prot.read_string()?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationAwardAchievementsArgs.achievement_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationAwardAchievementsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationAwardAchievementsArgs {
      achievement_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_AwardAchievements_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("achievementIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.achievement_ids.len() as i32))?;
    for e in &self.achievement_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationAwardAchievementsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationAwardAchievementsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationAwardAchievementsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationAwardAchievementsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationAwardAchievementsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationAwardAchievementsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationAwardAchievements"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadQuestsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadQuestsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadQuestsArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadQuests_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadQuestsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadQuestsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadQuestsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadQuestsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadQuests"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadCompletedQuestsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadCompletedQuestsArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadCompletedQuestsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadCompletedQuestsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadCompletedQuestsArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadCompletedQuestsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadCompletedQuestsArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadCompletedQuests_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadCompletedQuestsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadCompletedQuestsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadCompletedQuestsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadCompletedQuestsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadCompletedQuestsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadCompletedQuestsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadCompletedQuests"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadInProgressQuestsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadInProgressQuestsArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadInProgressQuestsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadInProgressQuestsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadInProgressQuestsArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadInProgressQuestsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadInProgressQuestsArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadInProgressQuests_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadInProgressQuestsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadInProgressQuestsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadInProgressQuestsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadInProgressQuestsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadInProgressQuestsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadInProgressQuestsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadInProgressQuests"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadNotStartedQuestsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadNotStartedQuestsArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadNotStartedQuestsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadNotStartedQuestsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadNotStartedQuestsArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadNotStartedQuestsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadNotStartedQuestsArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadNotStartedQuests_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadNotStartedQuestsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadNotStartedQuestsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadNotStartedQuestsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadNotStartedQuestsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadNotStartedQuestsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadNotStartedQuestsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadNotStartedQuests"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadQuestsWithStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsWithStatusArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadQuestsWithStatusArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsWithStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsWithStatusArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsWithStatusArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadQuestsWithStatusArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadQuestsWithStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadQuestsWithStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsWithStatusResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadQuestsWithStatusResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsWithStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadQuestsWithStatusResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadQuestsWithStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadQuestsWithStatus"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadQuestsWithBasicPercentageArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadQuestsWithBasicPercentage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadQuestsWithBasicPercentageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadQuestsWithBasicPercentage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs {
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs.include_meta_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationReadQuestsWithComplexPercentageArgs {
      include_meta_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadQuestsWithComplexPercentage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadQuestsWithComplexPercentageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadQuestsWithComplexPercentage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationReadQuestsByCategoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsByCategoryArgs {
  /// The quest category
  category: String,
  include_meta_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationReadQuestsByCategoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsByCategoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsByCategoryArgs.category", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsByCategoryArgs.include_meta_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGamificationReadQuestsByCategoryArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGamificationReadQuestsByCategoryArgs {
      category: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_meta_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ReadQuestsByCategory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeMetaData", TType::Bool, 2))?;
    o_prot.write_bool(self.include_meta_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationReadQuestsByCategoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationReadQuestsByCategoryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationReadQuestsByCategoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationReadQuestsByCategoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationReadQuestsByCategoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationReadQuestsByCategoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationReadQuestsByCategory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGamificationResetMilestonesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationResetMilestonesArgs {
  /// List of milestones to reset
  milestone_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGamificationResetMilestonesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationResetMilestonesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = i_prot.read_string()?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGamificationResetMilestonesArgs.milestone_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGamificationResetMilestonesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGamificationResetMilestonesArgs {
      milestone_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Gamification_ResetMilestones_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("milestoneIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.milestone_ids.len() as i32))?;
    for e in &self.milestone_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGamificationResetMilestonesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGamificationResetMilestonesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGamificationResetMilestonesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGamificationResetMilestonesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGamificationResetMilestonesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGamificationResetMilestonesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGamificationResetMilestones"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalAppReadPropertiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalAppReadPropertiesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalAppReadPropertiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalAppReadPropertiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalAppReadPropertiesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceGlobalAppReadPropertiesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalApp_ReadProperties_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalAppReadPropertiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalAppReadPropertiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalAppReadPropertiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalAppReadPropertiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalAppReadPropertiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalAppReadPropertiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalAppReadProperties"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityCreateEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityCreateEntityArgs {
  /// The entity type as defined by the user
  entity_type: String,
  /// Sets expiry time for entity in milliseconds if > 0
  time_to_live: i64,
  /// The entity's access control list as json. A null acl implies default
  json_entity_acl: String,
  /// The entity's data as a json string
  json_entity_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityCreateEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityCreateEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityArgs.time_to_live", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityArgs.json_entity_acl", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityArgs.json_entity_data", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGlobalEntityCreateEntityArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      time_to_live: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_acl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_CreateEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeToLive", TType::I64, 2))?;
    o_prot.write_i64(self.time_to_live)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityAcl", TType::String, 3))?;
    o_prot.write_string(&self.json_entity_acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 4))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityCreateEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityCreateEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityCreateEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityCreateEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityCreateEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityCreateEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityCreateEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs {
  /// The entity type as defined by the user
  entity_type: String,
  /// A secondary ID that will be indexed
  indexed_id: String,
  /// Sets expiry time for entity in milliseconds if > 0
  time_to_live: i64,
  /// The entity's access control list as json. A null acl implies default
  json_entity_acl: String,
  /// The entity's data as a json string
  json_entity_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs.entity_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs.indexed_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs.time_to_live", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs.json_entity_acl", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs.json_entity_data", &f_5)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdArgs {
      entity_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      indexed_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      time_to_live: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_acl: f_4.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_CreateEntityWithIndexedId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 1))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("indexedId", TType::String, 2))?;
    o_prot.write_string(&self.indexed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeToLive", TType::I64, 3))?;
    o_prot.write_i64(self.time_to_live)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityAcl", TType::String, 4))?;
    o_prot.write_string(&self.json_entity_acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 5))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityCreateEntityWithIndexedIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityCreateEntityWithIndexedId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityArgs {
  /// The entity ID
  entity_id: String,
  /// The version of the entity to update
  version: i32,
  /// The entity's data as a json string
  json_entity_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityUpdateEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityArgs.json_entity_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_UpdateEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityData", TType::String, 3))?;
    o_prot.write_string(&self.json_entity_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityUpdateEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityUpdateEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityUpdateEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityAclArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityAclArgs {
  /// The entity ID
  entity_id: String,
  /// The version of the entity to update
  version: i32,
  /// The entity's access control list as json.
  json_entity_acl: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityUpdateEntityAclArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityAclArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityAclArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityAclArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityAclArgs.json_entity_acl", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityAclArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityAclArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_entity_acl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_UpdateEntityAcl_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonEntityAcl", TType::String, 3))?;
    o_prot.write_string(&self.json_entity_acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityAclResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityAclResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityUpdateEntityAclResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityAclResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityAclResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityUpdateEntityAclResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityUpdateEntityAcl"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs {
  /// The entity ID
  entity_id: String,
  /// The version of the entity to update
  version: i32,
  /// Sets expiry time for entity in milliseconds if > 0
  time_to_live: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs.time_to_live", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      time_to_live: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_UpdateEntityTimeToLive_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timeToLive", TType::I64, 3))?;
    o_prot.write_i64(self.time_to_live)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityUpdateEntityTimeToLiveResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityUpdateEntityTimeToLive"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityDeleteEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityDeleteEntityArgs {
  /// The entity ID
  entity_id: String,
  /// The version of the entity to delete
  version: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityDeleteEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityDeleteEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityDeleteEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityDeleteEntityArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityDeleteEntityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGlobalEntityDeleteEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_DeleteEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I32, 2))?;
    o_prot.write_i32(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityDeleteEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityDeleteEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityDeleteEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityDeleteEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityDeleteEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityDeleteEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityDeleteEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityReadEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityReadEntityArgs {
  /// The entity ID
  entity_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityReadEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityReadEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityReadEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityReadEntityArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalEntityReadEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_ReadEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityReadEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityReadEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityReadEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityReadEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityReadEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityReadEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityReadEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityGetListArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetListArgs {
  /// Mongo style query string
  where_json: String,
  /// Sort order
  order_by_json: String,
  /// The maximum number of entities to return
  max_return: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityGetListArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetListArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListArgs.where_json", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListArgs.order_by_json", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListArgs.max_return", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGlobalEntityGetListArgs {
      where_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
      order_by_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      max_return: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_GetList_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("whereJson", TType::String, 1))?;
    o_prot.write_string(&self.where_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("orderByJson", TType::String, 2))?;
    o_prot.write_string(&self.order_by_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxReturn", TType::I32, 3))?;
    o_prot.write_i32(self.max_return)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityGetListResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetListResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityGetListResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetListResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityGetListResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityGetListResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityGetList"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityGetListByIndexedIdArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetListByIndexedIdArgs {
  /// The entity indexed Id
  entity_indexed_id: String,
  /// The maximum number of entities to return
  max_return: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityGetListByIndexedIdArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetListByIndexedIdArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListByIndexedIdArgs.entity_indexed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListByIndexedIdArgs.max_return", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListByIndexedIdArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGlobalEntityGetListByIndexedIdArgs {
      entity_indexed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_return: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_GetListByIndexedId_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityIndexedId", TType::String, 1))?;
    o_prot.write_string(&self.entity_indexed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxReturn", TType::I32, 2))?;
    o_prot.write_i32(self.max_return)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityGetListByIndexedIdResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetListByIndexedIdResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityGetListByIndexedIdResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetListByIndexedIdResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityGetListByIndexedIdResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityGetListByIndexedIdResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityGetListByIndexedId"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityGetListCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetListCountArgs {
  /// Mongo style query string
  where_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityGetListCountArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetListCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListCountArgs.where_json", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetListCountArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalEntityGetListCountArgs {
      where_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_GetListCount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("whereJson", TType::String, 1))?;
    o_prot.write_string(&self.where_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityGetListCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetListCountResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityGetListCountResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetListCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityGetListCountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityGetListCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityGetListCount"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityGetPageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetPageArgs {
  /// The json context for the page request.
  /// See the portal appendix documentation for format
  json_context: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityGetPageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetPageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetPageArgs.json_context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetPageArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalEntityGetPageArgs {
      json_context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_GetPage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonContext", TType::String, 1))?;
    o_prot.write_string(&self.json_context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityGetPageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetPageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityGetPageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetPageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityGetPageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityGetPageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityGetPage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityGetPageOffsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetPageOffsetArgs {
  /// The context string returned from the server from a previous call
  /// to GetPage() or GetPageOffset()
  context: String,
  /// The positive or negative page offset to fetch. Uses the last page
  /// retrieved using the context string to determine a starting point.
  page_offset: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityGetPageOffsetArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetPageOffsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetPageOffsetArgs.context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetPageOffsetArgs.page_offset", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetPageOffsetArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGlobalEntityGetPageOffsetArgs {
      context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_offset: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_GetPageOffset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("context", TType::String, 1))?;
    o_prot.write_string(&self.context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageOffset", TType::I32, 2))?;
    o_prot.write_i32(self.page_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityGetPageOffsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetPageOffsetResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityGetPageOffsetResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetPageOffsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityGetPageOffsetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityGetPageOffsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityGetPageOffset"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs {
  /// The entity to increment
  entity_id: String,
  /// The subset of data to increment
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs.json_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGlobalEntityIncrementGlobalEntityDataArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_IncrementGlobalEntityData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 2))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityIncrementGlobalEntityDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityIncrementGlobalEntityData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs {
  where_json: String,
  /// The maximum number of entities to return
  max_return: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs.where_json", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs.max_return", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingArgs {
      where_json: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_return: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_GetRandomEntitiesMatching_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("whereJson", TType::String, 1))?;
    o_prot.write_string(&self.where_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxReturn", TType::I32, 2))?;
    o_prot.write_i32(self.max_return)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityGetRandomEntitiesMatchingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityGetRandomEntitiesMatching"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs {
  /// The entity ID
  entity_id: String,
  /// The version of the entity
  version: i64,
  /// The owner ID
  owner_id: String,
  /// The entity's access control list
  acl: brain_cloud_service_s_d_k_data_types::JSON,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::JSON> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs.owner_id", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs.acl", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      owner_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      acl: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_UpdateEntityOwnerAndAcl_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 2))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("ownerId", TType::String, 3))?;
    o_prot.write_string(&self.owner_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("acl", TType::String, 4))?;
    o_prot.write_string(&self.acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAclResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityUpdateEntityOwnerAndAcl"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalEntityMakeSystemEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityMakeSystemEntityArgs {
  /// The entity ID
  entity_id: String,
  /// The version of the entity
  version: i64,
  /// The entity's access control list
  acl: brain_cloud_service_s_d_k_data_types::JSON,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalEntityMakeSystemEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityMakeSystemEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<brain_cloud_service_s_d_k_data_types::JSON> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityMakeSystemEntityArgs.entity_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityMakeSystemEntityArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityMakeSystemEntityArgs.acl", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGlobalEntityMakeSystemEntityArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGlobalEntityMakeSystemEntityArgs {
      entity_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      acl: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalEntity_MakeSystemEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 1))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 2))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("acl", TType::String, 3))?;
    o_prot.write_string(&self.acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalEntityMakeSystemEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalEntityMakeSystemEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalEntityMakeSystemEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalEntityMakeSystemEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalEntityMakeSystemEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalEntityMakeSystemEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalEntityMakeSystemEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceGlobalStatisticsReadAllGlobalStatsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalStatistics_ReadAllGlobalStats_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalStatisticsReadAllGlobalStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalStatisticsReadAllGlobalStats"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs {
  /// A list containing the statistics to read
  global_stats: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_8 = i_prot.read_string()?;
            val.push(list_elem_8);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs.global_stats", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetArgs {
      global_stats: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalStatistics_ReadGlobalStatsSubset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("globalStats", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.global_stats.len() as i32))?;
    for e in &self.global_stats {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalStatisticsReadGlobalStatsSubsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalStatisticsReadGlobalStatsSubset"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs {
  /// The global statistics category
  category: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs.category", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryArgs {
      category: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalStatistics_ReadGlobalStatsForCategory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalStatisticsReadGlobalStatsForCategory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs {
  /// The JSON encoded data to be sent to the server as follows:
  /// {
  ///   stat1: 10,
  ///   stat2: -5.5,
  /// }
  /// would increment stat1 by 10 and decrement stat2 by 5.5.
  /// For the full statistics grammer see the api.braincloudservers.com site.
  /// There are many more complex operations supported such as:
  /// {
  ///   stat1:INC_TO_LIMIT#9#30
  /// }
  /// which increments stat1 by 9 up to a limit of 30.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs.json_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalStatisticsIncrementGlobalStatsArgs {
      json_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalStatistics_IncrementGlobalStats_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 1))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalStatisticsIncrementGlobalStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalStatisticsIncrementGlobalStats"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGlobalStatisticsProcessStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsProcessStatisticsArgs {
  /// Example data to be passed to method:
  /// {
  ///     "DEAD_CATS": "RESET",
  ///     "LIVES_LEFT": "SET#9",
  ///     "MICE_KILLED": "INC#2",
  ///     "DOG_SCARE_BONUS_POINTS": "INC#10",
  ///     "TREES_CLIMBED": 1
  /// }
  statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGlobalStatisticsProcessStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsProcessStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_9 = i_prot.read_string()?;
            let map_val_10 = i_prot.read_string()?;
            val.insert(map_key_9, map_val_10);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsProcessStatisticsArgs.statistics_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGlobalStatisticsProcessStatisticsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGlobalStatisticsProcessStatisticsArgs {
      statistics_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("GlobalStatistics_ProcessStatistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statisticsData", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.statistics_data.len() as i32))?;
    for (k, v) in &self.statistics_data {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGlobalStatisticsProcessStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGlobalStatisticsProcessStatisticsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGlobalStatisticsProcessStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGlobalStatisticsProcessStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGlobalStatisticsProcessStatisticsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGlobalStatisticsProcessStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGlobalStatisticsProcessStatistics"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupAcceptGroupInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupAcceptGroupInvitationArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupAcceptGroupInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupAcceptGroupInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupAcceptGroupInvitationArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupAcceptGroupInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupAcceptGroupInvitationArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_AcceptGroupInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupAcceptGroupInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupAcceptGroupInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupAcceptGroupInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupAcceptGroupInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupAcceptGroupInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupAcceptGroupInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupAcceptGroupInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupAddGroupMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupAddGroupMemberArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the member being added.
  profile_id: String,
  /// Role of the member being added.
  role: brain_cloud_service_s_d_k_data_types::Role,
  /// Attributes of the member being added.
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupAddGroupMemberArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupAddGroupMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<brain_cloud_service_s_d_k_data_types::Role> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = brain_cloud_service_s_d_k_data_types::Role::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupAddGroupMemberArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupAddGroupMemberArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupAddGroupMemberArgs.role", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupAddGroupMemberArgs.json_attributes", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupAddGroupMemberArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGroupAddGroupMemberArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_AddGroupMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 3))?;
    self.role.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 4))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupAddGroupMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupAddGroupMemberResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupAddGroupMemberResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupAddGroupMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupAddGroupMemberResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupAddGroupMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupAddGroupMember"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupApproveGroupJoinRequestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupApproveGroupJoinRequestArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the invitation being deleted.
  profile_id: String,
  /// Role of the member being invited.
  role: brain_cloud_service_s_d_k_data_types::Role,
  /// Attributes of the member being invited.
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupApproveGroupJoinRequestArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupApproveGroupJoinRequestArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<brain_cloud_service_s_d_k_data_types::Role> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = brain_cloud_service_s_d_k_data_types::Role::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupApproveGroupJoinRequestArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupApproveGroupJoinRequestArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupApproveGroupJoinRequestArgs.role", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupApproveGroupJoinRequestArgs.json_attributes", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupApproveGroupJoinRequestArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGroupApproveGroupJoinRequestArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ApproveGroupJoinRequest_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 3))?;
    self.role.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 4))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupApproveGroupJoinRequestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupApproveGroupJoinRequestResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupApproveGroupJoinRequestResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupApproveGroupJoinRequestResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupApproveGroupJoinRequestResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupApproveGroupJoinRequestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupApproveGroupJoinRequest"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupAutoJoinGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupAutoJoinGroupArgs {
  /// Name of the associated group type.
  group_type: String,
  /// Selection strategy to employ when there are multiple matches
  auto_join_strategy: brain_cloud_service_s_d_k_data_types::AutoJoinStrategy,
  /// Query parameters (optional)
  data_query_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupAutoJoinGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupAutoJoinGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<brain_cloud_service_s_d_k_data_types::AutoJoinStrategy> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = brain_cloud_service_s_d_k_data_types::AutoJoinStrategy::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupAutoJoinGroupArgs.group_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupAutoJoinGroupArgs.auto_join_strategy", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupAutoJoinGroupArgs.data_query_json", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupAutoJoinGroupArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGroupAutoJoinGroupArgs {
      group_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      auto_join_strategy: f_2.expect("auto-generated code should have checked for presence of required fields"),
      data_query_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_AutoJoinGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupType", TType::String, 1))?;
    o_prot.write_string(&self.group_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("autoJoinStrategy", TType::I32, 2))?;
    self.auto_join_strategy.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dataQueryJson", TType::String, 3))?;
    o_prot.write_string(&self.data_query_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupAutoJoinGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupAutoJoinGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupAutoJoinGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupAutoJoinGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupAutoJoinGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupAutoJoinGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupAutoJoinGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupCancelGroupInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupCancelGroupInvitationArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the invitation being deleted.
  profile_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupCancelGroupInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupCancelGroupInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupCancelGroupInvitationArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupCancelGroupInvitationArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupCancelGroupInvitationArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupCancelGroupInvitationArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_CancelGroupInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupCancelGroupInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupCancelGroupInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupCancelGroupInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupCancelGroupInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupCancelGroupInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupCancelGroupInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupCancelGroupInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupCreateGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupCreateGroupArgs {
  /// Name of the group.
  name: String,
  /// Name of the type of group.
  group_type: String,
  /// true if group is open; false if closed.
  is_open_group: bool,
  /// The group's access control list. A null ACL implies default.
  acl: brain_cloud_service_s_d_k_data_types::JSON,
  /// Custom application data.
  json_data: String,
  /// Attributes for the group owner (current user).
  json_owner_attributes: String,
  /// Default attributes for group members.
  json_default_member_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupCreateGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupCreateGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::JSON> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<String> = None;
    let mut f_7: Option<String> = None;
    let mut f_8: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.group_type", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.is_open_group", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.acl", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.json_data", &f_5)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.json_owner_attributes", &f_6)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.json_default_member_attributes", &f_7)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupArgs.client_index", &f_8)?;
    let ret = BrainCloudServiceGroupCreateGroupArgs {
      name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_open_group: f_3.expect("auto-generated code should have checked for presence of required fields"),
      acl: f_4.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_5.expect("auto-generated code should have checked for presence of required fields"),
      json_owner_attributes: f_6.expect("auto-generated code should have checked for presence of required fields"),
      json_default_member_attributes: f_7.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_CreateGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupType", TType::String, 2))?;
    o_prot.write_string(&self.group_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isOpenGroup", TType::Bool, 3))?;
    o_prot.write_bool(self.is_open_group)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("acl", TType::String, 4))?;
    o_prot.write_string(&self.acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 5))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonOwnerAttributes", TType::String, 6))?;
    o_prot.write_string(&self.json_owner_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonDefaultMemberAttributes", TType::String, 7))?;
    o_prot.write_string(&self.json_default_member_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 8))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupCreateGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupCreateGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupCreateGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupCreateGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupCreateGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupCreateGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupCreateGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupCreateGroupEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupCreateGroupEntityArgs {
  /// ID of the group.
  group_id: String,
  entity_type: String,
  /// true if entity is owned by a member; false if owned by the entire group.
  is_owned_by_group_member: bool,
  /// Access control list for the group entity.
  acl: brain_cloud_service_s_d_k_data_types::JSON,
  /// Custom application data.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupCreateGroupEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupCreateGroupEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::JSON> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupEntityArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupEntityArgs.entity_type", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupEntityArgs.is_owned_by_group_member", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupEntityArgs.acl", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupEntityArgs.json_data", &f_5)?;
    verify_required_field_exists("BrainCloudServiceGroupCreateGroupEntityArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceGroupCreateGroupEntityArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_type: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_owned_by_group_member: f_3.expect("auto-generated code should have checked for presence of required fields"),
      acl: f_4.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_CreateGroupEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityType", TType::String, 2))?;
    o_prot.write_string(&self.entity_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isOwnedByGroupMember", TType::Bool, 3))?;
    o_prot.write_bool(self.is_owned_by_group_member)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("acl", TType::String, 4))?;
    o_prot.write_string(&self.acl)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 5))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupCreateGroupEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupCreateGroupEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupCreateGroupEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupCreateGroupEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupCreateGroupEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupCreateGroupEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupCreateGroupEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupDeleteGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupDeleteGroupArgs {
  /// ID of the group.
  group_id: String,
  /// Current version of the group
  version: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupDeleteGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupDeleteGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupDeleteGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_DeleteGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 2))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupDeleteGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupDeleteGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupDeleteGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupDeleteGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupDeleteGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupDeleteGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupDeleteGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupDeleteGroupEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupDeleteGroupEntityArgs {
  /// ID of the group.
  group_id: String,
  /// ID of the entity.
  entity_id: String,
  /// The current version of the group entity (for concurrency checking).
  version: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupDeleteGroupEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupDeleteGroupEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupEntityArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupEntityArgs.entity_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupEntityArgs.version", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupDeleteGroupEntityArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGroupDeleteGroupEntityArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_DeleteGroupEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 2))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupDeleteGroupEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupDeleteGroupEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupDeleteGroupEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupDeleteGroupEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupDeleteGroupEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupDeleteGroupEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupDeleteGroupEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupGetMyGroupsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupGetMyGroupsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupGetMyGroupsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupGetMyGroupsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupGetMyGroupsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceGroupGetMyGroupsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_GetMyGroups_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupGetMyGroupsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupGetMyGroupsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupGetMyGroupsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupGetMyGroupsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupGetMyGroupsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupGetMyGroupsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupGetMyGroups"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupIncrementGroupDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupIncrementGroupDataArgs {
  /// ID of the group.
  group_id: String,
  /// Partial data map with incremental values.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupIncrementGroupDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupIncrementGroupDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupDataArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupDataArgs.json_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupDataArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupIncrementGroupDataArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_IncrementGroupData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 2))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupIncrementGroupDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupIncrementGroupDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupIncrementGroupDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupIncrementGroupDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupIncrementGroupDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupIncrementGroupDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupIncrementGroupData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupIncrementGroupEntityDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupIncrementGroupEntityDataArgs {
  /// ID of the group.
  group_id: String,
  /// ID of the entity.
  entity_id: String,
  /// Partial data map with incremental values.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupIncrementGroupEntityDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupIncrementGroupEntityDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupEntityDataArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupEntityDataArgs.entity_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupEntityDataArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupIncrementGroupEntityDataArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGroupIncrementGroupEntityDataArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_IncrementGroupEntityData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 2))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupIncrementGroupEntityDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupIncrementGroupEntityDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupIncrementGroupEntityDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupIncrementGroupEntityDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupIncrementGroupEntityDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupIncrementGroupEntityDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupIncrementGroupEntityData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupInviteGroupMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupInviteGroupMemberArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the member being invited.
  profile_id: String,
  /// Role of the member being invited.
  role: brain_cloud_service_s_d_k_data_types::Role,
  /// Attributes of the member being invited.
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupInviteGroupMemberArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupInviteGroupMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<brain_cloud_service_s_d_k_data_types::Role> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = brain_cloud_service_s_d_k_data_types::Role::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupInviteGroupMemberArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupInviteGroupMemberArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupInviteGroupMemberArgs.role", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupInviteGroupMemberArgs.json_attributes", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupInviteGroupMemberArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGroupInviteGroupMemberArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_InviteGroupMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 3))?;
    self.role.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 4))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupInviteGroupMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupInviteGroupMemberResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupInviteGroupMemberResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupInviteGroupMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupInviteGroupMemberResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupInviteGroupMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupInviteGroupMember"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupJoinGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupJoinGroupArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupJoinGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupJoinGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupJoinGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupJoinGroupArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupJoinGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_JoinGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupJoinGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupJoinGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupJoinGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupJoinGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupJoinGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupJoinGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupJoinGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupLeaveGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupLeaveGroupArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupLeaveGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupLeaveGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupLeaveGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupLeaveGroupArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupLeaveGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_LeaveGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupLeaveGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupLeaveGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupLeaveGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupLeaveGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupLeaveGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupLeaveGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupLeaveGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupListGroupsPageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupListGroupsPageArgs {
  /// Query context.
  json_context: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupListGroupsPageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupListGroupsPageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsPageArgs.json_context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsPageArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupListGroupsPageArgs {
      json_context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ListGroupsPage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonContext", TType::String, 1))?;
    o_prot.write_string(&self.json_context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupListGroupsPageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupListGroupsPageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupListGroupsPageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupListGroupsPageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupListGroupsPageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupListGroupsPageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupListGroupsPage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupListGroupsPageByOffsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupListGroupsPageByOffsetArgs {
  /// Encoded reference query context.
  context: String,
  /// Number of pages by which to offset the query.
  page_offset: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupListGroupsPageByOffsetArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupListGroupsPageByOffsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsPageByOffsetArgs.context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsPageByOffsetArgs.page_offset", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsPageByOffsetArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupListGroupsPageByOffsetArgs {
      context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_offset: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ListGroupsPageByOffset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("context", TType::String, 1))?;
    o_prot.write_string(&self.context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageOffset", TType::I32, 2))?;
    o_prot.write_i32(self.page_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupListGroupsPageByOffsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupListGroupsPageByOffsetResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupListGroupsPageByOffsetResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupListGroupsPageByOffsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupListGroupsPageByOffsetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupListGroupsPageByOffsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupListGroupsPageByOffset"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupListGroupsWithMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupListGroupsWithMemberArgs {
  /// User to read groups for
  profile_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupListGroupsWithMemberArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupListGroupsWithMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsWithMemberArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupListGroupsWithMemberArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupListGroupsWithMemberArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ListGroupsWithMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupListGroupsWithMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupListGroupsWithMemberResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupListGroupsWithMemberResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupListGroupsWithMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupListGroupsWithMemberResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupListGroupsWithMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupListGroupsWithMember"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupReadGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupReadGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupReadGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ReadGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupReadGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupReadGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupReadGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupReadGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupReadGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupReadGroupDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupDataArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupReadGroupDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupDataArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupDataArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupReadGroupDataArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ReadGroupData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupReadGroupDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupReadGroupDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupReadGroupDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupReadGroupDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupReadGroupData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupReadGroupEntitiesPageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupEntitiesPageArgs {
  /// Query context.
  json_context: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupReadGroupEntitiesPageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupEntitiesPageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntitiesPageArgs.json_context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntitiesPageArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupReadGroupEntitiesPageArgs {
      json_context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ReadGroupEntitiesPage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonContext", TType::String, 1))?;
    o_prot.write_string(&self.json_context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupReadGroupEntitiesPageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupEntitiesPageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupReadGroupEntitiesPageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupEntitiesPageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupReadGroupEntitiesPageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupReadGroupEntitiesPageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupReadGroupEntitiesPage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs {
  /// Encoded reference query context.
  encoded_context: String,
  /// Number of pages by which to offset the query.
  page_offset: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs.encoded_context", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs.page_offset", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupReadGroupEntitiesPageByOffsetArgs {
      encoded_context: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_offset: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ReadGroupEntitiesPageByOffset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("encodedContext", TType::String, 1))?;
    o_prot.write_string(&self.encoded_context)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageOffset", TType::I32, 2))?;
    o_prot.write_i32(self.page_offset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupReadGroupEntitiesPageByOffsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupReadGroupEntitiesPageByOffset"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupReadGroupEntityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupEntityArgs {
  /// ID of the group.
  group_id: String,
  /// ID of the entity.
  entity_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupReadGroupEntityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupEntityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntityArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntityArgs.entity_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupEntityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupReadGroupEntityArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ReadGroupEntity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 2))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupReadGroupEntityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupEntityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupReadGroupEntityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupEntityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupReadGroupEntityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupReadGroupEntityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupReadGroupEntity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupReadGroupMembersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupMembersArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupReadGroupMembersArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupMembersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupMembersArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupReadGroupMembersArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupReadGroupMembersArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_ReadGroupMembers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupReadGroupMembersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupReadGroupMembersResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupReadGroupMembersResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupReadGroupMembersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupReadGroupMembersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupReadGroupMembersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupReadGroupMembers"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupRejectGroupInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupRejectGroupInvitationArgs {
  /// ID of the group.
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupRejectGroupInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupRejectGroupInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupRejectGroupInvitationArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupRejectGroupInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceGroupRejectGroupInvitationArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_RejectGroupInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupRejectGroupInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupRejectGroupInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupRejectGroupInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupRejectGroupInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupRejectGroupInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupRejectGroupInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupRejectGroupInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupRejectGroupJoinRequestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupRejectGroupJoinRequestArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the invitation being deleted.
  profile_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupRejectGroupJoinRequestArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupRejectGroupJoinRequestArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupRejectGroupJoinRequestArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupRejectGroupJoinRequestArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupRejectGroupJoinRequestArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupRejectGroupJoinRequestArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_RejectGroupJoinRequest_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupRejectGroupJoinRequestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupRejectGroupJoinRequestResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupRejectGroupJoinRequestResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupRejectGroupJoinRequestResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupRejectGroupJoinRequestResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupRejectGroupJoinRequestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupRejectGroupJoinRequest"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupRemoveGroupMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupRemoveGroupMemberArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the member being deleted.
  profile_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupRemoveGroupMemberArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupRemoveGroupMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupRemoveGroupMemberArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupRemoveGroupMemberArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupRemoveGroupMemberArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupRemoveGroupMemberArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_RemoveGroupMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupRemoveGroupMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupRemoveGroupMemberResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupRemoveGroupMemberResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupRemoveGroupMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupRemoveGroupMemberResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupRemoveGroupMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupRemoveGroupMember"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupUpdateGroupDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupDataArgs {
  /// ID of the group.
  group_id: String,
  /// Version to verify.
  version: i64,
  /// Data to apply.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupUpdateGroupDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupDataArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupDataArgs.version", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupDataArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupDataArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceGroupUpdateGroupDataArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_UpdateGroupData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 2))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupUpdateGroupDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupUpdateGroupDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupUpdateGroupDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupUpdateGroupDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupUpdateGroupData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupUpdateGroupEntityDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupEntityDataArgs {
  /// ID of the group.
  group_id: String,
  /// ID of the entity.
  entity_id: String,
  /// The current version of the group entity (for concurrency checking).
  version: i64,
  /// Custom application data.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupUpdateGroupEntityDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupEntityDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupEntityDataArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupEntityDataArgs.entity_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupEntityDataArgs.version", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupEntityDataArgs.json_data", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupEntityDataArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGroupUpdateGroupEntityDataArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      entity_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      version: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_UpdateGroupEntityData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("entityId", TType::String, 2))?;
    o_prot.write_string(&self.entity_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("version", TType::I64, 3))?;
    o_prot.write_i64(self.version)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 4))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupUpdateGroupEntityDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupEntityDataResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupUpdateGroupEntityDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupEntityDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupUpdateGroupEntityDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupUpdateGroupEntityDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupUpdateGroupEntityData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupUpdateGroupMemberArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupMemberArgs {
  /// ID of the group.
  group_id: String,
  /// Profile ID of the member being updated.
  profile_id: String,
  /// Role of the member being updated (optional).
  role: brain_cloud_service_s_d_k_data_types::Role,
  /// Attributes of the member being updated (optional).
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupUpdateGroupMemberArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupMemberArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<brain_cloud_service_s_d_k_data_types::Role> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = brain_cloud_service_s_d_k_data_types::Role::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupMemberArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupMemberArgs.profile_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupMemberArgs.role", &f_3)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupMemberArgs.json_attributes", &f_4)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupMemberArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceGroupUpdateGroupMemberArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      role: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_UpdateGroupMember_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 2))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("role", TType::I32, 3))?;
    self.role.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 4))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupUpdateGroupMemberResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupMemberResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupUpdateGroupMemberResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupMemberResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupUpdateGroupMemberResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupUpdateGroupMemberResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupUpdateGroupMember"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceGroupUpdateGroupNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupNameArgs {
  /// ID of the group.
  group_id: String,
  /// Name to apply.
  name: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceGroupUpdateGroupNameArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupNameArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupNameArgs.name", &f_2)?;
    verify_required_field_exists("BrainCloudServiceGroupUpdateGroupNameArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceGroupUpdateGroupNameArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Group_UpdateGroupName_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 2))?;
    o_prot.write_string(&self.name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceGroupUpdateGroupNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceGroupUpdateGroupNameResult {
  result_value: Option<String>,
}

impl BrainCloudServiceGroupUpdateGroupNameResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceGroupUpdateGroupNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceGroupUpdateGroupNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceGroupUpdateGroupNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceGroupUpdateGroupName"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityAttachEmailIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachEmailIdentityArgs {
  /// The user's e-mail address
  email: String,
  /// The user's password
  password: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityAttachEmailIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachEmailIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachEmailIdentityArgs.email", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachEmailIdentityArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachEmailIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentityAttachEmailIdentityArgs {
      email: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_AttachEmailIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 1))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityAttachEmailIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachEmailIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityAttachEmailIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachEmailIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityAttachEmailIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityAttachEmailIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityAttachEmailIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityMergeEmailIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityMergeEmailIdentityArgs {
  /// The user's e-mail address
  email: String,
  /// The user's password
  password: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityMergeEmailIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityMergeEmailIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityMergeEmailIdentityArgs.email", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityMergeEmailIdentityArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityMergeEmailIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentityMergeEmailIdentityArgs {
      email: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_MergeEmailIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 1))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityMergeEmailIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityMergeEmailIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityMergeEmailIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityMergeEmailIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityMergeEmailIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityMergeEmailIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityMergeEmailIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityDetachEmailIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachEmailIdentityArgs {
  /// The user's e-mail address
  email: String,
  /// Proceed even if the profile will revert to anonymous?
  continue_anon: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityDetachEmailIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachEmailIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachEmailIdentityArgs.email", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachEmailIdentityArgs.continue_anon", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachEmailIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentityDetachEmailIdentityArgs {
      email: f_1.expect("auto-generated code should have checked for presence of required fields"),
      continue_anon: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_DetachEmailIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("email", TType::String, 1))?;
    o_prot.write_string(&self.email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("continueAnon", TType::Bool, 2))?;
    o_prot.write_bool(self.continue_anon)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityDetachEmailIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachEmailIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityDetachEmailIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachEmailIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityDetachEmailIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityDetachEmailIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityDetachEmailIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityAttachUniversalIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachUniversalIdentityArgs {
  /// The user's userId
  user_id: String,
  /// The user's password
  password: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityAttachUniversalIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachUniversalIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachUniversalIdentityArgs.user_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachUniversalIdentityArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachUniversalIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentityAttachUniversalIdentityArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_AttachUniversalIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityAttachUniversalIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachUniversalIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityAttachUniversalIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachUniversalIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityAttachUniversalIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityAttachUniversalIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityAttachUniversalIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityMergeUniversalIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityMergeUniversalIdentityArgs {
  /// The user's userId
  user_id: String,
  /// The user's password
  password: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityMergeUniversalIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityMergeUniversalIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityMergeUniversalIdentityArgs.user_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityMergeUniversalIdentityArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityMergeUniversalIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentityMergeUniversalIdentityArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_MergeUniversalIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityMergeUniversalIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityMergeUniversalIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityMergeUniversalIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityMergeUniversalIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityMergeUniversalIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityMergeUniversalIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityMergeUniversalIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityDetachUniversalIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachUniversalIdentityArgs {
  /// The user's userId
  user_id: String,
  /// Proceed even if the profile will revert to anonymous?
  continue_anon: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityDetachUniversalIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachUniversalIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachUniversalIdentityArgs.user_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachUniversalIdentityArgs.continue_anon", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachUniversalIdentityArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentityDetachUniversalIdentityArgs {
      user_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      continue_anon: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_DetachUniversalIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
    o_prot.write_string(&self.user_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("continueAnon", TType::Bool, 2))?;
    o_prot.write_bool(self.continue_anon)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityDetachUniversalIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachUniversalIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityDetachUniversalIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachUniversalIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityDetachUniversalIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityDetachUniversalIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityDetachUniversalIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentitySwitchToChildProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentitySwitchToChildProfileArgs {
  /// The profileId of the child profile to switch to
  /// If null and forceCreate is true a new profile will be created
  child_profile_id: String,
  /// The appId of the child game to switch to
  child_app_id: String,
  /// Should a new profile be created if it does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentitySwitchToChildProfileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentitySwitchToChildProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToChildProfileArgs.child_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToChildProfileArgs.child_app_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToChildProfileArgs.force_create", &f_3)?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToChildProfileArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceIdentitySwitchToChildProfileArgs {
      child_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      child_app_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_SwitchToChildProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("childProfileId", TType::String, 1))?;
    o_prot.write_string(&self.child_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("childAppId", TType::String, 2))?;
    o_prot.write_string(&self.child_app_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 3))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentitySwitchToChildProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentitySwitchToChildProfileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentitySwitchToChildProfileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentitySwitchToChildProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentitySwitchToChildProfileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentitySwitchToChildProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentitySwitchToChildProfile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs {
  /// The App ID of the child game to switch to
  child_app_id: String,
  /// Should a new profile be created if one does not exist?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs.child_app_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs.force_create", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceIdentitySwitchToSingletonChildProfileArgs {
      child_app_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_SwitchToSingletonChildProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("childAppId", TType::String, 1))?;
    o_prot.write_string(&self.child_app_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 2))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentitySwitchToSingletonChildProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentitySwitchToSingletonChildProfileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentitySwitchToSingletonChildProfileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentitySwitchToSingletonChildProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentitySwitchToSingletonChildProfileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentitySwitchToSingletonChildProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentitySwitchToSingletonChildProfile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityAttachParentWithIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachParentWithIdentityArgs {
  /// User ID
  external_id: String,
  /// Password or client side token
  authentication_token: String,
  /// Type of authentication
  authentication_type: String,
  /// Optional - if using AuthenticationType of external
  external_auth_name: String,
  /// If the profile does not exist, should it be created?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityAttachParentWithIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachParentWithIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachParentWithIdentityArgs.external_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachParentWithIdentityArgs.authentication_token", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachParentWithIdentityArgs.authentication_type", &f_3)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachParentWithIdentityArgs.external_auth_name", &f_4)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachParentWithIdentityArgs.force_create", &f_5)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachParentWithIdentityArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceIdentityAttachParentWithIdentityArgs {
      external_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      authentication_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      authentication_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      external_auth_name: f_4.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_AttachParentWithIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalId", TType::String, 1))?;
    o_prot.write_string(&self.external_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 2))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationType", TType::String, 3))?;
    o_prot.write_string(&self.authentication_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalAuthName", TType::String, 4))?;
    o_prot.write_string(&self.external_auth_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 5))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityAttachParentWithIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachParentWithIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityAttachParentWithIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachParentWithIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityAttachParentWithIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityAttachParentWithIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityAttachParentWithIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentitySwitchToParentProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentitySwitchToParentProfileArgs {
  /// The level of the parent to switch to
  parent_level_name: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentitySwitchToParentProfileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentitySwitchToParentProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToParentProfileArgs.parent_level_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentitySwitchToParentProfileArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceIdentitySwitchToParentProfileArgs {
      parent_level_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_SwitchToParentProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parentLevelName", TType::String, 1))?;
    o_prot.write_string(&self.parent_level_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentitySwitchToParentProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentitySwitchToParentProfileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentitySwitchToParentProfileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentitySwitchToParentProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentitySwitchToParentProfileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentitySwitchToParentProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentitySwitchToParentProfile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityDetachParentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachParentArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityDetachParentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachParentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachParentArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceIdentityDetachParentArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_DetachParent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityDetachParentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachParentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityDetachParentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachParentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityDetachParentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityDetachParentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityDetachParent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityGetChildProfilesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetChildProfilesArgs {
  /// Whether to return the summary friend data along with this call
  include_summary_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityGetChildProfilesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetChildProfilesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityGetChildProfilesArgs.include_summary_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityGetChildProfilesArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceIdentityGetChildProfilesArgs {
      include_summary_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_GetChildProfiles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeSummaryData", TType::Bool, 1))?;
    o_prot.write_bool(self.include_summary_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityGetChildProfilesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetChildProfilesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityGetChildProfilesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetChildProfilesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityGetChildProfilesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityGetChildProfilesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityGetChildProfiles"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityGetIdentitiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetIdentitiesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityGetIdentitiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetIdentitiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityGetIdentitiesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceIdentityGetIdentitiesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_GetIdentities_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityGetIdentitiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetIdentitiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityGetIdentitiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetIdentitiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityGetIdentitiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityGetIdentitiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityGetIdentities"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityGetExpiredIdentitiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetExpiredIdentitiesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityGetExpiredIdentitiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetExpiredIdentitiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityGetExpiredIdentitiesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceIdentityGetExpiredIdentitiesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_GetExpiredIdentities_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityGetExpiredIdentitiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetExpiredIdentitiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityGetExpiredIdentitiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetExpiredIdentitiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityGetExpiredIdentitiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityGetExpiredIdentitiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityGetExpiredIdentities"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityRefreshIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityRefreshIdentityArgs {
  /// User ID
  external_id: String,
  /// Password or client side token
  authentication_token: String,
  /// Type of authentication
  authentication_type: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityRefreshIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityRefreshIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityRefreshIdentityArgs.external_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityRefreshIdentityArgs.authentication_token", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityRefreshIdentityArgs.authentication_type", &f_3)?;
    verify_required_field_exists("BrainCloudServiceIdentityRefreshIdentityArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceIdentityRefreshIdentityArgs {
      external_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      authentication_token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      authentication_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_RefreshIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalId", TType::String, 1))?;
    o_prot.write_string(&self.external_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 2))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationType", TType::String, 3))?;
    o_prot.write_string(&self.authentication_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityRefreshIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityRefreshIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityRefreshIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityRefreshIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityRefreshIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityRefreshIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityRefreshIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityChangeEmailIdentityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityChangeEmailIdentityArgs {
  /// Old email address
  old_email_address: String,
  /// Password for identity
  password: String,
  /// New email address
  new_email_address: String,
  /// Whether to update contact email in profile
  update_contact_email: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityChangeEmailIdentityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityChangeEmailIdentityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityChangeEmailIdentityArgs.old_email_address", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityChangeEmailIdentityArgs.password", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityChangeEmailIdentityArgs.new_email_address", &f_3)?;
    verify_required_field_exists("BrainCloudServiceIdentityChangeEmailIdentityArgs.update_contact_email", &f_4)?;
    verify_required_field_exists("BrainCloudServiceIdentityChangeEmailIdentityArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceIdentityChangeEmailIdentityArgs {
      old_email_address: f_1.expect("auto-generated code should have checked for presence of required fields"),
      password: f_2.expect("auto-generated code should have checked for presence of required fields"),
      new_email_address: f_3.expect("auto-generated code should have checked for presence of required fields"),
      update_contact_email: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_ChangeEmailIdentity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("oldEmailAddress", TType::String, 1))?;
    o_prot.write_string(&self.old_email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("password", TType::String, 2))?;
    o_prot.write_string(&self.password)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("newEmailAddress", TType::String, 3))?;
    o_prot.write_string(&self.new_email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("updateContactEmail", TType::Bool, 4))?;
    o_prot.write_bool(self.update_contact_email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityChangeEmailIdentityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityChangeEmailIdentityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityChangeEmailIdentityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityChangeEmailIdentityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityChangeEmailIdentityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityChangeEmailIdentityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityChangeEmailIdentity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityAttachPeerProfileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachPeerProfileArgs {
  /// Name of the peer to connect to
  peer: String,
  /// User ID
  external_id: String,
  /// Password or client side token
  authentication_token: String,
  /// Type of authentication
  authentication_type: String,
  /// Optional - if using AuthenticationType of external
  external_auth_name: String,
  /// If the profile does not exist, should it be created?
  force_create: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityAttachPeerProfileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachPeerProfileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<String> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.peer", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.external_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.authentication_token", &f_3)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.authentication_type", &f_4)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.external_auth_name", &f_5)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.force_create", &f_6)?;
    verify_required_field_exists("BrainCloudServiceIdentityAttachPeerProfileArgs.client_index", &f_7)?;
    let ret = BrainCloudServiceIdentityAttachPeerProfileArgs {
      peer: f_1.expect("auto-generated code should have checked for presence of required fields"),
      external_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      authentication_token: f_3.expect("auto-generated code should have checked for presence of required fields"),
      authentication_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      external_auth_name: f_5.expect("auto-generated code should have checked for presence of required fields"),
      force_create: f_6.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_AttachPeerProfile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peer", TType::String, 1))?;
    o_prot.write_string(&self.peer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalId", TType::String, 2))?;
    o_prot.write_string(&self.external_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationToken", TType::String, 3))?;
    o_prot.write_string(&self.authentication_token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("authenticationType", TType::String, 4))?;
    o_prot.write_string(&self.authentication_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("externalAuthName", TType::String, 5))?;
    o_prot.write_string(&self.external_auth_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("forceCreate", TType::Bool, 6))?;
    o_prot.write_bool(self.force_create)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 7))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityAttachPeerProfileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityAttachPeerProfileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityAttachPeerProfileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityAttachPeerProfileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityAttachPeerProfileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityAttachPeerProfileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityAttachPeerProfile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityDetachPeerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachPeerArgs {
  /// Name of the peer to connect to
  peer: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityDetachPeerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachPeerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachPeerArgs.peer", &f_1)?;
    verify_required_field_exists("BrainCloudServiceIdentityDetachPeerArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceIdentityDetachPeerArgs {
      peer: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_DetachPeer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peer", TType::String, 1))?;
    o_prot.write_string(&self.peer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityDetachPeerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityDetachPeerResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityDetachPeerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityDetachPeerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityDetachPeerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityDetachPeerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityDetachPeer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceIdentityGetPeerProfilesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetPeerProfilesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceIdentityGetPeerProfilesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetPeerProfilesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceIdentityGetPeerProfilesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceIdentityGetPeerProfilesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Identity_GetPeerProfiles_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceIdentityGetPeerProfilesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceIdentityGetPeerProfilesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceIdentityGetPeerProfilesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceIdentityGetPeerProfilesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceIdentityGetPeerProfilesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceIdentityGetPeerProfilesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceIdentityGetPeerProfiles"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMailSendBasicEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMailSendBasicEmailArgs {
  profile_id: String,
  /// The email subject
  subject: String,
  /// The email body
  body: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMailSendBasicEmailArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMailSendBasicEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMailSendBasicEmailArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMailSendBasicEmailArgs.subject", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMailSendBasicEmailArgs.body", &f_3)?;
    verify_required_field_exists("BrainCloudServiceMailSendBasicEmailArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceMailSendBasicEmailArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      subject: f_2.expect("auto-generated code should have checked for presence of required fields"),
      body: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Mail_SendBasicEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("subject", TType::String, 2))?;
    o_prot.write_string(&self.subject)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("body", TType::String, 3))?;
    o_prot.write_string(&self.body)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMailSendBasicEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMailSendBasicEmailResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMailSendBasicEmailResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMailSendBasicEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMailSendBasicEmailResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMailSendBasicEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMailSendBasicEmail"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMailSendAdvancedEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMailSendAdvancedEmailArgs {
  profile_id: String,
  /// Parameters to send to the email service. See the documentation for
  /// a full list. http://getbraincloud.com/apidocs/apiref/#capi-mail
  json_service_params: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMailSendAdvancedEmailArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMailSendAdvancedEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMailSendAdvancedEmailArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMailSendAdvancedEmailArgs.json_service_params", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMailSendAdvancedEmailArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceMailSendAdvancedEmailArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_service_params: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Mail_SendAdvancedEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonServiceParams", TType::String, 2))?;
    o_prot.write_string(&self.json_service_params)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMailSendAdvancedEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMailSendAdvancedEmailResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMailSendAdvancedEmailResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMailSendAdvancedEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMailSendAdvancedEmailResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMailSendAdvancedEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMailSendAdvancedEmail"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMailSendAdvancedEmailByAddressArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMailSendAdvancedEmailByAddressArgs {
  /// The address to send the email to
  email_address: String,
  /// Parameters to send to the email service. See the documentation for
  /// a full list. http://getbraincloud.com/apidocs/apiref/#capi-mail
  json_service_params: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMailSendAdvancedEmailByAddressArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMailSendAdvancedEmailByAddressArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMailSendAdvancedEmailByAddressArgs.email_address", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMailSendAdvancedEmailByAddressArgs.json_service_params", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMailSendAdvancedEmailByAddressArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceMailSendAdvancedEmailByAddressArgs {
      email_address: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_service_params: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Mail_SendAdvancedEmailByAddress_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("emailAddress", TType::String, 1))?;
    o_prot.write_string(&self.email_address)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonServiceParams", TType::String, 2))?;
    o_prot.write_string(&self.json_service_params)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMailSendAdvancedEmailByAddressResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMailSendAdvancedEmailByAddressResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMailSendAdvancedEmailByAddressResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMailSendAdvancedEmailByAddressResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMailSendAdvancedEmailByAddressResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMailSendAdvancedEmailByAddressResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMailSendAdvancedEmailByAddress"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingReadArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingReadArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingReadArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingReadArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingReadArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceMatchMakingReadArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_Read_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingReadResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingReadResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingReadResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingReadResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingReadResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingReadResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingRead"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingSetPlayerRatingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingSetPlayerRatingArgs {
  /// The new player rating.
  player_rating: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingSetPlayerRatingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingSetPlayerRatingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingSetPlayerRatingArgs.player_rating", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingSetPlayerRatingArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceMatchMakingSetPlayerRatingArgs {
      player_rating: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_SetPlayerRating_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerRating", TType::I64, 1))?;
    o_prot.write_i64(self.player_rating)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingSetPlayerRatingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingSetPlayerRatingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingSetPlayerRatingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingSetPlayerRatingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingSetPlayerRatingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingSetPlayerRatingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingSetPlayerRating"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingResetPlayerRatingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingResetPlayerRatingArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingResetPlayerRatingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingResetPlayerRatingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingResetPlayerRatingArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceMatchMakingResetPlayerRatingArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_ResetPlayerRating_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingResetPlayerRatingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingResetPlayerRatingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingResetPlayerRatingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingResetPlayerRatingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingResetPlayerRatingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingResetPlayerRatingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingResetPlayerRating"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingIncrementPlayerRatingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingIncrementPlayerRatingArgs {
  /// The increment amount
  increment: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingIncrementPlayerRatingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingIncrementPlayerRatingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingIncrementPlayerRatingArgs.increment", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingIncrementPlayerRatingArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceMatchMakingIncrementPlayerRatingArgs {
      increment: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_IncrementPlayerRating_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("increment", TType::I64, 1))?;
    o_prot.write_i64(self.increment)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingIncrementPlayerRatingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingIncrementPlayerRatingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingIncrementPlayerRatingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingIncrementPlayerRatingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingIncrementPlayerRatingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingIncrementPlayerRatingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingIncrementPlayerRating"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingDecrementPlayerRatingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingDecrementPlayerRatingArgs {
  /// The decrement amount
  decrement: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingDecrementPlayerRatingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingDecrementPlayerRatingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingDecrementPlayerRatingArgs.decrement", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingDecrementPlayerRatingArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceMatchMakingDecrementPlayerRatingArgs {
      decrement: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_DecrementPlayerRating_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("decrement", TType::I64, 1))?;
    o_prot.write_i64(self.decrement)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingDecrementPlayerRatingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingDecrementPlayerRatingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingDecrementPlayerRatingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingDecrementPlayerRatingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingDecrementPlayerRatingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingDecrementPlayerRatingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingDecrementPlayerRating"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingTurnShieldOnArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingTurnShieldOnArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingTurnShieldOnArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingTurnShieldOnArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingTurnShieldOnArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceMatchMakingTurnShieldOnArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_TurnShieldOn_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingTurnShieldOnResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingTurnShieldOnResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingTurnShieldOnResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingTurnShieldOnResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingTurnShieldOnResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingTurnShieldOnResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingTurnShieldOn"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingTurnShieldOnForArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingTurnShieldOnForArgs {
  /// Number of minutes to turn the shield on for
  minutes: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingTurnShieldOnForArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingTurnShieldOnForArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingTurnShieldOnForArgs.minutes", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingTurnShieldOnForArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceMatchMakingTurnShieldOnForArgs {
      minutes: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_TurnShieldOnFor_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minutes", TType::I32, 1))?;
    o_prot.write_i32(self.minutes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingTurnShieldOnForResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingTurnShieldOnForResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingTurnShieldOnForResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingTurnShieldOnForResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingTurnShieldOnForResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingTurnShieldOnForResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingTurnShieldOnFor"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingTurnShieldOffArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingTurnShieldOffArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingTurnShieldOffArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingTurnShieldOffArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingTurnShieldOffArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceMatchMakingTurnShieldOffArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_TurnShieldOff_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingTurnShieldOffResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingTurnShieldOffResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingTurnShieldOffResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingTurnShieldOffResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingTurnShieldOffResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingTurnShieldOffResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingTurnShieldOff"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingIncrementShieldOnForArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingIncrementShieldOnForArgs {
  /// Number of minutes to increase the shield time for
  minutes: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingIncrementShieldOnForArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingIncrementShieldOnForArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingIncrementShieldOnForArgs.minutes", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingIncrementShieldOnForArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceMatchMakingIncrementShieldOnForArgs {
      minutes: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_IncrementShieldOnFor_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minutes", TType::I32, 1))?;
    o_prot.write_i32(self.minutes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingIncrementShieldOnForResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingIncrementShieldOnForResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingIncrementShieldOnForResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingIncrementShieldOnForResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingIncrementShieldOnForResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingIncrementShieldOnForResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingIncrementShieldOnFor"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingGetShieldExpiryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingGetShieldExpiryArgs {
  /// The player id or use null to retrieve for the current player
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingGetShieldExpiryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingGetShieldExpiryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingGetShieldExpiryArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingGetShieldExpiryArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceMatchMakingGetShieldExpiryArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_GetShieldExpiry_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingGetShieldExpiryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingGetShieldExpiryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingGetShieldExpiryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingGetShieldExpiryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingGetShieldExpiryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingGetShieldExpiryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingGetShieldExpiry"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersArgs {
  /// The range delta
  range_delta: i64,
  /// The maximum number of matches to return
  num_matches: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingFindPlayersArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersArgs.range_delta", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersArgs.num_matches", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceMatchMakingFindPlayersArgs {
      range_delta: f_1.expect("auto-generated code should have checked for presence of required fields"),
      num_matches: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_FindPlayers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rangeDelta", TType::I64, 1))?;
    o_prot.write_i64(self.range_delta)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numMatches", TType::I64, 2))?;
    o_prot.write_i64(self.num_matches)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingFindPlayersResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingFindPlayersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingFindPlayersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingFindPlayers"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs {
  /// The range delta
  range_delta: i64,
  /// The maximum number of matches to return
  num_matches: i64,
  /// Attributes match criteria
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs.range_delta", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs.num_matches", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs.json_attributes", &f_3)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceMatchMakingFindPlayersWithAttributesArgs {
      range_delta: f_1.expect("auto-generated code should have checked for presence of required fields"),
      num_matches: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_FindPlayersWithAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rangeDelta", TType::I64, 1))?;
    o_prot.write_i64(self.range_delta)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numMatches", TType::I64, 2))?;
    o_prot.write_i64(self.num_matches)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 3))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersWithAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersWithAttributesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingFindPlayersWithAttributesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersWithAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingFindPlayersWithAttributesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingFindPlayersWithAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingFindPlayersWithAttributes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs {
  /// The range delta
  range_delta: i64,
  /// The maximum number of matches to return
  num_matches: i64,
  /// Parameters to pass to the CloudCode filter script
  json_extra_parms: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs.range_delta", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs.num_matches", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs.json_extra_parms", &f_3)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceMatchMakingFindPlayersUsingFilterArgs {
      range_delta: f_1.expect("auto-generated code should have checked for presence of required fields"),
      num_matches: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_extra_parms: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_FindPlayersUsingFilter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rangeDelta", TType::I64, 1))?;
    o_prot.write_i64(self.range_delta)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numMatches", TType::I64, 2))?;
    o_prot.write_i64(self.num_matches)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonExtraParms", TType::String, 3))?;
    o_prot.write_string(&self.json_extra_parms)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersUsingFilterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersUsingFilterResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingFindPlayersUsingFilterResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersUsingFilterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingFindPlayersUsingFilterResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingFindPlayersUsingFilterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingFindPlayersUsingFilter"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs {
  /// The range delta
  range_delta: i64,
  /// The maximum number of matches to return
  num_matches: i64,
  /// Attributes match criteria
  json_attributes: String,
  /// Parameters to pass to the CloudCode filter script
  json_extra_parms: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i64> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i64()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs.range_delta", &f_1)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs.num_matches", &f_2)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs.json_attributes", &f_3)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs.json_extra_parms", &f_4)?;
    verify_required_field_exists("BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterArgs {
      range_delta: f_1.expect("auto-generated code should have checked for presence of required fields"),
      num_matches: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_extra_parms: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_FindPlayersWithAttributesUsingFilter_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rangeDelta", TType::I64, 1))?;
    o_prot.write_i64(self.range_delta)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numMatches", TType::I64, 2))?;
    o_prot.write_i64(self.num_matches)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 3))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonExtraParms", TType::String, 4))?;
    o_prot.write_string(&self.json_extra_parms)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilterResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingFindPlayersWithAttributesUsingFilter"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingEnableMatchMakingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingEnableMatchMakingArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingEnableMatchMakingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingEnableMatchMakingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingEnableMatchMakingArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceMatchMakingEnableMatchMakingArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_EnableMatchMaking_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingEnableMatchMakingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingEnableMatchMakingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingEnableMatchMakingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingEnableMatchMakingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingEnableMatchMakingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingEnableMatchMakingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingEnableMatchMaking"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceMatchMakingDisableMatchMakingArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingDisableMatchMakingArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceMatchMakingDisableMatchMakingArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingDisableMatchMakingArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceMatchMakingDisableMatchMakingArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceMatchMakingDisableMatchMakingArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("MatchMaking_DisableMatchMaking_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceMatchMakingDisableMatchMakingResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceMatchMakingDisableMatchMakingResult {
  result_value: Option<String>,
}

impl BrainCloudServiceMatchMakingDisableMatchMakingResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceMatchMakingDisableMatchMakingResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceMatchMakingDisableMatchMakingResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceMatchMakingDisableMatchMakingResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceMatchMakingDisableMatchMaking"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceOneWayMatchStartMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceOneWayMatchStartMatchArgs {
  /// The player to start a match with
  other_player_id: String,
  /// The range delta used for the initial match search
  range_delta: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceOneWayMatchStartMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceOneWayMatchStartMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchStartMatchArgs.other_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchStartMatchArgs.range_delta", &f_2)?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchStartMatchArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceOneWayMatchStartMatchArgs {
      other_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      range_delta: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OneWayMatch_StartMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("otherPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.other_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rangeDelta", TType::I64, 2))?;
    o_prot.write_i64(self.range_delta)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceOneWayMatchStartMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceOneWayMatchStartMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceOneWayMatchStartMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceOneWayMatchStartMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceOneWayMatchStartMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceOneWayMatchStartMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceOneWayMatchStartMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceOneWayMatchCancelMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceOneWayMatchCancelMatchArgs {
  /// The playback stream id returned in the start match
  playback_stream_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceOneWayMatchCancelMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceOneWayMatchCancelMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchCancelMatchArgs.playback_stream_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchCancelMatchArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceOneWayMatchCancelMatchArgs {
      playback_stream_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OneWayMatch_CancelMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playbackStreamId", TType::String, 1))?;
    o_prot.write_string(&self.playback_stream_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceOneWayMatchCancelMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceOneWayMatchCancelMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceOneWayMatchCancelMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceOneWayMatchCancelMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceOneWayMatchCancelMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceOneWayMatchCancelMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceOneWayMatchCancelMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceOneWayMatchCompleteMatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceOneWayMatchCompleteMatchArgs {
  /// The playback stream id returned in the initial start match
  playback_stream_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceOneWayMatchCompleteMatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceOneWayMatchCompleteMatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchCompleteMatchArgs.playback_stream_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceOneWayMatchCompleteMatchArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceOneWayMatchCompleteMatchArgs {
      playback_stream_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("OneWayMatch_CompleteMatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playbackStreamId", TType::String, 1))?;
    o_prot.write_string(&self.playback_stream_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceOneWayMatchCompleteMatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceOneWayMatchCompleteMatchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceOneWayMatchCompleteMatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceOneWayMatchCompleteMatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceOneWayMatchCompleteMatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceOneWayMatchCompleteMatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceOneWayMatchCompleteMatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamStartStreamArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamStartStreamArgs {
  /// The player to start a stream with
  target_player_id: String,
  /// Whether to include shared data in the stream
  include_shared_data: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamStartStreamArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamStartStreamArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamStartStreamArgs.target_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamStartStreamArgs.include_shared_data", &f_2)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamStartStreamArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePlaybackStreamStartStreamArgs {
      target_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_shared_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_StartStream_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("targetPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.target_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeSharedData", TType::Bool, 2))?;
    o_prot.write_bool(self.include_shared_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamStartStreamResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamStartStreamResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamStartStreamResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamStartStreamResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamStartStreamResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamStartStreamResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamStartStream"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamReadStreamArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamReadStreamArgs {
  /// Identifies the stream to read
  playback_stream_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamReadStreamArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamReadStreamArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamReadStreamArgs.playback_stream_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamReadStreamArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlaybackStreamReadStreamArgs {
      playback_stream_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_ReadStream_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playbackStreamId", TType::String, 1))?;
    o_prot.write_string(&self.playback_stream_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamReadStreamResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamReadStreamResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamReadStreamResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamReadStreamResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamReadStreamResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamReadStreamResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamReadStream"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamEndStreamArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamEndStreamArgs {
  /// Identifies the stream to read
  playback_stream_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamEndStreamArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamEndStreamArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamEndStreamArgs.playback_stream_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamEndStreamArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlaybackStreamEndStreamArgs {
      playback_stream_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_EndStream_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playbackStreamId", TType::String, 1))?;
    o_prot.write_string(&self.playback_stream_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamEndStreamResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamEndStreamResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamEndStreamResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamEndStreamResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamEndStreamResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamEndStreamResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamEndStream"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamDeleteStreamArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamDeleteStreamArgs {
  /// Identifies the stream to read
  playback_stream_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamDeleteStreamArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamDeleteStreamArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamDeleteStreamArgs.playback_stream_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamDeleteStreamArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlaybackStreamDeleteStreamArgs {
      playback_stream_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_DeleteStream_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playbackStreamId", TType::String, 1))?;
    o_prot.write_string(&self.playback_stream_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamDeleteStreamResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamDeleteStreamResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamDeleteStreamResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamDeleteStreamResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamDeleteStreamResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamDeleteStreamResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamDeleteStream"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamAddEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamAddEventArgs {
  /// Identifies the stream to read
  playback_stream_id: String,
  /// Describes the event
  event_data: String,
  /// Current summary data as of this event
  summary: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamAddEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamAddEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamAddEventArgs.playback_stream_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamAddEventArgs.event_data", &f_2)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamAddEventArgs.summary", &f_3)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamAddEventArgs.client_index", &f_4)?;
    let ret = BrainCloudServicePlaybackStreamAddEventArgs {
      playback_stream_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      event_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      summary: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_AddEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playbackStreamId", TType::String, 1))?;
    o_prot.write_string(&self.playback_stream_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventData", TType::String, 2))?;
    o_prot.write_string(&self.event_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("summary", TType::String, 3))?;
    o_prot.write_string(&self.summary)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamAddEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamAddEventResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamAddEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamAddEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamAddEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamAddEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamAddEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs {
  /// The player that started the stream
  initiating_player_id: String,
  /// The player that started the stream
  max_num_streams: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs.initiating_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs.max_num_streams", &f_2)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerArgs {
      initiating_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_num_streams: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_GetRecentStreamsForInitiatingPlayer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("initiatingPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.initiating_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxNumStreams", TType::I32, 2))?;
    o_prot.write_i32(self.max_num_streams)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamGetRecentStreamsForInitiatingPlayer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs {
  /// The player that started the stream
  target_player_id: String,
  /// The player that started the stream
  max_num_streams: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs.target_player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs.max_num_streams", &f_2)?;
    verify_required_field_exists("BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerArgs {
      target_player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_num_streams: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlaybackStream_GetRecentStreamsForTargetPlayer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("targetPlayerId", TType::String, 1))?;
    o_prot.write_string(&self.target_player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxNumStreams", TType::I32, 2))?;
    o_prot.write_i32(self.max_num_streams)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlaybackStreamGetRecentStreamsForTargetPlayer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateReadUserStateArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateReadUserStateArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateReadUserStateArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateReadUserStateArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateReadUserStateArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStateReadUserStateArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_ReadUserState_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateReadUserStateResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateReadUserStateResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateReadUserStateResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateReadUserStateResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateReadUserStateResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateReadUserStateResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateReadUserState"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateDeleteUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateDeleteUserArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateDeleteUserArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateDeleteUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateDeleteUserArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStateDeleteUserArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_DeleteUser_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateDeleteUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateDeleteUserResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateDeleteUserResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateDeleteUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateDeleteUserResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateDeleteUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateDeleteUser"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateResetUserArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateResetUserArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateResetUserArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateResetUserArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateResetUserArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStateResetUserArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_ResetUser_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateResetUserResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateResetUserResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateResetUserResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateResetUserResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateResetUserResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateResetUserResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateResetUser"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateLogoutArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateLogoutArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateLogoutArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateLogoutArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateLogoutArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStateLogoutArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_Logout_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateLogoutResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateLogoutResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateLogoutResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateLogoutResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateLogoutResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateLogoutResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateLogout"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateUpdateUserNameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateUserNameArgs {
  /// The name of the user
  user_name: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateUpdateUserNameArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateUserNameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateUserNameArgs.user_name", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateUserNameArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStateUpdateUserNameArgs {
      user_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_UpdateUserName_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userName", TType::String, 1))?;
    o_prot.write_string(&self.user_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateUpdateUserNameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateUserNameResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateUpdateUserNameResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateUserNameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateUpdateUserNameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateUpdateUserNameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateUpdateUserName"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs {
  /// A JSON string defining the summary data.
  /// For example:
  /// {
  ///   "xp":123,
  ///   "level":12,
  ///   "highScore":45123
  /// }
  json_summary_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs.json_summary_data", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStateUpdateSummaryFriendDataArgs {
      json_summary_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_UpdateSummaryFriendData_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonSummaryData", TType::String, 1))?;
    o_prot.write_string(&self.json_summary_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateUpdateSummaryFriendDataResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateSummaryFriendDataResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateUpdateSummaryFriendDataResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateSummaryFriendDataResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateUpdateSummaryFriendDataResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateUpdateSummaryFriendDataResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateUpdateSummaryFriendData"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateGetAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateGetAttributesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateGetAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateGetAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateGetAttributesArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStateGetAttributesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_GetAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateGetAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateGetAttributesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateGetAttributesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateGetAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateGetAttributesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateGetAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateGetAttributes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateUpdateAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateAttributesArgs {
  /// Single layer json string that is a set of key-value pairs
  json_attributes: String,
  /// Whether to wipe existing attributes prior to update.
  wipe_existing: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateUpdateAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateAttributesArgs.json_attributes", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateAttributesArgs.wipe_existing", &f_2)?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateAttributesArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePlayerStateUpdateAttributesArgs {
      json_attributes: f_1.expect("auto-generated code should have checked for presence of required fields"),
      wipe_existing: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_UpdateAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 1))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("wipeExisting", TType::Bool, 2))?;
    o_prot.write_bool(self.wipe_existing)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateUpdateAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateAttributesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateUpdateAttributesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateUpdateAttributesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateUpdateAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateUpdateAttributes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateRemoveAttributesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateRemoveAttributesArgs {
  /// List of attribute names.
  attribute_names: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateRemoveAttributesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateRemoveAttributesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_11 = i_prot.read_string()?;
            val.push(list_elem_11);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateRemoveAttributesArgs.attribute_names", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStateRemoveAttributesArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStateRemoveAttributesArgs {
      attribute_names: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_RemoveAttributes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("attributeNames", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.attribute_names.len() as i32))?;
    for e in &self.attribute_names {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateRemoveAttributesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateRemoveAttributesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateRemoveAttributesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateRemoveAttributesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateRemoveAttributesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateRemoveAttributesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateRemoveAttributes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateUpdateUserPictureUrlArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateUserPictureUrlArgs {
  /// URL to apply.
  picture_url: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateUpdateUserPictureUrlArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateUserPictureUrlArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateUserPictureUrlArgs.picture_url", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateUserPictureUrlArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStateUpdateUserPictureUrlArgs {
      picture_url: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_UpdateUserPictureUrl_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pictureUrl", TType::String, 1))?;
    o_prot.write_string(&self.picture_url)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateUpdateUserPictureUrlResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateUserPictureUrlResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateUpdateUserPictureUrlResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateUserPictureUrlResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateUpdateUserPictureUrlResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateUpdateUserPictureUrlResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateUpdateUserPictureUrl"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStateUpdateContactEmailArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateContactEmailArgs {
  /// Updated email
  contact_email: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStateUpdateContactEmailArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateContactEmailArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateContactEmailArgs.contact_email", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStateUpdateContactEmailArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStateUpdateContactEmailArgs {
      contact_email: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerState_UpdateContactEmail_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("contactEmail", TType::String, 1))?;
    o_prot.write_string(&self.contact_email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStateUpdateContactEmailResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStateUpdateContactEmailResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStateUpdateContactEmailResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStateUpdateContactEmailResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStateUpdateContactEmailResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStateUpdateContactEmailResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStateUpdateContactEmail"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsReadAllUserStatsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsReadAllUserStatsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsReadAllUserStatsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsReadAllUserStatsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsReadAllUserStatsArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStatisticsReadAllUserStatsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_ReadAllUserStats_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsReadAllUserStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsReadAllUserStatsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsReadAllUserStatsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsReadAllUserStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsReadAllUserStatsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsReadAllUserStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsReadAllUserStats"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs {
  player_stats: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_12 = i_prot.read_string()?;
            val.push(list_elem_12);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs.player_stats", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsReadUserStatsSubsetArgs {
      player_stats: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_ReadUserStatsSubset_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerStats", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.player_stats.len() as i32))?;
    for e in &self.player_stats {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsReadUserStatsSubsetResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsReadUserStatsSubset"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs {
  /// The user statistics category
  category: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs.category", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsReadUserStatsForCategoryArgs {
      category: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_ReadUserStatsForCategory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 1))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsReadUserStatsForCategoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsReadUserStatsForCategory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsResetAllUserStatsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsResetAllUserStatsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsResetAllUserStatsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsResetAllUserStatsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsResetAllUserStatsArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStatisticsResetAllUserStatsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_ResetAllUserStats_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsResetAllUserStatsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsResetAllUserStatsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsResetAllUserStatsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsResetAllUserStatsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsResetAllUserStatsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsResetAllUserStatsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsResetAllUserStats"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs {
  /// The JSON encoded data to be sent to the server as follows:
  /// {
  ///   stat1: 10,
  ///   stat2: -5.5,
  /// }
  /// would increment stat1 by 10 and decrement stat2 by 5.5.
  /// For the full statistics grammer see the api.braincloudservers.com site.
  /// There are many more complex operations supported such as:
  /// {
  ///   stat1:INC_TO_LIMIT#9#30
  /// }
  /// which increments stat1 by 9 up to a limit of 30.
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs.json_data", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOArgs {
      json_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_IncrementUserStats_SSFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 1))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsIncrementUserStatsSSFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsIncrementUserStatsSSFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs {
  /// Stats name and their increments:
  /// {
  ///  {"stat1", 10},
  ///  {"stat1", -5}
  /// }
  /// 
  /// would increment stat1 by 10 and decrement stat2 by 5.
  /// For the full statistics grammer see the api.braincloudservers.com site.
  /// There are many more complex operations supported such as:
  /// {
  ///   stat1:INC_TO_LIMIT#9#30
  /// }
  /// which increments stat1 by 9 up to a limit of 30.
  dict_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_13 = i_prot.read_string()?;
            let map_val_14 = i_prot.read_string()?;
            val.insert(map_key_13, map_val_14);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs.dict_data", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOArgs {
      dict_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_IncrementUserStats_DSFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("dictData", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.dict_data.len() as i32))?;
    for (k, v) in &self.dict_data {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsIncrementUserStatsDSFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsIncrementUserStatsDSFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsProcessStatisticsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsProcessStatisticsArgs {
  /// Example data to be passed to method:
  /// {
  ///     "DEAD_CATS": "RESET",
  ///     "LIVES_LEFT": "SET#9",
  ///     "MICE_KILLED": "INC#2",
  ///     "DOG_SCARE_BONUS_POINTS": "INC#10",
  ///     "TREES_CLIMBED": 1
  /// }
  statistics_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsProcessStatisticsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsProcessStatisticsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_15 = i_prot.read_string()?;
            let map_val_16 = i_prot.read_string()?;
            val.insert(map_key_15, map_val_16);
          }
          i_prot.read_map_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsProcessStatisticsArgs.statistics_data", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsProcessStatisticsArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsProcessStatisticsArgs {
      statistics_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_ProcessStatistics_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("statisticsData", TType::Map, 1))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.statistics_data.len() as i32))?;
    for (k, v) in &self.statistics_data {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsProcessStatisticsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsProcessStatisticsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsProcessStatisticsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsProcessStatisticsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsProcessStatisticsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsProcessStatisticsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsProcessStatistics"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePlayerStatisticsGetNextExperienceLevelArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_GetNextExperienceLevel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsGetNextExperienceLevelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsGetNextExperienceLevel"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs {
  /// The amount to increase the user's experience by
  xp_value: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs.xp_value", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsIncrementExperiencePointsArgs {
      xp_value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_IncrementExperiencePoints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("xpValue", TType::I32, 1))?;
    o_prot.write_i32(self.xp_value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsIncrementExperiencePointsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsIncrementExperiencePoints"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsSetExperiencePointsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsSetExperiencePointsArgs {
  /// The amount to set the the player's experience to
  xp_value: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsSetExperiencePointsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsSetExperiencePointsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsSetExperiencePointsArgs.xp_value", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsSetExperiencePointsArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsSetExperiencePointsArgs {
      xp_value: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatistics_SetExperiencePoints_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("xpValue", TType::I32, 1))?;
    o_prot.write_i32(self.xp_value)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsSetExperiencePointsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsSetExperiencePointsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsSetExperiencePointsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsSetExperiencePointsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsSetExperiencePointsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsSetExperiencePointsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsSetExperiencePoints"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs {
  event_name: String,
  event_multiplier: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs.event_name", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs.event_multiplier", &f_2)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePlayerStatisticsEventTriggerStatsEventArgs {
      event_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      event_multiplier: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventName", TType::String, 1))?;
    o_prot.write_string(&self.event_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventMultiplier", TType::I32, 2))?;
    o_prot.write_i32(self.event_multiplier)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsEventTriggerStatsEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsEventTriggerStatsEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs {
  /// jsonData
  /// [
  ///   {
  ///     "eventName": "event1",
  ///     "eventMultiplier": 1
  ///   },
  ///   {
  ///     "eventName": "event2",
  ///     "eventMultiplier": 1
  ///   }
  /// ]
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs.json_data", &f_1)?;
    verify_required_field_exists("BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePlayerStatisticsEventTriggerStatsEventsArgs {
      json_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PlayerStatisticsEvent_TriggerStatsEvents_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 1))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePlayerStatisticsEventTriggerStatsEventsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePlayerStatisticsEventTriggerStatsEvents"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProductGetCurrencyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetCurrencyArgs {
  /// The currency type to retrieve or null
  /// if all currency types are being requested.
  currency_type: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProductGetCurrencyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetCurrencyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProductGetCurrencyArgs.currency_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProductGetCurrencyArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceProductGetCurrencyArgs {
      currency_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product_GetCurrency_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("currencyType", TType::String, 1))?;
    o_prot.write_string(&self.currency_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProductGetCurrencyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetCurrencyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProductGetCurrencyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetCurrencyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProductGetCurrencyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProductGetCurrencyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProductGetCurrency"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProductGetSalesInventoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetSalesInventoryArgs {
  /// The store platform. Valid stores are:
  /// - itunes
  /// - facebook
  /// - appworld
  /// - steam
  /// - windows
  /// - windowsPhone
  /// - googlePlay
  platform: String,
  /// The currency to retrieve the sales
  /// inventory for. This is only used for Steam and Facebook stores.
  user_currency: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProductGetSalesInventoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetSalesInventoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryArgs.platform", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryArgs.user_currency", &f_2)?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceProductGetSalesInventoryArgs {
      platform: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_currency: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product_GetSalesInventory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::String, 1))?;
    o_prot.write_string(&self.platform)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userCurrency", TType::String, 2))?;
    o_prot.write_string(&self.user_currency)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProductGetSalesInventoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetSalesInventoryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProductGetSalesInventoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetSalesInventoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProductGetSalesInventoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProductGetSalesInventoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProductGetSalesInventory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProductGetSalesInventoryByCategoryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetSalesInventoryByCategoryArgs {
  /// The store platform. Valid stores are:
  /// - itunes
  /// - facebook
  /// - appworld
  /// - steam
  /// - windows
  /// - windowsPhone
  /// - googlePlay
  platform: String,
  /// The currency to retrieve the sales
  /// inventory for. This is only used for Steam and Facebook stores.
  user_currency: String,
  /// The product category
  category: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProductGetSalesInventoryByCategoryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetSalesInventoryByCategoryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryByCategoryArgs.platform", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryByCategoryArgs.user_currency", &f_2)?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryByCategoryArgs.category", &f_3)?;
    verify_required_field_exists("BrainCloudServiceProductGetSalesInventoryByCategoryArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceProductGetSalesInventoryByCategoryArgs {
      platform: f_1.expect("auto-generated code should have checked for presence of required fields"),
      user_currency: f_2.expect("auto-generated code should have checked for presence of required fields"),
      category: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product_GetSalesInventoryByCategory_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::String, 1))?;
    o_prot.write_string(&self.platform)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("userCurrency", TType::String, 2))?;
    o_prot.write_string(&self.user_currency)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("category", TType::String, 3))?;
    o_prot.write_string(&self.category)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProductGetSalesInventoryByCategoryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetSalesInventoryByCategoryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProductGetSalesInventoryByCategoryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetSalesInventoryByCategoryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProductGetSalesInventoryByCategoryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProductGetSalesInventoryByCategoryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProductGetSalesInventoryByCategory"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProductVerifyMicrosoftReceiptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductVerifyMicrosoftReceiptArgs {
  /// Receipt XML
  receipt: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProductVerifyMicrosoftReceiptArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductVerifyMicrosoftReceiptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProductVerifyMicrosoftReceiptArgs.receipt", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProductVerifyMicrosoftReceiptArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceProductVerifyMicrosoftReceiptArgs {
      receipt: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product_VerifyMicrosoftReceipt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("receipt", TType::String, 1))?;
    o_prot.write_string(&self.receipt)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProductVerifyMicrosoftReceiptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductVerifyMicrosoftReceiptResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProductVerifyMicrosoftReceiptResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductVerifyMicrosoftReceiptResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProductVerifyMicrosoftReceiptResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProductVerifyMicrosoftReceiptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProductVerifyMicrosoftReceipt"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProductGetEligiblePromotionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetEligiblePromotionsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProductGetEligiblePromotionsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetEligiblePromotionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProductGetEligiblePromotionsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceProductGetEligiblePromotionsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product_GetEligiblePromotions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProductGetEligiblePromotionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductGetEligiblePromotionsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProductGetEligiblePromotionsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductGetEligiblePromotionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProductGetEligiblePromotionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProductGetEligiblePromotionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProductGetEligiblePromotions"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProductVerifyItunesReceiptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductVerifyItunesReceiptArgs {
  /// Base64 encoded receipt data
  base64_enc_receipt_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProductVerifyItunesReceiptArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductVerifyItunesReceiptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProductVerifyItunesReceiptArgs.base64_enc_receipt_data", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProductVerifyItunesReceiptArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceProductVerifyItunesReceiptArgs {
      base64_enc_receipt_data: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Product_VerifyItunesReceipt_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("base64EncReceiptData", TType::String, 1))?;
    o_prot.write_string(&self.base64_enc_receipt_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProductVerifyItunesReceiptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProductVerifyItunesReceiptResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProductVerifyItunesReceiptResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProductVerifyItunesReceiptResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProductVerifyItunesReceiptResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProductVerifyItunesReceiptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProductVerifyItunesReceipt"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProfanityProfanityCheckArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProfanityProfanityCheckArgs {
  /// The text to check
  text: String,
  /// Optional comma delimited list of two character language codes
  languages: String,
  /// Optional processing of email addresses
  flag_email: bool,
  /// Optional processing of phone numbers
  flag_phone: bool,
  /// Optional processing of urls
  flag_urls: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProfanityProfanityCheckArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProfanityProfanityCheckArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityCheckArgs.text", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityCheckArgs.languages", &f_2)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityCheckArgs.flag_email", &f_3)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityCheckArgs.flag_phone", &f_4)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityCheckArgs.flag_urls", &f_5)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityCheckArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceProfanityProfanityCheckArgs {
      text: f_1.expect("auto-generated code should have checked for presence of required fields"),
      languages: f_2.expect("auto-generated code should have checked for presence of required fields"),
      flag_email: f_3.expect("auto-generated code should have checked for presence of required fields"),
      flag_phone: f_4.expect("auto-generated code should have checked for presence of required fields"),
      flag_urls: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Profanity_ProfanityCheck_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 1))?;
    o_prot.write_string(&self.text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("languages", TType::String, 2))?;
    o_prot.write_string(&self.languages)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagEmail", TType::Bool, 3))?;
    o_prot.write_bool(self.flag_email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagPhone", TType::Bool, 4))?;
    o_prot.write_bool(self.flag_phone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagUrls", TType::Bool, 5))?;
    o_prot.write_bool(self.flag_urls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProfanityProfanityCheckResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProfanityProfanityCheckResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProfanityProfanityCheckResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProfanityProfanityCheckResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProfanityProfanityCheckResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProfanityProfanityCheckResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProfanityProfanityCheck"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProfanityProfanityReplaceTextArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProfanityProfanityReplaceTextArgs {
  /// The text to check
  text: String,
  /// The text to replace individual characters of profanity text with
  replace_symbol: String,
  /// Optional comma delimited list of two character language codes
  languages: String,
  /// Optional processing of email addresses
  flag_email: bool,
  /// Optional processing of phone numbers
  flag_phone: bool,
  /// Optional processing of urls
  flag_urls: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProfanityProfanityReplaceTextArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProfanityProfanityReplaceTextArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<bool> = None;
    let mut f_7: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.text", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.replace_symbol", &f_2)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.languages", &f_3)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.flag_email", &f_4)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.flag_phone", &f_5)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.flag_urls", &f_6)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityReplaceTextArgs.client_index", &f_7)?;
    let ret = BrainCloudServiceProfanityProfanityReplaceTextArgs {
      text: f_1.expect("auto-generated code should have checked for presence of required fields"),
      replace_symbol: f_2.expect("auto-generated code should have checked for presence of required fields"),
      languages: f_3.expect("auto-generated code should have checked for presence of required fields"),
      flag_email: f_4.expect("auto-generated code should have checked for presence of required fields"),
      flag_phone: f_5.expect("auto-generated code should have checked for presence of required fields"),
      flag_urls: f_6.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_7.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Profanity_ProfanityReplaceText_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 1))?;
    o_prot.write_string(&self.text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replaceSymbol", TType::String, 2))?;
    o_prot.write_string(&self.replace_symbol)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("languages", TType::String, 3))?;
    o_prot.write_string(&self.languages)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagEmail", TType::Bool, 4))?;
    o_prot.write_bool(self.flag_email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagPhone", TType::Bool, 5))?;
    o_prot.write_bool(self.flag_phone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagUrls", TType::Bool, 6))?;
    o_prot.write_bool(self.flag_urls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 7))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProfanityProfanityReplaceTextResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProfanityProfanityReplaceTextResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProfanityProfanityReplaceTextResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProfanityProfanityReplaceTextResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProfanityProfanityReplaceTextResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProfanityProfanityReplaceTextResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProfanityProfanityReplaceText"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs {
  /// The text to check
  text: String,
  /// Optional comma delimited list of two character language codes
  languages: String,
  /// Optional processing of email addresses
  flag_email: bool,
  /// Optional processing of phone numbers
  flag_phone: bool,
  /// Optional processing of urls
  flag_urls: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<bool> = None;
    let mut f_5: Option<bool> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs.text", &f_1)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs.languages", &f_2)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs.flag_email", &f_3)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs.flag_phone", &f_4)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs.flag_urls", &f_5)?;
    verify_required_field_exists("BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceProfanityProfanityIdentifyBadWordsArgs {
      text: f_1.expect("auto-generated code should have checked for presence of required fields"),
      languages: f_2.expect("auto-generated code should have checked for presence of required fields"),
      flag_email: f_3.expect("auto-generated code should have checked for presence of required fields"),
      flag_phone: f_4.expect("auto-generated code should have checked for presence of required fields"),
      flag_urls: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Profanity_ProfanityIdentifyBadWords_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("text", TType::String, 1))?;
    o_prot.write_string(&self.text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("languages", TType::String, 2))?;
    o_prot.write_string(&self.languages)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagEmail", TType::Bool, 3))?;
    o_prot.write_bool(self.flag_email)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagPhone", TType::Bool, 4))?;
    o_prot.write_bool(self.flag_phone)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("flagUrls", TType::Bool, 5))?;
    o_prot.write_bool(self.flag_urls)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceProfanityProfanityIdentifyBadWordsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceProfanityProfanityIdentifyBadWordsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceProfanityProfanityIdentifyBadWordsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceProfanityProfanityIdentifyBadWordsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceProfanityProfanityIdentifyBadWordsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceProfanityProfanityIdentifyBadWordsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceProfanityProfanityIdentifyBadWords"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_DeregisterAllPushNotificationDeviceTokens_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokensResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationDeregisterAllPushNotificationDeviceTokens"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs {
  /// The device platform being registered.
  platform: String,
  /// The platform-dependant device token needed for push notifications.
  token: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs.platform", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs.token", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenArgs {
      platform: f_1.expect("auto-generated code should have checked for presence of required fields"),
      token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_DeregisterPushNotificationDeviceToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::String, 1))?;
    o_prot.write_string(&self.platform)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
    o_prot.write_string(&self.token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationDeregisterPushNotificationDeviceTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationDeregisterPushNotificationDeviceToken"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs {
  platform: String,
  /// The platform-dependant device token needed for push notifications.
  token: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs.platform", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs.token", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenArgs {
      platform: f_1.expect("auto-generated code should have checked for presence of required fields"),
      token: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_RegisterPushNotificationDeviceToken_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("platform", TType::String, 1))?;
    o_prot.write_string(&self.platform)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("token", TType::String, 2))?;
    o_prot.write_string(&self.token)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationRegisterPushNotificationDeviceTokenResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationRegisterPushNotificationDeviceToken"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendSimplePushNotificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendSimplePushNotificationArgs {
  /// The braincloud profileId of the user to receive the notification
  to_profile_id: String,
  /// Text of the push notification
  message: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendSimplePushNotificationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendSimplePushNotificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendSimplePushNotificationArgs.to_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendSimplePushNotificationArgs.message", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendSimplePushNotificationArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePushNotificationSendSimplePushNotificationArgs {
      to_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      message: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendSimplePushNotification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toProfileId", TType::String, 1))?;
    o_prot.write_string(&self.to_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("message", TType::String, 2))?;
    o_prot.write_string(&self.message)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendSimplePushNotificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendSimplePushNotificationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendSimplePushNotificationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendSimplePushNotificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendSimplePushNotificationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendSimplePushNotificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendSimplePushNotification"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendRichPushNotificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRichPushNotificationArgs {
  /// The braincloud profileId of the user to receive the notification
  to_profile_id: String,
  /// Id of the notification template
  notification_template_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendRichPushNotificationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRichPushNotificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationArgs.to_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationArgs.notification_template_id", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationArgs.client_index", &f_3)?;
    let ret = BrainCloudServicePushNotificationSendRichPushNotificationArgs {
      to_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notification_template_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendRichPushNotification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toProfileId", TType::String, 1))?;
    o_prot.write_string(&self.to_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationTemplateId", TType::I32, 2))?;
    o_prot.write_i32(self.notification_template_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendRichPushNotificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRichPushNotificationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendRichPushNotificationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRichPushNotificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendRichPushNotificationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendRichPushNotificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendRichPushNotification"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs {
  /// The braincloud profileId of the user to receive the notification
  to_profile_id: String,
  /// Id of the notification template
  notification_template_id: i32,
  /// JSON defining the substitution params to use with the template
  substitution_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs.to_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs.notification_template_id", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs.substitution_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs.client_index", &f_4)?;
    let ret = BrainCloudServicePushNotificationSendRichPushNotificationWithParamsArgs {
      to_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notification_template_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      substitution_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendRichPushNotificationWithParams_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toProfileId", TType::String, 1))?;
    o_prot.write_string(&self.to_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationTemplateId", TType::I32, 2))?;
    o_prot.write_i32(self.notification_template_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("substitutionJson", TType::String, 3))?;
    o_prot.write_string(&self.substitution_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendRichPushNotificationWithParamsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendRichPushNotificationWithParams"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs {
  /// Target group
  group_id: String,
  /// Id of the notification template
  notification_template_id: i32,
  /// JSON defining the substitution params to use with the template
  substitutions_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs.notification_template_id", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs.substitutions_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs.client_index", &f_4)?;
    let ret = BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notification_template_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      substitutions_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendTemplatedPushNotificationToGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationTemplateId", TType::I32, 2))?;
    o_prot.write_i32(self.notification_template_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("substitutionsJson", TType::String, 3))?;
    o_prot.write_string(&self.substitutions_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendTemplatedPushNotificationToGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs {
  /// Target group
  group_id: String,
  /// Body and title of alert
  alert_content_json: String,
  /// Optional custom data
  custom_data_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs.alert_content_json", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs.custom_data_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs.client_index", &f_4)?;
    let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      alert_content_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      custom_data_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendNormalizedPushNotificationToGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("alertContentJson", TType::String, 2))?;
    o_prot.write_string(&self.alert_content_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customDataJson", TType::String, 3))?;
    o_prot.write_string(&self.custom_data_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendNormalizedPushNotificationToGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs {
  /// The profileId of the user to receive the notification
  profile_id: String,
  /// Valid Fcm data content
  fcm_content: String,
  /// Valid ios data content
  ios_content: String,
  /// Facebook template string
  facebook_content: String,
  /// Start time of sending the push notification
  start_time: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs.fcm_content", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs.ios_content", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs.facebook_content", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs.start_time", &f_5)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs.client_index", &f_6)?;
    let ret = BrainCloudServicePushNotificationScheduleRawPushNotificationUTCArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      fcm_content: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ios_content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      facebook_content: f_4.expect("auto-generated code should have checked for presence of required fields"),
      start_time: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_ScheduleRawPushNotificationUTC_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fcmContent", TType::String, 2))?;
    o_prot.write_string(&self.fcm_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iosContent", TType::String, 3))?;
    o_prot.write_string(&self.ios_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("facebookContent", TType::String, 4))?;
    o_prot.write_string(&self.facebook_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I32, 5))?;
    o_prot.write_i32(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationScheduleRawPushNotificationUTCResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationScheduleRawPushNotificationUTC"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs {
  /// The profileId of the user to receive the notification
  profile_id: String,
  /// Valid Fcm data content
  fcm_content: String,
  /// Valid ios data content
  ios_content: String,
  /// Facebook template string
  facebook_content: String,
  /// Minutes from now to send the push notification
  minutes_from_now: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs.fcm_content", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs.ios_content", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs.facebook_content", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs.minutes_from_now", &f_5)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs.client_index", &f_6)?;
    let ret = BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      fcm_content: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ios_content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      facebook_content: f_4.expect("auto-generated code should have checked for presence of required fields"),
      minutes_from_now: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_ScheduleRawPushNotificationMinutes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fcmContent", TType::String, 2))?;
    o_prot.write_string(&self.fcm_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iosContent", TType::String, 3))?;
    o_prot.write_string(&self.ios_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("facebookContent", TType::String, 4))?;
    o_prot.write_string(&self.facebook_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minutesFromNow", TType::I32, 5))?;
    o_prot.write_i32(self.minutes_from_now)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationScheduleRawPushNotificationMinutesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationScheduleRawPushNotificationMinutes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendRawPushNotificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRawPushNotificationArgs {
  /// The profileId of the user to receive the notification
  to_profile_id: String,
  /// Valid Fcm data content
  fcm_content: String,
  /// Valid ios data content
  ios_content: String,
  /// Facebook template string
  facebook_content: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendRawPushNotificationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRawPushNotificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationArgs.to_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationArgs.fcm_content", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationArgs.ios_content", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationArgs.facebook_content", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationSendRawPushNotificationArgs {
      to_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      fcm_content: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ios_content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      facebook_content: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendRawPushNotification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toProfileId", TType::String, 1))?;
    o_prot.write_string(&self.to_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fcmContent", TType::String, 2))?;
    o_prot.write_string(&self.fcm_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iosContent", TType::String, 3))?;
    o_prot.write_string(&self.ios_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("facebookContent", TType::String, 4))?;
    o_prot.write_string(&self.facebook_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendRawPushNotificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRawPushNotificationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendRawPushNotificationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRawPushNotificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendRawPushNotificationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendRawPushNotificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendRawPushNotification"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs {
  /// Collection of profile IDs to send the notification to
  profile_ids: Vec<String>,
  /// Valid Fcm data content
  fcm_content: String,
  /// Valid ios data content
  ios_content: String,
  /// Facebook template string
  facebook_content: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_17 = i_prot.read_string()?;
            val.push(list_elem_17);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs.profile_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs.fcm_content", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs.ios_content", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs.facebook_content", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationSendRawPushNotificationBatchArgs {
      profile_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      fcm_content: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ios_content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      facebook_content: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendRawPushNotificationBatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.profile_ids.len() as i32))?;
    for e in &self.profile_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fcmContent", TType::String, 2))?;
    o_prot.write_string(&self.fcm_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iosContent", TType::String, 3))?;
    o_prot.write_string(&self.ios_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("facebookContent", TType::String, 4))?;
    o_prot.write_string(&self.facebook_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendRawPushNotificationBatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRawPushNotificationBatchResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendRawPushNotificationBatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRawPushNotificationBatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendRawPushNotificationBatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendRawPushNotificationBatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendRawPushNotificationBatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs {
  /// Target group
  group_id: String,
  /// Valid Fcm data content
  fcm_content: String,
  /// Valid ios data content
  ios_content: String,
  /// Facebook template string
  facebook_content: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs.group_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs.fcm_content", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs.ios_content", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs.facebook_content", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationSendRawPushNotificationToGroupArgs {
      group_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      fcm_content: f_2.expect("auto-generated code should have checked for presence of required fields"),
      ios_content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      facebook_content: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendRawPushNotificationToGroup_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 1))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("fcmContent", TType::String, 2))?;
    o_prot.write_string(&self.fcm_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("iosContent", TType::String, 3))?;
    o_prot.write_string(&self.ios_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("facebookContent", TType::String, 4))?;
    o_prot.write_string(&self.facebook_content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendRawPushNotificationToGroupResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendRawPushNotificationToGroup"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs {
  /// The profileId of the user to receive the notification
  profile_id: String,
  /// Body and title of alert
  alert_content_json: String,
  /// Optional custom data
  custom_data_json: String,
  /// Start time of sending the push notification
  start_time: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs.alert_content_json", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs.custom_data_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs.start_time", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      alert_content_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      custom_data_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      start_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationUTC_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("alertContentJson", TType::String, 2))?;
    o_prot.write_string(&self.alert_content_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customDataJson", TType::String, 3))?;
    o_prot.write_string(&self.custom_data_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I32, 4))?;
    o_prot.write_i32(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTCResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationScheduleNormalizedPushNotificationUTC"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs {
  /// The profileId of the user to receive the notification
  profile_id: String,
  /// Body and title of alert
  alert_content_json: String,
  /// Optional custom data
  custom_data_json: String,
  /// Minutes from now to send the push notification
  minutes_from_now: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs.alert_content_json", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs.custom_data_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs.minutes_from_now", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      alert_content_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      custom_data_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      minutes_from_now: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_ScheduleNormalizedPushNotificationMinutes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("alertContentJson", TType::String, 2))?;
    o_prot.write_string(&self.alert_content_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customDataJson", TType::String, 3))?;
    o_prot.write_string(&self.custom_data_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minutesFromNow", TType::I32, 4))?;
    o_prot.write_i32(self.minutes_from_now)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationScheduleNormalizedPushNotificationMinutes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs {
  /// The profileId of the user to receive the notification
  profile_id: String,
  /// Body and title of alert
  notification_template_id: i32,
  /// Optional custom data
  substitutions_json: String,
  /// Start time of sending the push notification
  start_time: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs.notification_template_id", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs.substitutions_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs.start_time", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationScheduleRichPushNotificationUTCArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notification_template_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      substitutions_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      start_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_ScheduleRichPushNotificationUTC_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationTemplateId", TType::I32, 2))?;
    o_prot.write_i32(self.notification_template_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("substitutionsJson", TType::String, 3))?;
    o_prot.write_string(&self.substitutions_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startTime", TType::I32, 4))?;
    o_prot.write_i32(self.start_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationScheduleRichPushNotificationUTCResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationScheduleRichPushNotificationUTC"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs {
  /// The profileId of the user to receive the notification
  profile_id: String,
  /// Body and title of alert
  notification_template_id: i32,
  /// Optional custom data
  substitutions_json: String,
  /// Minutes from now to send the push notification
  minutes_from_now: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs.profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs.notification_template_id", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs.substitutions_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs.minutes_from_now", &f_4)?;
    verify_required_field_exists("BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs.client_index", &f_5)?;
    let ret = BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesArgs {
      profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      notification_template_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      substitutions_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      minutes_from_now: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_ScheduleRichPushNotificationMinutes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileId", TType::String, 1))?;
    o_prot.write_string(&self.profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("notificationTemplateId", TType::I32, 2))?;
    o_prot.write_i32(self.notification_template_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("substitutionsJson", TType::String, 3))?;
    o_prot.write_string(&self.substitutions_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minutesFromNow", TType::I32, 4))?;
    o_prot.write_i32(self.minutes_from_now)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationScheduleRichPushNotificationMinutesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationScheduleRichPushNotificationMinutes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs {
  /// The profileId of the user to receive the notification
  to_profile_id: String,
  /// Body and title of alert
  alert_content_json: String,
  /// Optional custom data
  custom_data_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs.to_profile_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs.alert_content_json", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs.custom_data_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs.client_index", &f_4)?;
    let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationArgs {
      to_profile_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      alert_content_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      custom_data_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendNormalizedPushNotification_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("toProfileId", TType::String, 1))?;
    o_prot.write_string(&self.to_profile_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("alertContentJson", TType::String, 2))?;
    o_prot.write_string(&self.alert_content_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customDataJson", TType::String, 3))?;
    o_prot.write_string(&self.custom_data_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendNormalizedPushNotificationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendNormalizedPushNotificationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendNormalizedPushNotificationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendNormalizedPushNotificationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendNormalizedPushNotificationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendNormalizedPushNotification"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs {
  /// Collection of profile IDs to send the notification to
  profile_ids: Vec<String>,
  /// Body and title of alert
  alert_content_json: String,
  /// Optional custom data
  custom_data_json: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_18 = i_prot.read_string()?;
            val.push(list_elem_18);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs.profile_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs.alert_content_json", &f_2)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs.custom_data_json", &f_3)?;
    verify_required_field_exists("BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs.client_index", &f_4)?;
    let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchArgs {
      profile_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      alert_content_json: f_2.expect("auto-generated code should have checked for presence of required fields"),
      custom_data_json: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("PushNotification_SendNormalizedPushNotificationBatch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.profile_ids.len() as i32))?;
    for e in &self.profile_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("alertContentJson", TType::String, 2))?;
    o_prot.write_string(&self.alert_content_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customDataJson", TType::String, 3))?;
    o_prot.write_string(&self.custom_data_json)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult {
  result_value: Option<String>,
}

impl BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePushNotificationSendNormalizedPushNotificationBatchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePushNotificationSendNormalizedPushNotificationBatch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptRunScriptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunScriptArgs {
  /// The name of the script to be run
  script_name: String,
  /// Data to be sent to the script in json format
  json_script_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptRunScriptArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunScriptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptRunScriptArgs.script_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptRunScriptArgs.json_script_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceScriptRunScriptArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceScriptRunScriptArgs {
      script_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_script_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_RunScript_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scriptName", TType::String, 1))?;
    o_prot.write_string(&self.script_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonScriptData", TType::String, 2))?;
    o_prot.write_string(&self.json_script_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptRunScriptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunScriptResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptRunScriptResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunScriptResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptRunScriptResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptRunScriptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptRunScript"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptScheduleRunScriptUTCArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptScheduleRunScriptUTCArgs {
  /// Name of script
  script_name: String,
  /// JSON bundle to pass to script
  json_script_data: String,
  /// The start date as a DateTime object
  start_date_in_u_t_c: brain_cloud_service_s_d_k_data_types::date,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptScheduleRunScriptUTCArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptScheduleRunScriptUTCArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<brain_cloud_service_s_d_k_data_types::date> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptUTCArgs.script_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptUTCArgs.json_script_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptUTCArgs.start_date_in_u_t_c", &f_3)?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptUTCArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceScriptScheduleRunScriptUTCArgs {
      script_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_script_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_date_in_u_t_c: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_ScheduleRunScriptUTC_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scriptName", TType::String, 1))?;
    o_prot.write_string(&self.script_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonScriptData", TType::String, 2))?;
    o_prot.write_string(&self.json_script_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startDateInUTC", TType::I64, 3))?;
    o_prot.write_i64(self.start_date_in_u_t_c)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptScheduleRunScriptUTCResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptScheduleRunScriptUTCResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptScheduleRunScriptUTCResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptScheduleRunScriptUTCResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptScheduleRunScriptUTCResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptScheduleRunScriptUTCResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptScheduleRunScriptUTC"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptScheduleRunScriptMinutesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptScheduleRunScriptMinutesArgs {
  /// Name of script
  script_name: String,
  /// JSON bundle to pass to script
  json_script_data: String,
  /// Number of minutes from now to run script
  minutes_from_now: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptScheduleRunScriptMinutesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptScheduleRunScriptMinutesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptMinutesArgs.script_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptMinutesArgs.json_script_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptMinutesArgs.minutes_from_now", &f_3)?;
    verify_required_field_exists("BrainCloudServiceScriptScheduleRunScriptMinutesArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceScriptScheduleRunScriptMinutesArgs {
      script_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_script_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      minutes_from_now: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_ScheduleRunScriptMinutes_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scriptName", TType::String, 1))?;
    o_prot.write_string(&self.script_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonScriptData", TType::String, 2))?;
    o_prot.write_string(&self.json_script_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("minutesFromNow", TType::I64, 3))?;
    o_prot.write_i64(self.minutes_from_now)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptScheduleRunScriptMinutesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptScheduleRunScriptMinutesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptScheduleRunScriptMinutesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptScheduleRunScriptMinutesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptScheduleRunScriptMinutesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptScheduleRunScriptMinutesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptScheduleRunScriptMinutes"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptRunParentScriptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunParentScriptArgs {
  /// Name of script
  script_name: String,
  /// JSON bundle to pass to script
  json_script_data: String,
  /// The level name of the parent to run the script from
  parent_level: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptRunParentScriptArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunParentScriptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptRunParentScriptArgs.script_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptRunParentScriptArgs.json_script_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceScriptRunParentScriptArgs.parent_level", &f_3)?;
    verify_required_field_exists("BrainCloudServiceScriptRunParentScriptArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceScriptRunParentScriptArgs {
      script_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_script_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      parent_level: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_RunParentScript_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scriptName", TType::String, 1))?;
    o_prot.write_string(&self.script_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonScriptData", TType::String, 2))?;
    o_prot.write_string(&self.json_script_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parentLevel", TType::String, 3))?;
    o_prot.write_string(&self.parent_level)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptRunParentScriptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunParentScriptResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptRunParentScriptResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunParentScriptResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptRunParentScriptResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptRunParentScriptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptRunParentScript"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptCancelScheduledScriptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptCancelScheduledScriptArgs {
  /// ID of script job to cancel
  job_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptCancelScheduledScriptArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptCancelScheduledScriptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptCancelScheduledScriptArgs.job_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptCancelScheduledScriptArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceScriptCancelScheduledScriptArgs {
      job_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_CancelScheduledScript_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jobId", TType::String, 1))?;
    o_prot.write_string(&self.job_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptCancelScheduledScriptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptCancelScheduledScriptResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptCancelScheduledScriptResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptCancelScheduledScriptResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptCancelScheduledScriptResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptCancelScheduledScriptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptCancelScheduledScript"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptRunPeerScriptArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunPeerScriptArgs {
  /// The name of the script to run
  script_name: String,
  /// JSON data to pass into the script
  json_script_data: String,
  /// Identifies the peer
  peer: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptRunPeerScriptArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunPeerScriptArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptArgs.script_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptArgs.json_script_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptArgs.peer", &f_3)?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceScriptRunPeerScriptArgs {
      script_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_script_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      peer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_RunPeerScript_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scriptName", TType::String, 1))?;
    o_prot.write_string(&self.script_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonScriptData", TType::String, 2))?;
    o_prot.write_string(&self.json_script_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peer", TType::String, 3))?;
    o_prot.write_string(&self.peer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptRunPeerScriptResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunPeerScriptResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptRunPeerScriptResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunPeerScriptResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptRunPeerScriptResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptRunPeerScriptResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptRunPeerScript"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceScriptRunPeerScriptAsynchArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunPeerScriptAsynchArgs {
  /// The name of the script to run
  script_name: String,
  /// JSON data to pass into the script
  json_script_data: String,
  /// Identifies the peer
  peer: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceScriptRunPeerScriptAsynchArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunPeerScriptAsynchArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptAsynchArgs.script_name", &f_1)?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptAsynchArgs.json_script_data", &f_2)?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptAsynchArgs.peer", &f_3)?;
    verify_required_field_exists("BrainCloudServiceScriptRunPeerScriptAsynchArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceScriptRunPeerScriptAsynchArgs {
      script_name: f_1.expect("auto-generated code should have checked for presence of required fields"),
      json_script_data: f_2.expect("auto-generated code should have checked for presence of required fields"),
      peer: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Script_RunPeerScriptAsynch_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("scriptName", TType::String, 1))?;
    o_prot.write_string(&self.script_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonScriptData", TType::String, 2))?;
    o_prot.write_string(&self.json_script_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("peer", TType::String, 3))?;
    o_prot.write_string(&self.peer)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceScriptRunPeerScriptAsynchResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceScriptRunPeerScriptAsynchResult {
  result_value: Option<String>,
}

impl BrainCloudServiceScriptRunPeerScriptAsynchResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceScriptRunPeerScriptAsynchResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceScriptRunPeerScriptAsynchResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceScriptRunPeerScriptAsynchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceScriptRunPeerScriptAsynch"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs {
  /// The id of the leaderboard to retrieve
  leaderboard_id: String,
  /// If true, the currently logged in player's name will be replaced
  /// by the string "You".
  replace_name: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs.replace_name", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialLeaderboardGetSocialLeaderboardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      replace_name: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetSocialLeaderboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replaceName", TType::Bool, 2))?;
    o_prot.write_bool(self.replace_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetSocialLeaderboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetSocialLeaderboard"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs {
  /// Array of leaderboard id strings
  leaderboard_ids: Vec<String>,
  /// Maximum count of entries to return for each leaderboard.
  leaderboard_result_count: i32,
  /// If true, the currently logged in player's name will be replaced
  /// by the string "You".
  replace_name: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_19 = i_prot.read_string()?;
            val.push(list_elem_19);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs.leaderboard_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs.leaderboard_result_count", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs.replace_name", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardArgs {
      leaderboard_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      leaderboard_result_count: f_2.expect("auto-generated code should have checked for presence of required fields"),
      replace_name: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetMultiSocialLeaderboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.leaderboard_ids.len() as i32))?;
    for e in &self.leaderboard_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardResultCount", TType::I32, 2))?;
    o_prot.write_i32(self.leaderboard_result_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replaceName", TType::Bool, 3))?;
    o_prot.write_bool(self.replace_name)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetMultiSocialLeaderboard"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs {
  /// The id of the leaderboard to retrieve.
  leaderboard_id: String,
  /// Sort key Sort order of page.
  sort: brain_cloud_service_s_d_k_data_types::SortOrder,
  /// The index at which to start the page.
  start_index: i32,
  /// The index at which to end the page.
  end_index: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<brain_cloud_service_s_d_k_data_types::SortOrder> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = brain_cloud_service_s_d_k_data_types::SortOrder::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs.sort", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs.start_index", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs.end_index", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sort: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
      end_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPage_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sort", TType::I32, 2))?;
    self.sort.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startIndex", TType::I32, 3))?;
    o_prot.write_i32(self.start_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endIndex", TType::I32, 4))?;
    o_prot.write_i32(self.end_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPage"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs {
  /// The id of the leaderboard to retrieve.
  leaderboard_id: String,
  /// Sort key Sort order of page.
  sort: brain_cloud_service_s_d_k_data_types::SortOrder,
  /// The index at which to start the page.
  start_index: i32,
  /// The index at which to end the page.
  end_index: i32,
  /// The historical version to retrieve.
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<brain_cloud_service_s_d_k_data_types::SortOrder> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = brain_cloud_service_s_d_k_data_types::SortOrder::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs.sort", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs.start_index", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs.end_index", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs.version_id", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sort: f_2.expect("auto-generated code should have checked for presence of required fields"),
      start_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
      end_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardPageByVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sort", TType::I32, 2))?;
    self.sort.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("startIndex", TType::I32, 3))?;
    o_prot.write_i32(self.start_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("endIndex", TType::I32, 4))?;
    o_prot.write_i32(self.end_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 5))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardPageByVersion"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs {
  /// The id of the leaderboard to retrieve.
  leaderboard_id: String,
  /// Sort key Sort order of page.
  sort: brain_cloud_service_s_d_k_data_types::SortOrder,
  /// The count of number of players before the current player to include.
  before_count: i32,
  /// The count of number of players after the current player to include.
  after_count: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<brain_cloud_service_s_d_k_data_types::SortOrder> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = brain_cloud_service_s_d_k_data_types::SortOrder::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs.sort", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs.before_count", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs.after_count", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sort: f_2.expect("auto-generated code should have checked for presence of required fields"),
      before_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      after_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardView_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sort", TType::I32, 2))?;
    self.sort.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("beforeCount", TType::I32, 3))?;
    o_prot.write_i32(self.before_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("afterCount", TType::I32, 4))?;
    o_prot.write_i32(self.after_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardView"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs {
  /// The id of the leaderboard to retrieve.
  leaderboard_id: String,
  /// Sort key Sort order of page.
  sort: brain_cloud_service_s_d_k_data_types::SortOrder,
  /// The count of number of players before the current player to include.
  before_count: i32,
  /// The count of number of players after the current player to include.
  after_count: i32,
  /// The historial version to retrieve. Use -1 for current leaderboard.
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<brain_cloud_service_s_d_k_data_types::SortOrder> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = brain_cloud_service_s_d_k_data_types::SortOrder::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs.sort", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs.before_count", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs.after_count", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs.version_id", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      sort: f_2.expect("auto-generated code should have checked for presence of required fields"),
      before_count: f_3.expect("auto-generated code should have checked for presence of required fields"),
      after_count: f_4.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardViewByVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sort", TType::I32, 2))?;
    self.sort.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("beforeCount", TType::I32, 3))?;
    o_prot.write_i32(self.before_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("afterCount", TType::I32, 4))?;
    o_prot.write_i32(self.after_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 5))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardViewByVersion"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs {
  /// In_leaderboard identifier.
  leaderboard_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardVersions_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersionsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardVersions"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs {
  /// The leaderboard to read
  leaderboard_id: String,
  /// The group ID
  group_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs.group_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      group_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGroupSocialLeaderboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("groupId", TType::String, 2))?;
    o_prot.write_string(&self.group_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGroupSocialLeaderboard"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs {
  /// The leaderboard to post to
  leaderboard_id: String,
  /// The score to post
  score: i64,
  json_data: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs.score", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      score: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_PostScoreToLeaderboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("score", TType::I64, 2))?;
    o_prot.write_i64(self.score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardPostScoreToLeaderboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardPostScoreToLeaderboard"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs {
  /// The ID of the leaderboard
  leaderboard_id: String,
  /// The version of the leaderboard
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs.version_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialLeaderboardRemovePlayerScoreArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_RemovePlayerScore_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 2))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardRemovePlayerScoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardRemovePlayerScore"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs {
  /// The leaderboard to post to
  leaderboard_id: String,
  /// The score to post
  score: i64,
  json_data: String,
  /// leaderboard type
  leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType,
  /// Type of rotation
  rotation_type: brain_cloud_service_s_d_k_data_types::RotationType,
  /// Date to reset the leaderboard UTC
  rotation_reset: brain_cloud_service_s_d_k_data_types::date,
  /// How many rotations to keep
  retained_count: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::SocialLeaderboardType> = None;
    let mut f_5: Option<brain_cloud_service_s_d_k_data_types::RotationType> = None;
    let mut f_6: Option<brain_cloud_service_s_d_k_data_types::date> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = brain_cloud_service_s_d_k_data_types::SocialLeaderboardType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = brain_cloud_service_s_d_k_data_types::RotationType::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i64()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.score", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.leaderboard_type", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.rotation_type", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.rotation_reset", &f_6)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.retained_count", &f_7)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs.client_index", &f_8)?;
    let ret = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      score: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      leaderboard_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      rotation_type: f_5.expect("auto-generated code should have checked for presence of required fields"),
      rotation_reset: f_6.expect("auto-generated code should have checked for presence of required fields"),
      retained_count: f_7.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("score", TType::I64, 2))?;
    o_prot.write_i64(self.score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardType", TType::I32, 4))?;
    self.leaderboard_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rotationType", TType::I32, 5))?;
    self.rotation_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rotationReset", TType::I64, 6))?;
    o_prot.write_i64(self.rotation_reset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("retainedCount", TType::I32, 7))?;
    o_prot.write_i32(self.retained_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 8))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboard"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs {
  /// The leaderboard to post to
  leaderboard_id: String,
  /// The score to post
  score: i64,
  json_data: String,
  /// leaderboard type
  leaderboard_type: brain_cloud_service_s_d_k_data_types::SocialLeaderboardType,
  /// Date to reset the leaderboard UTC
  rotation_reset: brain_cloud_service_s_d_k_data_types::date,
  /// How many rotations to keep
  retained_count: i32,
  /// How many days between each rotation
  num_days_to_rotate: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::SocialLeaderboardType> = None;
    let mut f_5: Option<brain_cloud_service_s_d_k_data_types::date> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = brain_cloud_service_s_d_k_data_types::SocialLeaderboardType::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i64()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i32()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.score", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.leaderboard_type", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.rotation_reset", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.retained_count", &f_6)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.num_days_to_rotate", &f_7)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs.client_index", &f_8)?;
    let ret = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      score: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      leaderboard_type: f_4.expect("auto-generated code should have checked for presence of required fields"),
      rotation_reset: f_5.expect("auto-generated code should have checked for presence of required fields"),
      retained_count: f_6.expect("auto-generated code should have checked for presence of required fields"),
      num_days_to_rotate: f_7.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_8.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_PostScoreToDynamicLeaderboardDays_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("score", TType::I64, 2))?;
    o_prot.write_i64(self.score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardType", TType::I32, 4))?;
    self.leaderboard_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("rotationReset", TType::I64, 5))?;
    o_prot.write_i64(self.rotation_reset)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("retainedCount", TType::I32, 6))?;
    o_prot.write_i32(self.retained_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("numDaysToRotate", TType::I32, 7))?;
    o_prot.write_i32(self.num_days_to_rotate)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 8))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDaysResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardPostScoreToDynamicLeaderboardDays"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs {
  /// The ID of the leaderboard
  leaderboard_id: String,
  /// The IDs of the players
  profile_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_20 = i_prot.read_string()?;
            val.push(list_elem_20);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs.profile_ids", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      profile_ids: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetPlayersSocialLeaderboard_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("profileIds", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.profile_ids.len() as i32))?;
    for e in &self.profile_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetPlayersSocialLeaderboard"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardListLeaderboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardListLeaderboardsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardListLeaderboardsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardListLeaderboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardListLeaderboardsArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceSocialLeaderboardListLeaderboardsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_ListLeaderboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardListLeaderboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardListLeaderboardsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardListLeaderboardsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardListLeaderboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardListLeaderboardsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardListLeaderboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardListLeaderboards"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs {
  /// The ID of the leaderboard
  leaderboard_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCount_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCount"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs {
  /// The ID of the leaderboard
  leaderboard_id: String,
  /// The version of the leaderboard
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs.version_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 2))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetGlobalLeaderboardEntryCountByVersion"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs {
  /// The ID of the leaderboard
  leaderboard_id: String,
  /// The version of the leaderboard. Use -1 for current.
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs.version_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialLeaderboardGetPlayerScoreArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetPlayerScore_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 2))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetPlayerScoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetPlayerScoreResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetPlayerScoreResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetPlayerScoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetPlayerScoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetPlayerScoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetPlayerScore"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs {
  /// A collection of leaderboardIds to retrieve scores from
  leaderboard_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_21 = i_prot.read_string()?;
            val.push(list_elem_21);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs.leaderboard_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsArgs {
      leaderboard_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialLeaderboard_GetPlayerScoresFromLeaderboards_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.leaderboard_ids.len() as i32))?;
    for e in &self.leaderboard_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboardsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialLeaderboardGetPlayerScoresFromLeaderboards"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTimeReadServerTimeArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTimeReadServerTimeArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTimeReadServerTimeArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTimeReadServerTimeArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTimeReadServerTimeArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceTimeReadServerTimeArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Time_ReadServerTime_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTimeReadServerTimeResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTimeReadServerTimeResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTimeReadServerTimeResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTimeReadServerTimeResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTimeReadServerTimeResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTimeReadServerTimeResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTimeReadServerTime"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentClaimTournamentRewardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentClaimTournamentRewardArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// Version of the tournament to claim rewards for.
  /// Use -1 for the latest version.
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentClaimTournamentRewardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentClaimTournamentRewardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentClaimTournamentRewardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentClaimTournamentRewardArgs.version_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTournamentClaimTournamentRewardArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceTournamentClaimTournamentRewardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_ClaimTournamentReward_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 2))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentClaimTournamentRewardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentClaimTournamentRewardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentClaimTournamentRewardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentClaimTournamentRewardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentClaimTournamentRewardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentClaimTournamentRewardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentClaimTournamentReward"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentGetTournamentStatusArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentGetTournamentStatusArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// Version of the tournament. Use -1 for the latest version.
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentGetTournamentStatusArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentGetTournamentStatusArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentGetTournamentStatusArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentGetTournamentStatusArgs.version_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTournamentGetTournamentStatusArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceTournamentGetTournamentStatusArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_GetTournamentStatus_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 2))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentGetTournamentStatusResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentGetTournamentStatusResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentGetTournamentStatusResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentGetTournamentStatusResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentGetTournamentStatusResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentGetTournamentStatusResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentGetTournamentStatus"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentJoinTournamentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentJoinTournamentArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// Tournament to join
  tournament_code: String,
  /// The initial score for players first joining a tournament
  /// Usually 0, unless leaderboard is LOW_VALUE
  initial_score: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentJoinTournamentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentJoinTournamentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i64> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentJoinTournamentArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentJoinTournamentArgs.tournament_code", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTournamentJoinTournamentArgs.initial_score", &f_3)?;
    verify_required_field_exists("BrainCloudServiceTournamentJoinTournamentArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceTournamentJoinTournamentArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tournament_code: f_2.expect("auto-generated code should have checked for presence of required fields"),
      initial_score: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_JoinTournament_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tournamentCode", TType::String, 2))?;
    o_prot.write_string(&self.tournament_code)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("initialScore", TType::I64, 3))?;
    o_prot.write_i64(self.initial_score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentJoinTournamentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentJoinTournamentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentJoinTournamentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentJoinTournamentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentJoinTournamentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentJoinTournamentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentJoinTournament"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentLeaveTournamentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentLeaveTournamentArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentLeaveTournamentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentLeaveTournamentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentLeaveTournamentArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentLeaveTournamentArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceTournamentLeaveTournamentArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_LeaveTournament_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentLeaveTournamentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentLeaveTournamentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentLeaveTournamentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentLeaveTournamentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentLeaveTournamentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentLeaveTournamentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentLeaveTournament"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentPostTournamentScoreArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentPostTournamentScoreArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// The score to post
  score: i64,
  /// Optional data attached to the leaderboard entry
  json_data: String,
  /// Time the user started the match resulting in the score
  /// being posted.
  round_started_time: brain_cloud_service_s_d_k_data_types::date,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentPostTournamentScoreArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentPostTournamentScoreArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::date> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreArgs.score", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreArgs.round_started_time", &f_4)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceTournamentPostTournamentScoreArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      score: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      round_started_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_PostTournamentScore_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("score", TType::I64, 2))?;
    o_prot.write_i64(self.score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roundStartedTime", TType::I64, 4))?;
    o_prot.write_i64(self.round_started_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentPostTournamentScoreResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentPostTournamentScoreResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentPostTournamentScoreResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentPostTournamentScoreResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentPostTournamentScoreResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentPostTournamentScoreResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentPostTournamentScore"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// The score to post
  score: i64,
  /// Optional data attached to the leaderboard entry
  json_data: String,
  /// Time the user started the match resulting in the score
  /// being posted.
  round_started_time: brain_cloud_service_s_d_k_data_types::date,
  /// Sort key Sort order of page.
  sort: brain_cloud_service_s_d_k_data_types::SortOrder,
  /// The count of number of players before the current player to include.
  before_count: i32,
  /// The count of number of players after the current player to include.
  after_count: i32,
  /// The initial score for players first joining a tournament
  /// Usually 0, unless leaderboard is LOW_VALUE
  initial_score: i64,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i64> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<brain_cloud_service_s_d_k_data_types::date> = None;
    let mut f_5: Option<brain_cloud_service_s_d_k_data_types::SortOrder> = None;
    let mut f_6: Option<i32> = None;
    let mut f_7: Option<i32> = None;
    let mut f_8: Option<i64> = None;
    let mut f_9: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i64()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i64()?;
          f_4 = Some(val);
        },
        5 => {
          let val = brain_cloud_service_s_d_k_data_types::SortOrder::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_i32()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_i64()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_i32()?;
          f_9 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.score", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.json_data", &f_3)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.round_started_time", &f_4)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.sort", &f_5)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.before_count", &f_6)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.after_count", &f_7)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.initial_score", &f_8)?;
    verify_required_field_exists("BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs.client_index", &f_9)?;
    let ret = BrainCloudServiceTournamentPostTournamentScoreWithResultsArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      score: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_data: f_3.expect("auto-generated code should have checked for presence of required fields"),
      round_started_time: f_4.expect("auto-generated code should have checked for presence of required fields"),
      sort: f_5.expect("auto-generated code should have checked for presence of required fields"),
      before_count: f_6.expect("auto-generated code should have checked for presence of required fields"),
      after_count: f_7.expect("auto-generated code should have checked for presence of required fields"),
      initial_score: f_8.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_9.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_PostTournamentScoreWithResults_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("score", TType::I64, 2))?;
    o_prot.write_i64(self.score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
    o_prot.write_string(&self.json_data)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("roundStartedTime", TType::I64, 4))?;
    o_prot.write_i64(self.round_started_time)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("sort", TType::I32, 5))?;
    self.sort.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("beforeCount", TType::I32, 6))?;
    o_prot.write_i32(self.before_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("afterCount", TType::I32, 7))?;
    o_prot.write_i32(self.after_count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("initialScore", TType::I64, 8))?;
    o_prot.write_i64(self.initial_score)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 9))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentPostTournamentScoreWithResultsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentPostTournamentScoreWithResultsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentPostTournamentScoreWithResultsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentPostTournamentScoreWithResultsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentPostTournamentScoreWithResultsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentPostTournamentScoreWithResultsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentPostTournamentScoreWithsResult"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentViewCurrentRewardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentViewCurrentRewardArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentViewCurrentRewardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentViewCurrentRewardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentViewCurrentRewardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentViewCurrentRewardArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceTournamentViewCurrentRewardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_ViewCurrentReward_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentViewCurrentRewardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentViewCurrentRewardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentViewCurrentRewardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentViewCurrentRewardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentViewCurrentRewardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentViewCurrentRewardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentViewCurrentReward"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTournamentViewRewardArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentViewRewardArgs {
  /// The leaderboard for the tournament
  leaderboard_id: String,
  /// Version of the tournament. Use -1 for the latest version.
  version_id: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTournamentViewRewardArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentViewRewardArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTournamentViewRewardArgs.leaderboard_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTournamentViewRewardArgs.version_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTournamentViewRewardArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceTournamentViewRewardArgs {
      leaderboard_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      version_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Tournament_ViewReward_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("leaderboardId", TType::String, 1))?;
    o_prot.write_string(&self.leaderboard_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("versionId", TType::I32, 2))?;
    o_prot.write_i32(self.version_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTournamentViewRewardResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTournamentViewRewardResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTournamentViewRewardResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTournamentViewRewardResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTournamentViewRewardResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTournamentViewRewardResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTournamentViewReward"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyCreateLobbyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyCreateLobbyArgs {
  /// The type of lobby to create, either "PLAYER" or "RANKED".
  lobby_type: brain_cloud_service_s_d_k_data_types::LobbyType,
  /// The maximum number of players that can join the lobby.
  max_slots: i32,
  /// Whether or not the lobby is open by default.
  is_open: bool,
  /// A json string containing any custom attributes to attach to the lobby.
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyCreateLobbyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyCreateLobbyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<brain_cloud_service_s_d_k_data_types::LobbyType> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = brain_cloud_service_s_d_k_data_types::LobbyType::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyCreateLobbyArgs.lobby_type", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyCreateLobbyArgs.max_slots", &f_2)?;
    verify_required_field_exists("BrainCloudServiceLobbyCreateLobbyArgs.is_open", &f_3)?;
    verify_required_field_exists("BrainCloudServiceLobbyCreateLobbyArgs.json_attributes", &f_4)?;
    verify_required_field_exists("BrainCloudServiceLobbyCreateLobbyArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceLobbyCreateLobbyArgs {
      lobby_type: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_slots: f_2.expect("auto-generated code should have checked for presence of required fields"),
      is_open: f_3.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_CreateLobby_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyType", TType::I32, 1))?;
    self.lobby_type.write_to_out_protocol(o_prot)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxSlots", TType::I32, 2))?;
    o_prot.write_i32(self.max_slots)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("isOpen", TType::Bool, 3))?;
    o_prot.write_bool(self.is_open)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 4))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyCreateLobbyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyCreateLobbyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyCreateLobbyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyCreateLobbyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyCreateLobbyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyCreateLobbyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyCreateLobby"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyOpenLobbyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyOpenLobbyArgs {
  /// The ID of the lobby to open.
  lobby_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyOpenLobbyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyOpenLobbyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyOpenLobbyArgs.lobby_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyOpenLobbyArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceLobbyOpenLobbyArgs {
      lobby_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_OpenLobby_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyId", TType::String, 1))?;
    o_prot.write_string(&self.lobby_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyOpenLobbyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyOpenLobbyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyOpenLobbyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyOpenLobbyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyOpenLobbyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyOpenLobbyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyOpenLobby"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyCloseLobbyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyCloseLobbyArgs {
  /// The ID of the lobby to close.
  lobby_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyCloseLobbyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyCloseLobbyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyCloseLobbyArgs.lobby_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyCloseLobbyArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceLobbyCloseLobbyArgs {
      lobby_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_CloseLobby_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyId", TType::String, 1))?;
    o_prot.write_string(&self.lobby_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyCloseLobbyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyCloseLobbyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyCloseLobbyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyCloseLobbyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyCloseLobbyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyCloseLobbyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyCloseLobby"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyFindLobbiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyFindLobbiesArgs {
  free_slots: i32,
  max_results: i32,
  /// A json string containing any custom attributes to search for.
  json_attributes: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyFindLobbiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyFindLobbiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyFindLobbiesArgs.free_slots", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyFindLobbiesArgs.max_results", &f_2)?;
    verify_required_field_exists("BrainCloudServiceLobbyFindLobbiesArgs.json_attributes", &f_3)?;
    verify_required_field_exists("BrainCloudServiceLobbyFindLobbiesArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceLobbyFindLobbiesArgs {
      free_slots: f_1.expect("auto-generated code should have checked for presence of required fields"),
      max_results: f_2.expect("auto-generated code should have checked for presence of required fields"),
      json_attributes: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_FindLobbies_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("freeSlots", TType::I32, 1))?;
    o_prot.write_i32(self.free_slots)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxResults", TType::I32, 2))?;
    o_prot.write_i32(self.max_results)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("jsonAttributes", TType::String, 3))?;
    o_prot.write_string(&self.json_attributes)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyFindLobbiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyFindLobbiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyFindLobbiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyFindLobbiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyFindLobbiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyFindLobbiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyFindLobbies"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyFindFriendsLobbiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyFindFriendsLobbiesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyFindFriendsLobbiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyFindFriendsLobbiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyFindFriendsLobbiesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceLobbyFindFriendsLobbiesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_FindFriendsLobbies_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyFindFriendsLobbiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyFindFriendsLobbiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyFindFriendsLobbiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyFindFriendsLobbiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyFindFriendsLobbiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyFindFriendsLobbiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyFindFriendsLobbies"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyJoinLobbyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyJoinLobbyArgs {
  /// The ID of the lobby to join.
  lobby_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyJoinLobbyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyJoinLobbyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyJoinLobbyArgs.lobby_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyJoinLobbyArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceLobbyJoinLobbyArgs {
      lobby_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_JoinLobby_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyId", TType::String, 1))?;
    o_prot.write_string(&self.lobby_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyJoinLobbyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyJoinLobbyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyJoinLobbyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyJoinLobbyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyJoinLobbyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyJoinLobbyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyJoinLobby"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyLeaveLobbyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyLeaveLobbyArgs {
  /// The ID of the lobby to leave.
  lobby_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyLeaveLobbyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyLeaveLobbyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyLeaveLobbyArgs.lobby_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyLeaveLobbyArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceLobbyLeaveLobbyArgs {
      lobby_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_LeaveLobby_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyId", TType::String, 1))?;
    o_prot.write_string(&self.lobby_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyLeaveLobbyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyLeaveLobbyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyLeaveLobbyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyLeaveLobbyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyLeaveLobbyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyLeaveLobbyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyLeaveLobby"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyDestroyLobbyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyDestroyLobbyArgs {
  /// The ID of the lobby to destroy.
  lobby_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyDestroyLobbyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyDestroyLobbyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyDestroyLobbyArgs.lobby_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyDestroyLobbyArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceLobbyDestroyLobbyArgs {
      lobby_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_DestroyLobby_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyId", TType::String, 1))?;
    o_prot.write_string(&self.lobby_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyDestroyLobbyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyDestroyLobbyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyDestroyLobbyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyDestroyLobbyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyDestroyLobbyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyDestroyLobbyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyDestroyLobby"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyStartGameArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyStartGameArgs {
  /// The ID of the lobby to destroy.
  lobby_id: String,
  /// A string that can be used to connect to a real game (e.g an IP Address/port).
  connection_string: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyStartGameArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyStartGameArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyStartGameArgs.lobby_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceLobbyStartGameArgs.connection_string", &f_2)?;
    verify_required_field_exists("BrainCloudServiceLobbyStartGameArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceLobbyStartGameArgs {
      lobby_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      connection_string: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_StartGame_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("lobbyId", TType::String, 1))?;
    o_prot.write_string(&self.lobby_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("connectionString", TType::String, 2))?;
    o_prot.write_string(&self.connection_string)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyStartGameResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyStartGameResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyStartGameResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyStartGameResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyStartGameResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyStartGameResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyStartGame"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceLobbyGetMyLobbiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyGetMyLobbiesArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceLobbyGetMyLobbiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyGetMyLobbiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceLobbyGetMyLobbiesArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceLobbyGetMyLobbiesArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Lobby_GetMyLobbies_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceLobbyGetMyLobbiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceLobbyGetMyLobbiesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceLobbyGetMyLobbiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceLobbyGetMyLobbiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceLobbyGetMyLobbiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceLobbyGetMyLobbiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceLobbyGetMyLobbies"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyAcceptPartyInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyAcceptPartyInvitationArgs {
  party_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyAcceptPartyInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyAcceptPartyInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyAcceptPartyInvitationArgs.party_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartyAcceptPartyInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartyAcceptPartyInvitationArgs {
      party_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_AcceptPartyInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partyId", TType::String, 1))?;
    o_prot.write_string(&self.party_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyAcceptPartyInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyAcceptPartyInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyAcceptPartyInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyAcceptPartyInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyAcceptPartyInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyAcceptPartyInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyAcceptPartyInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyGetPartyInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyGetPartyInfoArgs {
  party_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyGetPartyInfoArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyGetPartyInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyGetPartyInfoArgs.party_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartyGetPartyInfoArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartyGetPartyInfoArgs {
      party_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_GetPartyInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partyId", TType::String, 1))?;
    o_prot.write_string(&self.party_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyGetPartyInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyGetPartyInfoResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyGetPartyInfoResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyGetPartyInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyGetPartyInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyGetPartyInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyGetPartyInfo"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyJoinPartyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyJoinPartyArgs {
  party_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyJoinPartyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyJoinPartyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyJoinPartyArgs.party_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartyJoinPartyArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartyJoinPartyArgs {
      party_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_JoinParty_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partyId", TType::String, 1))?;
    o_prot.write_string(&self.party_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyJoinPartyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyJoinPartyResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyJoinPartyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyJoinPartyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyJoinPartyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyJoinPartyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyJoinParty"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyLeavePartyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyLeavePartyArgs {
  party_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyLeavePartyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyLeavePartyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyLeavePartyArgs.party_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartyLeavePartyArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartyLeavePartyArgs {
      party_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_LeaveParty_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partyId", TType::String, 1))?;
    o_prot.write_string(&self.party_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyLeavePartyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyLeavePartyResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyLeavePartyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyLeavePartyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyLeavePartyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyLeavePartyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyLeaveParty"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyRejectPartyInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyRejectPartyInvitationArgs {
  party_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyRejectPartyInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyRejectPartyInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyRejectPartyInvitationArgs.party_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartyRejectPartyInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartyRejectPartyInvitationArgs {
      party_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_RejectPartyInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("partyId", TType::String, 1))?;
    o_prot.write_string(&self.party_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyRejectPartyInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyRejectPartyInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyRejectPartyInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyRejectPartyInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyRejectPartyInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyRejectPartyInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyRejectPartyInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartySendPartyInvitationArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartySendPartyInvitationArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartySendPartyInvitationArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartySendPartyInvitationArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartySendPartyInvitationArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartySendPartyInvitationArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartySendPartyInvitationArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_SendPartyInvitation_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartySendPartyInvitationResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartySendPartyInvitationResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartySendPartyInvitationResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartySendPartyInvitationResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartySendPartyInvitationResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartySendPartyInvitationResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartySendPartyInvitation"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyListPartyInvitationsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyListPartyInvitationsArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyListPartyInvitationsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyListPartyInvitationsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyListPartyInvitationsArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePartyListPartyInvitationsArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_ListPartyInvitations_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyListPartyInvitationsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyListPartyInvitationsResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyListPartyInvitationsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyListPartyInvitationsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyListPartyInvitationsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyListPartyInvitationsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyListPartyInvitations"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyGetFriendsPartiesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyGetFriendsPartiesArgs {
  max_results: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyGetFriendsPartiesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyGetFriendsPartiesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyGetFriendsPartiesArgs.max_results", &f_1)?;
    verify_required_field_exists("BrainCloudServicePartyGetFriendsPartiesArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePartyGetFriendsPartiesArgs {
      max_results: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_GetFriendsParties_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("maxResults", TType::I32, 1))?;
    o_prot.write_i32(self.max_results)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyGetFriendsPartiesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyGetFriendsPartiesResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyGetFriendsPartiesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyGetFriendsPartiesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyGetFriendsPartiesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyGetFriendsPartiesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyGetFriendsParties"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePartyGetMyPartyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyGetMyPartyArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePartyGetMyPartyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyGetMyPartyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePartyGetMyPartyArgs.client_index", &f_1)?;
    let ret = BrainCloudServicePartyGetMyPartyArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Party_GetMyParty_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePartyGetMyPartyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePartyGetMyPartyResult {
  result_value: Option<String>,
}

impl BrainCloudServicePartyGetMyPartyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePartyGetMyPartyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePartyGetMyPartyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePartyGetMyPartyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePartyGetMyParty"
          )
        )
      )
    }
  }
}

//
// BrainCloudServicePatchGetGameManifestArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePatchGetGameManifestArgs {
  game_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServicePatchGetGameManifestArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePatchGetGameManifestArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServicePatchGetGameManifestArgs.game_id", &f_1)?;
    verify_required_field_exists("BrainCloudServicePatchGetGameManifestArgs.client_index", &f_2)?;
    let ret = BrainCloudServicePatchGetGameManifestArgs {
      game_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Patch_GetGameManifest_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("gameId", TType::String, 1))?;
    o_prot.write_string(&self.game_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServicePatchGetGameManifestResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServicePatchGetGameManifestResult {
  result_value: Option<String>,
}

impl BrainCloudServicePatchGetGameManifestResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServicePatchGetGameManifestResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServicePatchGetGameManifestResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServicePatchGetGameManifestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServicePatchGetGameManifest"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingAddToCartSISFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingAddToCartSISFOArgs {
  /// The ID of the product to add to the cart (usually a Game ID).
  product_id: String,
  /// The amount of this product to add.
  quantity: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingAddToCartSISFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingAddToCartSISFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToCartSISFOArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToCartSISFOArgs.quantity", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToCartSISFOArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingAddToCartSISFOArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      quantity: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_AddToCart_SISFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("quantity", TType::I32, 2))?;
    o_prot.write_i32(self.quantity)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingAddToCartSISFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingAddToCartSISFOResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingAddToCartSISFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingAddToCartSISFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingAddToCartSISFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingAddToCartSISFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingAddToCartSISFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingAddToCartISFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingAddToCartISFOArgs {
  product_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingAddToCartISFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingAddToCartISFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_22 = i_prot.read_string()?;
            val.push(list_elem_22);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToCartISFOArgs.product_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToCartISFOArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingAddToCartISFOArgs {
      product_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_AddToCart_ISFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.product_ids.len() as i32))?;
    for e in &self.product_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingAddToCartISFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingAddToCartISFOResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingAddToCartISFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingAddToCartISFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingAddToCartISFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingAddToCartISFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingAddToCartISFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingEmptyCartArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingEmptyCartArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingEmptyCartArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingEmptyCartArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingEmptyCartArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceShoppingEmptyCartArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_EmptyCart_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingEmptyCartResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingEmptyCartResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingEmptyCartResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingEmptyCartResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingEmptyCartResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingEmptyCartResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingEmptyCart"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetCartArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetCartArgs {
  include_details: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetCartArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetCartArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetCartArgs.include_details", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetCartArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetCartArgs {
      include_details: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetCart_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeDetails", TType::Bool, 1))?;
    o_prot.write_bool(self.include_details)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetCartResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetCartResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetCartResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetCartResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetCartResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetCartResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetCart"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingRemoveFromCartArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveFromCartArgs {
  /// The ID of the product to remove.
  product_id: String,
  quantity: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingRemoveFromCartArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveFromCartArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromCartArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromCartArgs.quantity", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromCartArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingRemoveFromCartArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      quantity: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_RemoveFromCart_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("quantity", TType::I32, 2))?;
    o_prot.write_i32(self.quantity)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingRemoveFromCartResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveFromCartResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingRemoveFromCartResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveFromCartResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingRemoveFromCartResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingRemoveFromCartResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingRemoveFromCart"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingAddToWishlistArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingAddToWishlistArgs {
  /// The ID of the product to add.
  product_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingAddToWishlistArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingAddToWishlistArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToWishlistArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingAddToWishlistArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingAddToWishlistArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_AddToWishlist_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingAddToWishlistResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingAddToWishlistResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingAddToWishlistResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingAddToWishlistResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingAddToWishlistResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingAddToWishlistResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingAddToWishlist"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingEmptyWishlistArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingEmptyWishlistArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingEmptyWishlistArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingEmptyWishlistArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingEmptyWishlistArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceShoppingEmptyWishlistArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_EmptyWishlist_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingEmptyWishlistResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingEmptyWishlistResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingEmptyWishlistResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingEmptyWishlistResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingEmptyWishlistResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingEmptyWishlistResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingEmptyWishlist"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetMyWishlistArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyWishlistArgs {
  include_details: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetMyWishlistArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyWishlistArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyWishlistArgs.include_details", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyWishlistArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetMyWishlistArgs {
      include_details: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetMyWishlist_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeDetails", TType::Bool, 1))?;
    o_prot.write_bool(self.include_details)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetMyWishlistResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyWishlistResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetMyWishlistResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyWishlistResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetMyWishlistResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetMyWishlistResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetMyWishlist"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetWishlistArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetWishlistArgs {
  /// The ID of the player to get the wishlist for.
  player_id: String,
  include_details: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetWishlistArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetWishlistArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<bool> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetWishlistArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetWishlistArgs.include_details", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetWishlistArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingGetWishlistArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      include_details: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetWishlist_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeDetails", TType::Bool, 2))?;
    o_prot.write_bool(self.include_details)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetWishlistResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetWishlistResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetWishlistResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetWishlistResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetWishlistResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetWishlistResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetWishlist"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs {
  /// The ID of the product to remove.
  product_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingRemoveFromWishlistSSFOArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_RemoveFromWishlist_SSFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingRemoveFromWishlistSSFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveFromWishlistSSFOResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingRemoveFromWishlistSSFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveFromWishlistSSFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingRemoveFromWishlistSSFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingRemoveFromWishlistSSFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingRemoveFromWishlistSSFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingRemoveFromWishlistISFOArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveFromWishlistISFOArgs {
  product_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingRemoveFromWishlistISFOArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveFromWishlistISFOArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_23 = i_prot.read_string()?;
            val.push(list_elem_23);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromWishlistISFOArgs.product_ids", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveFromWishlistISFOArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingRemoveFromWishlistISFOArgs {
      product_ids: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_RemoveFromWishlist_ISFO_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productIds", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.product_ids.len() as i32))?;
    for e in &self.product_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingRemoveFromWishlistISFOResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveFromWishlistISFOResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingRemoveFromWishlistISFOResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveFromWishlistISFOResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingRemoveFromWishlistISFOResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingRemoveFromWishlistISFOResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingRemoveFromWishlistISFO"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetUserReviewsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetUserReviewsArgs {
  /// The ID of the product to get reviews for.
  product_id: String,
  /// The 1-indexed page of the review list to fetch.
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetUserReviewsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetUserReviewsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserReviewsArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserReviewsArgs.page", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserReviewsArgs.page_size", &f_3)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserReviewsArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceShoppingGetUserReviewsArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page: f_2.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetUserReviews_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 2))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 3))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetUserReviewsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetUserReviewsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetUserReviewsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetUserReviewsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetUserReviewsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetUserReviewsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetUserReviews"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingSubmitUserReviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingSubmitUserReviewArgs {
  /// The ID of the product being reviewed.
  product_id: String,
  /// The text of the review.
  review_text: String,
  positive: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingSubmitUserReviewArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingSubmitUserReviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserReviewArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserReviewArgs.review_text", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserReviewArgs.positive", &f_3)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserReviewArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceShoppingSubmitUserReviewArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      review_text: f_2.expect("auto-generated code should have checked for presence of required fields"),
      positive: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_SubmitUserReview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reviewText", TType::String, 2))?;
    o_prot.write_string(&self.review_text)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("positive", TType::Bool, 3))?;
    o_prot.write_bool(self.positive)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingSubmitUserReviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingSubmitUserReviewResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingSubmitUserReviewResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingSubmitUserReviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingSubmitUserReviewResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingSubmitUserReviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingSubmitUserReview"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingLikeUserReviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingLikeUserReviewArgs {
  /// The ID of the product being reviewed.
  product_id: String,
  /// @2487545452
  review_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingLikeUserReviewArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingLikeUserReviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingLikeUserReviewArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingLikeUserReviewArgs.review_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingLikeUserReviewArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingLikeUserReviewArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      review_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_LikeUserReview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reviewId", TType::String, 2))?;
    o_prot.write_string(&self.review_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingLikeUserReviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingLikeUserReviewResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingLikeUserReviewResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingLikeUserReviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingLikeUserReviewResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingLikeUserReviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingLikeUserReview"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingUnlikeUserReviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingUnlikeUserReviewArgs {
  /// The ID of the product being reviewed.
  product_id: String,
  /// @2487545452
  review_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingUnlikeUserReviewArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingUnlikeUserReviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingUnlikeUserReviewArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingUnlikeUserReviewArgs.review_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingUnlikeUserReviewArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingUnlikeUserReviewArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      review_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_UnlikeUserReview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reviewId", TType::String, 2))?;
    o_prot.write_string(&self.review_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingUnlikeUserReviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingUnlikeUserReviewResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingUnlikeUserReviewResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingUnlikeUserReviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingUnlikeUserReviewResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingUnlikeUserReviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingUnlikeUserReview"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingFunnyUserReviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingFunnyUserReviewArgs {
  /// The ID of the product being reviewed.
  product_id: String,
  /// @2487545452
  review_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingFunnyUserReviewArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingFunnyUserReviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingFunnyUserReviewArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingFunnyUserReviewArgs.review_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingFunnyUserReviewArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingFunnyUserReviewArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      review_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_FunnyUserReview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reviewId", TType::String, 2))?;
    o_prot.write_string(&self.review_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingFunnyUserReviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingFunnyUserReviewResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingFunnyUserReviewResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingFunnyUserReviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingFunnyUserReviewResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingFunnyUserReviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingFunnyUserReview"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingUnfunnyUserReviewArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingUnfunnyUserReviewArgs {
  /// The ID of the product being reviewed.
  product_id: String,
  /// @2487545452
  review_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingUnfunnyUserReviewArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingUnfunnyUserReviewArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingUnfunnyUserReviewArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingUnfunnyUserReviewArgs.review_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingUnfunnyUserReviewArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingUnfunnyUserReviewArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      review_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_UnfunnyUserReview_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("reviewId", TType::String, 2))?;
    o_prot.write_string(&self.review_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingUnfunnyUserReviewResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingUnfunnyUserReviewResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingUnfunnyUserReviewResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingUnfunnyUserReviewResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingUnfunnyUserReviewResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingUnfunnyUserReviewResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingUnfunnyUserReview"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs {
  /// The 1-indexed page of the review list to fetch.
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs.page", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs.page_size", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingGetRecentlyCreatedProductsArgs {
      page: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetRecentlyCreatedProducts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 1))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 2))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetRecentlyCreatedProductsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetRecentlyCreatedProductsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetRecentlyCreatedProductsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetRecentlyCreatedProductsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetRecentlyCreatedProductsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetRecentlyCreatedProductsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetRecentlyCreatedProducts"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs {
  /// The 1-indexed page of the review list to fetch.
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs.page", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs.page_size", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingGetRecentlyUpdatedProductsArgs {
      page: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetRecentlyUpdatedProducts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 1))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 2))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetRecentlyUpdatedProductsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetRecentlyUpdatedProducts"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetFeaturedProductsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetFeaturedProductsArgs {
  /// If true will also return full descriptions of games in the list.
  include_details: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetFeaturedProductsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetFeaturedProductsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetFeaturedProductsArgs.include_details", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetFeaturedProductsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetFeaturedProductsArgs {
      include_details: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetFeaturedProducts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeDetails", TType::Bool, 1))?;
    o_prot.write_bool(self.include_details)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetFeaturedProductsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetFeaturedProductsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetFeaturedProductsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetFeaturedProductsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetFeaturedProductsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetFeaturedProductsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetFeaturedProducts"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetPopularProductsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetPopularProductsArgs {
  /// The 1-indexed page of the review list to fetch.
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetPopularProductsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetPopularProductsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetPopularProductsArgs.page", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetPopularProductsArgs.page_size", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetPopularProductsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingGetPopularProductsArgs {
      page: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetPopularProducts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 1))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 2))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetPopularProductsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetPopularProductsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetPopularProductsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetPopularProductsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetPopularProductsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetPopularProductsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetPopularProducts"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetSpecialOffersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetSpecialOffersArgs {
  /// The 1-indexed page of the review list to fetch.
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetSpecialOffersArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetSpecialOffersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetSpecialOffersArgs.page", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetSpecialOffersArgs.page_size", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetSpecialOffersArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingGetSpecialOffersArgs {
      page: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetSpecialOffers_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 1))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 2))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetSpecialOffersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetSpecialOffersResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetSpecialOffersResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetSpecialOffersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetSpecialOffersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetSpecialOffersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetSpecialOffers"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetMyLibraryArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyLibraryArgs {
  include_details: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetMyLibraryArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyLibraryArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyLibraryArgs.include_details", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyLibraryArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetMyLibraryArgs {
      include_details: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetMyLibrary_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeDetails", TType::Bool, 1))?;
    o_prot.write_bool(self.include_details)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetMyLibraryResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyLibraryResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetMyLibraryResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyLibraryResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetMyLibraryResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetMyLibraryResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetMyLibrary"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetPopularTagsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetPopularTagsArgs {
  /// @1144882702
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetPopularTagsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetPopularTagsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetPopularTagsArgs.page", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetPopularTagsArgs.page_size", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetPopularTagsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingGetPopularTagsArgs {
      page: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetPopularTags_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 1))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 2))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetPopularTagsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetPopularTagsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetPopularTagsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetPopularTagsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetPopularTagsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetPopularTagsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetPopularTags"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetProductsByTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetProductsByTagArgs {
  tag: String,
  /// @1144882702
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetProductsByTagArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetProductsByTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagArgs.tag", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagArgs.page", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagArgs.page_size", &f_3)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceShoppingGetProductsByTagArgs {
      tag: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page: f_2.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetProductsByTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tag", TType::String, 1))?;
    o_prot.write_string(&self.tag)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 2))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 3))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetProductsByTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetProductsByTagResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetProductsByTagResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetProductsByTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetProductsByTagResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetProductsByTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetProductsByTag"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetProductsByTagsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetProductsByTagsArgs {
  tags: Vec<String>,
  /// @1144882702
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetProductsByTagsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetProductsByTagsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<String>> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_24 = i_prot.read_string()?;
            val.push(list_elem_24);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagsArgs.tags", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagsArgs.page", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagsArgs.page_size", &f_3)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductsByTagsArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceShoppingGetProductsByTagsArgs {
      tags: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page: f_2.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetProductsByTags_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::List, 1))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tags.len() as i32))?;
    for e in &self.tags {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 2))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 3))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetProductsByTagsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetProductsByTagsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetProductsByTagsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetProductsByTagsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetProductsByTagsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetProductsByTagsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetProductsByTags"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetRecommendedProductsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetRecommendedProductsArgs {
  count: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetRecommendedProductsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetRecommendedProductsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecommendedProductsArgs.count", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetRecommendedProductsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetRecommendedProductsArgs {
      count: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetRecommendedProducts_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("count", TType::I32, 1))?;
    o_prot.write_i32(self.count)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetRecommendedProductsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetRecommendedProductsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetRecommendedProductsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetRecommendedProductsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetRecommendedProductsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetRecommendedProductsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetRecommendedProducts"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetMyOrdersArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyOrdersArgs {
  /// @1616325051
  include_completed: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetMyOrdersArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyOrdersArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyOrdersArgs.include_completed", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyOrdersArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetMyOrdersArgs {
      include_completed: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetMyOrders_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("includeCompleted", TType::Bool, 1))?;
    o_prot.write_bool(self.include_completed)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetMyOrdersResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyOrdersResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetMyOrdersResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyOrdersResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetMyOrdersResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetMyOrdersResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetMyOrders"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetProductArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetProductArgs {
  product_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetProductArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetProductArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetProductArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetProductArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetProduct_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetProductResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetProductResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetProductResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetProductResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetProductResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetProductResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetProduct"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetUserTagsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetUserTagsArgs {
  /// @3110420339
  product_id: String,
  /// @1144882702
  page: i32,
  /// The size of each page.
  page_size: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetUserTagsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetUserTagsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserTagsArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserTagsArgs.page", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserTagsArgs.page_size", &f_3)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetUserTagsArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceShoppingGetUserTagsArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      page: f_2.expect("auto-generated code should have checked for presence of required fields"),
      page_size: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetUserTags_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("page", TType::I32, 2))?;
    o_prot.write_i32(self.page)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("pageSize", TType::I32, 3))?;
    o_prot.write_i32(self.page_size)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetUserTagsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetUserTagsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetUserTagsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetUserTagsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetUserTagsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetUserTagsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetUserTags"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetMyUserTagsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyUserTagsArgs {
  /// @3110420339
  product_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetMyUserTagsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyUserTagsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyUserTagsArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetMyUserTagsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetMyUserTagsArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetMyUserTags_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetMyUserTagsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetMyUserTagsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetMyUserTagsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetMyUserTagsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetMyUserTagsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetMyUserTagsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetMyUserTags"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingSubmitUserTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingSubmitUserTagArgs {
  /// @3110420339
  product_id: String,
  /// @605655784
  tag: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingSubmitUserTagArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingSubmitUserTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserTagArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserTagArgs.tag", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserTagArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingSubmitUserTagArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tag: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_SubmitUserTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tag", TType::String, 2))?;
    o_prot.write_string(&self.tag)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingSubmitUserTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingSubmitUserTagResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingSubmitUserTagResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingSubmitUserTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingSubmitUserTagResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingSubmitUserTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingSubmitUserTag"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingSubmitUserTagsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingSubmitUserTagsArgs {
  /// @3110420339
  product_id: String,
  tags: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingSubmitUserTagsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingSubmitUserTagsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<Vec<String>> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_25 = i_prot.read_string()?;
            val.push(list_elem_25);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserTagsArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserTagsArgs.tags", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingSubmitUserTagsArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingSubmitUserTagsArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tags: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_SubmitUserTags_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tags", TType::List, 2))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tags.len() as i32))?;
    for e in &self.tags {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingSubmitUserTagsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingSubmitUserTagsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingSubmitUserTagsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingSubmitUserTagsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingSubmitUserTagsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingSubmitUserTagsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingSubmitUserTags"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingRemoveUserTagArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveUserTagArgs {
  /// @3110420339
  product_id: String,
  /// @3017888560
  tag: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingRemoveUserTagArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveUserTagArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveUserTagArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveUserTagArgs.tag", &f_2)?;
    verify_required_field_exists("BrainCloudServiceShoppingRemoveUserTagArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceShoppingRemoveUserTagArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      tag: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_RemoveUserTag_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tag", TType::String, 2))?;
    o_prot.write_string(&self.tag)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingRemoveUserTagResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingRemoveUserTagResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingRemoveUserTagResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingRemoveUserTagResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingRemoveUserTagResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingRemoveUserTagResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingRemoveUserTag"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceShoppingGetBuildDetailsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetBuildDetailsArgs {
  /// @3110420339
  product_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceShoppingGetBuildDetailsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetBuildDetailsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceShoppingGetBuildDetailsArgs.product_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceShoppingGetBuildDetailsArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceShoppingGetBuildDetailsArgs {
      product_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Shopping_GetBuildDetails_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("productId", TType::String, 1))?;
    o_prot.write_string(&self.product_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceShoppingGetBuildDetailsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceShoppingGetBuildDetailsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceShoppingGetBuildDetailsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceShoppingGetBuildDetailsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceShoppingGetBuildDetailsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceShoppingGetBuildDetailsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceShoppingGetBuildDetails"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareVideoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareVideoArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareVideoArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareVideoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_26 = i_prot.read_string()?;
            val.push(list_elem_26);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_27 = i_prot.read_string()?;
            val.push(list_elem_27);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_28 = i_prot.read_string()?;
            val.push(list_elem_28);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareVideoArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareVideoArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareVideoArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareVideoArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareVideoArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareVideoArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareVideoArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareVideo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareVideoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareVideoResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareVideoResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareVideoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareVideoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareVideoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareVideo"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareScreenshotArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareScreenshotArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareScreenshotArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareScreenshotArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_29 = i_prot.read_string()?;
            val.push(list_elem_29);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_30 = i_prot.read_string()?;
            val.push(list_elem_30);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_31 = i_prot.read_string()?;
            val.push(list_elem_31);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareScreenshotArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareScreenshotArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareScreenshotArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareScreenshotArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareScreenshotArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareScreenshotArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareScreenshotArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareScreenshot_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareScreenshotResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareScreenshotResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareScreenshotResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareScreenshotResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareScreenshotResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareScreenshotResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareScreenshot"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareAchievementArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareAchievementArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareAchievementArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareAchievementArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_32 = i_prot.read_string()?;
            val.push(list_elem_32);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_33 = i_prot.read_string()?;
            val.push(list_elem_33);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_34 = i_prot.read_string()?;
            val.push(list_elem_34);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAchievementArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAchievementArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAchievementArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAchievementArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAchievementArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAchievementArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareAchievementArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareAchievement_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareAchievementResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareAchievementResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareAchievementResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareAchievementResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareAchievementResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareAchievementResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareAchievement"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareAppArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareAppArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareAppArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareAppArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_35 = i_prot.read_string()?;
            val.push(list_elem_35);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_36 = i_prot.read_string()?;
            val.push(list_elem_36);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_37 = i_prot.read_string()?;
            val.push(list_elem_37);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAppArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAppArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAppArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAppArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAppArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareAppArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareAppArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareApp_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareAppResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareAppResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareAppResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareAppResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareAppResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareAppResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareApp"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareChannelArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareChannelArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareChannelArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareChannelArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_38 = i_prot.read_string()?;
            val.push(list_elem_38);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_39 = i_prot.read_string()?;
            val.push(list_elem_39);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_40 = i_prot.read_string()?;
            val.push(list_elem_40);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareChannelArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareChannelArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareChannelArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareChannelArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareChannelArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareChannelArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareChannelArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareChannel_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareChannelResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareChannelResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareChannelResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareChannelResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareChannelResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareChannelResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareChannel"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareLinkArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareLinkArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareLinkArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareLinkArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_41 = i_prot.read_string()?;
            val.push(list_elem_41);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_42 = i_prot.read_string()?;
            val.push(list_elem_42);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_43 = i_prot.read_string()?;
            val.push(list_elem_43);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareLinkArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareLinkArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareLinkArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareLinkArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareLinkArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareLinkArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareLinkArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareLink_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareLinkResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareLinkResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareLinkResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareLinkResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareLinkResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareLinkResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareLink"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedShareGameGuideArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareGameGuideArgs {
  timestamp: i32,
  resource: String,
  tagged: Vec<String>,
  show: Vec<String>,
  block: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedShareGameGuideArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareGameGuideArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<Vec<String>> = None;
    let mut f_5: Option<Vec<String>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_44 = i_prot.read_string()?;
            val.push(list_elem_44);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_45 = i_prot.read_string()?;
            val.push(list_elem_45);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        5 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_46 = i_prot.read_string()?;
            val.push(list_elem_46);
          }
          i_prot.read_list_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareGameGuideArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareGameGuideArgs.resource", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareGameGuideArgs.tagged", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareGameGuideArgs.show", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareGameGuideArgs.block", &f_5)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedShareGameGuideArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceSocialFeedShareGameGuideArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      resource: f_2.expect("auto-generated code should have checked for presence of required fields"),
      tagged: f_3.expect("auto-generated code should have checked for presence of required fields"),
      show: f_4.expect("auto-generated code should have checked for presence of required fields"),
      block: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ShareGameGuide_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("resource", TType::String, 2))?;
    o_prot.write_string(&self.resource)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("tagged", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.tagged.len() as i32))?;
    for e in &self.tagged {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("show", TType::List, 4))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.show.len() as i32))?;
    for e in &self.show {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("block", TType::List, 5))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.block.len() as i32))?;
    for e in &self.block {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedShareGameGuideResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedShareGameGuideResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedShareGameGuideResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedShareGameGuideResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedShareGameGuideResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedShareGameGuideResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedShareGameGuide"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedReadSocialFeedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadSocialFeedArgs {
  skip: i32,
  limit: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedReadSocialFeedArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadSocialFeedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadSocialFeedArgs.skip", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadSocialFeedArgs.limit", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadSocialFeedArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialFeedReadSocialFeedArgs {
      skip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ReadSocialFeed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 1))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 2))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedReadSocialFeedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadSocialFeedResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedReadSocialFeedResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadSocialFeedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedReadSocialFeedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedReadSocialFeedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedReadSocialFeed"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs {
  skip: i32,
  limit: i32,
  player_ids: Vec<String>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<Vec<String>> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<String> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_47 = i_prot.read_string()?;
            val.push(list_elem_47);
          }
          i_prot.read_list_end()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs.skip", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs.limit", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs.player_ids", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialFeedReadFilteredSocialFeedArgs {
      skip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
      player_ids: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ReadFilteredSocialFeed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 1))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 2))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerIds", TType::List, 3))?;
    o_prot.write_list_begin(&TListIdentifier::new(TType::String, self.player_ids.len() as i32))?;
    for e in &self.player_ids {
      o_prot.write_string(e)?;
      o_prot.write_list_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedReadFilteredSocialFeedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadFilteredSocialFeedResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedReadFilteredSocialFeedResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadFilteredSocialFeedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedReadFilteredSocialFeedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedReadFilteredSocialFeedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedReadFilteredSocialFeed"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs {
  skip: i32,
  limit: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs.skip", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs.limit", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceSocialFeedReadFriendsSocialFeedArgs {
      skip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ReadFriendsSocialFeed_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 1))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 2))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedReadFriendsSocialFeedResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadFriendsSocialFeedResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedReadFriendsSocialFeedResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadFriendsSocialFeedResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedReadFriendsSocialFeedResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedReadFriendsSocialFeedResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedReadFriendsSocialFeed"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedPostCommentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedPostCommentArgs {
  timestamp: i32,
  parent_id: String,
  content: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedPostCommentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedPostCommentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentArgs.parent_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentArgs.content", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialFeedPostCommentArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parent_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_PostComment_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parentId", TType::String, 2))?;
    o_prot.write_string(&self.parent_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_string(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedPostCommentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedPostCommentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedPostCommentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedPostCommentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedPostCommentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedPostCommentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedPostComment"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedPostCommentReplyArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedPostCommentReplyArgs {
  timestamp: i32,
  parent_id: String,
  content: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedPostCommentReplyArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedPostCommentReplyArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentReplyArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentReplyArgs.parent_id", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentReplyArgs.content", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedPostCommentReplyArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialFeedPostCommentReplyArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      parent_id: f_2.expect("auto-generated code should have checked for presence of required fields"),
      content: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_PostCommentReply_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parentId", TType::String, 2))?;
    o_prot.write_string(&self.parent_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("content", TType::String, 3))?;
    o_prot.write_string(&self.content)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedPostCommentReplyResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedPostCommentReplyResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedPostCommentReplyResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedPostCommentReplyResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedPostCommentReplyResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedPostCommentReplyResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedPostCommentReply"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedReadCommentsArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadCommentsArgs {
  skip: i32,
  limit: i32,
  parent_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedReadCommentsArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadCommentsArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentsArgs.skip", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentsArgs.limit", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentsArgs.parent_id", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentsArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialFeedReadCommentsArgs {
      skip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
      parent_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ReadComments_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 1))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 2))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parentId", TType::String, 3))?;
    o_prot.write_string(&self.parent_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedReadCommentsResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadCommentsResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedReadCommentsResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadCommentsResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedReadCommentsResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedReadCommentsResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedReadComments"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedReadCommentRepliesArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadCommentRepliesArgs {
  skip: i32,
  limit: i32,
  parent_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedReadCommentRepliesArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadCommentRepliesArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentRepliesArgs.skip", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentRepliesArgs.limit", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentRepliesArgs.parent_id", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedReadCommentRepliesArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceSocialFeedReadCommentRepliesArgs {
      skip: f_1.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_2.expect("auto-generated code should have checked for presence of required fields"),
      parent_id: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_ReadCommentReplies_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 1))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 2))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("parentId", TType::String, 3))?;
    o_prot.write_string(&self.parent_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedReadCommentRepliesResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedReadCommentRepliesResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedReadCommentRepliesResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedReadCommentRepliesResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedReadCommentRepliesResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedReadCommentRepliesResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedReadCommentReplies"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedLikeCommentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedLikeCommentArgs {
  social_feed_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedLikeCommentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedLikeCommentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedLikeCommentArgs.social_feed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedLikeCommentArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedLikeCommentArgs {
      social_feed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_LikeComment_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("socialFeedId", TType::String, 1))?;
    o_prot.write_string(&self.social_feed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedLikeCommentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedLikeCommentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedLikeCommentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedLikeCommentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedLikeCommentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedLikeCommentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedLikeComment"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedLikeActivityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedLikeActivityArgs {
  social_feed_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedLikeActivityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedLikeActivityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedLikeActivityArgs.social_feed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedLikeActivityArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedLikeActivityArgs {
      social_feed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_LikeActivity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("socialFeedId", TType::String, 1))?;
    o_prot.write_string(&self.social_feed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedLikeActivityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedLikeActivityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedLikeActivityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedLikeActivityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedLikeActivityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedLikeActivityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedLikeActivity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedUnlikeCommentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnlikeCommentArgs {
  social_feed_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedUnlikeCommentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnlikeCommentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnlikeCommentArgs.social_feed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnlikeCommentArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedUnlikeCommentArgs {
      social_feed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_UnlikeComment_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("socialFeedId", TType::String, 1))?;
    o_prot.write_string(&self.social_feed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedUnlikeCommentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnlikeCommentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedUnlikeCommentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnlikeCommentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedUnlikeCommentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedUnlikeCommentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedUnlikeComment"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedUnlikeActivityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnlikeActivityArgs {
  social_feed_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedUnlikeActivityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnlikeActivityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnlikeActivityArgs.social_feed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnlikeActivityArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedUnlikeActivityArgs {
      social_feed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_UnlikeActivity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("socialFeedId", TType::String, 1))?;
    o_prot.write_string(&self.social_feed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedUnlikeActivityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnlikeActivityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedUnlikeActivityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnlikeActivityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedUnlikeActivityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedUnlikeActivityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedUnlikeActivity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedSetFeedVisibilityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedSetFeedVisibilityArgs {
  visibility: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedSetFeedVisibilityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedSetFeedVisibilityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedSetFeedVisibilityArgs.visibility", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedSetFeedVisibilityArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedSetFeedVisibilityArgs {
      visibility: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_SetFeedVisibility_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("visibility", TType::String, 1))?;
    o_prot.write_string(&self.visibility)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedSetFeedVisibilityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedSetFeedVisibilityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedSetFeedVisibilityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedSetFeedVisibilityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedSetFeedVisibilityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedSetFeedVisibilityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedSetFeedVisibility"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedBlockPlayerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedBlockPlayerArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedBlockPlayerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedBlockPlayerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedBlockPlayerArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedBlockPlayerArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedBlockPlayerArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_BlockPlayer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedBlockPlayerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedBlockPlayerResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedBlockPlayerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedBlockPlayerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedBlockPlayerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedBlockPlayerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedBlockPlayer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedHidePlayerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedHidePlayerArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedHidePlayerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedHidePlayerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedHidePlayerArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedHidePlayerArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedHidePlayerArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_HidePlayer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedHidePlayerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedHidePlayerResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedHidePlayerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedHidePlayerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedHidePlayerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedHidePlayerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedHidePlayer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedUnblockPlayerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnblockPlayerArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedUnblockPlayerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnblockPlayerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnblockPlayerArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnblockPlayerArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedUnblockPlayerArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_UnblockPlayer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedUnblockPlayerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnblockPlayerResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedUnblockPlayerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnblockPlayerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedUnblockPlayerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedUnblockPlayerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedUnblockPlayer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedUnhidePlayerArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnhidePlayerArgs {
  player_id: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedUnhidePlayerArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnhidePlayerArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnhidePlayerArgs.player_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedUnhidePlayerArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceSocialFeedUnhidePlayerArgs {
      player_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_UnhidePlayer_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("playerId", TType::String, 1))?;
    o_prot.write_string(&self.player_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedUnhidePlayerResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedUnhidePlayerResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedUnhidePlayerResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedUnhidePlayerResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedUnhidePlayerResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedUnhidePlayerResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedUnhidePlayer"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedGetActivityArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedGetActivityArgs {
  social_feed_id: String,
  depth: i32,
  skip: i32,
  limit: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedGetActivityArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedGetActivityArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetActivityArgs.social_feed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetActivityArgs.depth", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetActivityArgs.skip", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetActivityArgs.limit", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetActivityArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceSocialFeedGetActivityArgs {
      social_feed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      depth: f_2.expect("auto-generated code should have checked for presence of required fields"),
      skip: f_3.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_GetActivity_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("socialFeedId", TType::String, 1))?;
    o_prot.write_string(&self.social_feed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("depth", TType::I32, 2))?;
    o_prot.write_i32(self.depth)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 3))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 4))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedGetActivityResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedGetActivityResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedGetActivityResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedGetActivityResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedGetActivityResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedGetActivityResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedGetActivity"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceSocialFeedGetCommentArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedGetCommentArgs {
  social_feed_id: String,
  depth: i32,
  skip: i32,
  limit: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceSocialFeedGetCommentArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedGetCommentArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    let mut f_4: Option<i32> = None;
    let mut f_5: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetCommentArgs.social_feed_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetCommentArgs.depth", &f_2)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetCommentArgs.skip", &f_3)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetCommentArgs.limit", &f_4)?;
    verify_required_field_exists("BrainCloudServiceSocialFeedGetCommentArgs.client_index", &f_5)?;
    let ret = BrainCloudServiceSocialFeedGetCommentArgs {
      social_feed_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      depth: f_2.expect("auto-generated code should have checked for presence of required fields"),
      skip: f_3.expect("auto-generated code should have checked for presence of required fields"),
      limit: f_4.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_5.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SocialFeed_GetComment_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("socialFeedId", TType::String, 1))?;
    o_prot.write_string(&self.social_feed_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("depth", TType::I32, 2))?;
    o_prot.write_i32(self.depth)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("skip", TType::I32, 3))?;
    o_prot.write_i32(self.skip)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("limit", TType::I32, 4))?;
    o_prot.write_i32(self.limit)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 5))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceSocialFeedGetCommentResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceSocialFeedGetCommentResult {
  result_value: Option<String>,
}

impl BrainCloudServiceSocialFeedGetCommentResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceSocialFeedGetCommentResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceSocialFeedGetCommentResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceSocialFeedGetCommentResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceSocialFeedGetComment"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTelemetryStartTelemetrySessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryStartTelemetrySessionArgs {
  timestamp: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTelemetryStartTelemetrySessionArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryStartTelemetrySessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    let mut f_2: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetrySessionArgs.timestamp", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetrySessionArgs.client_index", &f_2)?;
    let ret = BrainCloudServiceTelemetryStartTelemetrySessionArgs {
      timestamp: f_1.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_2.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Telemetry_StartTelemetrySession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 1))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 2))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTelemetryStartTelemetrySessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryStartTelemetrySessionResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTelemetryStartTelemetrySessionResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryStartTelemetrySessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTelemetryStartTelemetrySessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTelemetryStartTelemetrySessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTelemetryStartTelemetrySession"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTelemetryEndTelemetrySessionArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryEndTelemetrySessionArgs {
  telemetry_session_id: String,
  timestamp: i32,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTelemetryEndTelemetrySessionArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryEndTelemetrySessionArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetrySessionArgs.telemetry_session_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetrySessionArgs.timestamp", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetrySessionArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceTelemetryEndTelemetrySessionArgs {
      telemetry_session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Telemetry_EndTelemetrySession_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("telemetrySessionId", TType::String, 1))?;
    o_prot.write_string(&self.telemetry_session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 2))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTelemetryEndTelemetrySessionResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryEndTelemetrySessionResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTelemetryEndTelemetrySessionResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryEndTelemetrySessionResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTelemetryEndTelemetrySessionResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTelemetryEndTelemetrySessionResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTelemetryEndTelemetrySession"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTelemetryLogTelemetryEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryLogTelemetryEventArgs {
  telemetry_session_id: String,
  timestamp: i32,
  event_type: String,
  participant_id: String,
  custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTelemetryLogTelemetryEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryLogTelemetryEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_48 = i_prot.read_string()?;
            let map_val_49 = i_prot.read_string()?;
            val.insert(map_key_48, map_val_49);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTelemetryLogTelemetryEventArgs.telemetry_session_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTelemetryLogTelemetryEventArgs.timestamp", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTelemetryLogTelemetryEventArgs.event_type", &f_3)?;
    verify_required_field_exists("BrainCloudServiceTelemetryLogTelemetryEventArgs.participant_id", &f_4)?;
    verify_required_field_exists("BrainCloudServiceTelemetryLogTelemetryEventArgs.custom_data", &f_5)?;
    verify_required_field_exists("BrainCloudServiceTelemetryLogTelemetryEventArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceTelemetryLogTelemetryEventArgs {
      telemetry_session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      participant_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      custom_data: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Telemetry_LogTelemetryEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("telemetrySessionId", TType::String, 1))?;
    o_prot.write_string(&self.telemetry_session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 2))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::String, 3))?;
    o_prot.write_string(&self.event_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("participantId", TType::String, 4))?;
    o_prot.write_string(&self.participant_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customData", TType::Map, 5))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.custom_data.len() as i32))?;
    for (k, v) in &self.custom_data {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTelemetryLogTelemetryEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryLogTelemetryEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTelemetryLogTelemetryEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryLogTelemetryEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTelemetryLogTelemetryEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTelemetryLogTelemetryEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTelemetryLogTelemetryEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTelemetryStartTelemetryEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryStartTelemetryEventArgs {
  telemetry_session_id: String,
  timestamp: i32,
  event_type: String,
  participant_id: String,
  custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTelemetryStartTelemetryEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryStartTelemetryEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_50 = i_prot.read_string()?;
            let map_val_51 = i_prot.read_string()?;
            val.insert(map_key_50, map_val_51);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetryEventArgs.telemetry_session_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetryEventArgs.timestamp", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetryEventArgs.event_type", &f_3)?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetryEventArgs.participant_id", &f_4)?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetryEventArgs.custom_data", &f_5)?;
    verify_required_field_exists("BrainCloudServiceTelemetryStartTelemetryEventArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceTelemetryStartTelemetryEventArgs {
      telemetry_session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      participant_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      custom_data: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Telemetry_StartTelemetryEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("telemetrySessionId", TType::String, 1))?;
    o_prot.write_string(&self.telemetry_session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 2))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::String, 3))?;
    o_prot.write_string(&self.event_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("participantId", TType::String, 4))?;
    o_prot.write_string(&self.participant_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customData", TType::Map, 5))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.custom_data.len() as i32))?;
    for (k, v) in &self.custom_data {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTelemetryStartTelemetryEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryStartTelemetryEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTelemetryStartTelemetryEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryStartTelemetryEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTelemetryStartTelemetryEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTelemetryStartTelemetryEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTelemetryStartTelemetryEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceTelemetryEndTelemetryEventArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryEndTelemetryEventArgs {
  telemetry_session_id: String,
  timestamp: i32,
  event_type: String,
  participant_id: String,
  custom_data: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceTelemetryEndTelemetryEventArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryEndTelemetryEventArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<i32> = None;
    let mut f_3: Option<String> = None;
    let mut f_4: Option<String> = None;
    let mut f_5: Option<BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON>> = None;
    let mut f_6: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, brain_cloud_service_s_d_k_data_types::JSON> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_52 = i_prot.read_string()?;
            let map_val_53 = i_prot.read_string()?;
            val.insert(map_key_52, map_val_53);
          }
          i_prot.read_map_end()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_i32()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetryEventArgs.telemetry_session_id", &f_1)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetryEventArgs.timestamp", &f_2)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetryEventArgs.event_type", &f_3)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetryEventArgs.participant_id", &f_4)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetryEventArgs.custom_data", &f_5)?;
    verify_required_field_exists("BrainCloudServiceTelemetryEndTelemetryEventArgs.client_index", &f_6)?;
    let ret = BrainCloudServiceTelemetryEndTelemetryEventArgs {
      telemetry_session_id: f_1.expect("auto-generated code should have checked for presence of required fields"),
      timestamp: f_2.expect("auto-generated code should have checked for presence of required fields"),
      event_type: f_3.expect("auto-generated code should have checked for presence of required fields"),
      participant_id: f_4.expect("auto-generated code should have checked for presence of required fields"),
      custom_data: f_5.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_6.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Telemetry_EndTelemetryEvent_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("telemetrySessionId", TType::String, 1))?;
    o_prot.write_string(&self.telemetry_session_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I32, 2))?;
    o_prot.write_i32(self.timestamp)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("eventType", TType::String, 3))?;
    o_prot.write_string(&self.event_type)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("participantId", TType::String, 4))?;
    o_prot.write_string(&self.participant_id)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("customData", TType::Map, 5))?;
    o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::String, self.custom_data.len() as i32))?;
    for (k, v) in &self.custom_data {
      o_prot.write_string(k)?;
      o_prot.write_string(v)?;
      o_prot.write_map_end()?;
    }
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 6))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceTelemetryEndTelemetryEventResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceTelemetryEndTelemetryEventResult {
  result_value: Option<String>,
}

impl BrainCloudServiceTelemetryEndTelemetryEventResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceTelemetryEndTelemetryEventResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceTelemetryEndTelemetryEventResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceTelemetryEndTelemetryEventResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceTelemetryEndTelemetryEvent"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs {
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i32()?;
          f_1 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs.client_index", &f_1)?;
    let ret = BrainCloudServiceAuthenticationGetWeChatQRPageURLArgs {
      client_index: f_1.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("Authentication_GetWeChatQRPageURL_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 1))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceAuthenticationGetWeChatQRPageURLResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceAuthenticationGetWeChatQRPageURLResult {
  result_value: Option<String>,
}

impl BrainCloudServiceAuthenticationGetWeChatQRPageURLResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceAuthenticationGetWeChatQRPageURLResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceAuthenticationGetWeChatQRPageURLResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceAuthenticationGetWeChatQRPageURLResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceAuthenticationGetWeChatQRPageURL"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileDownloadFileArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileDownloadFileArgs {
  /// @BrainCloudFile_cloudPath
  cloud_path: String,
  /// @BrainCloudFile_cloudFilename
  cloud_filename: String,
  /// @BrainCloudFile_replaceIfExists
  replace_if_exists: bool,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileDownloadFileArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileDownloadFileArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<bool> = None;
    let mut f_4: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileDownloadFileArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileDownloadFileArgs.cloud_filename", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileDownloadFileArgs.replace_if_exists", &f_3)?;
    verify_required_field_exists("BrainCloudServiceFileDownloadFileArgs.client_index", &f_4)?;
    let ret = BrainCloudServiceFileDownloadFileArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cloud_filename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      replace_if_exists: f_3.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_4.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_DownloadFile_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudFilename", TType::String, 2))?;
    o_prot.write_string(&self.cloud_filename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("replaceIfExists", TType::Bool, 3))?;
    o_prot.write_bool(self.replace_if_exists)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 4))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileDownloadFileResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileDownloadFileResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileDownloadFileResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileDownloadFileResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileDownloadFileResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileDownloadFileResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileDownloadFile"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileGetDownloadInfoArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetDownloadInfoArgs {
  /// @BrainCloudFile_cloudPath
  cloud_path: String,
  /// @BrainCloudFile_cloudFileName
  cloud_filename: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileGetDownloadInfoArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetDownloadInfoArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileGetDownloadInfoArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileGetDownloadInfoArgs.cloud_filename", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileGetDownloadInfoArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFileGetDownloadInfoArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cloud_filename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_GetDownloadInfo_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudFilename", TType::String, 2))?;
    o_prot.write_string(&self.cloud_filename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileGetDownloadInfoResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileGetDownloadInfoResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileGetDownloadInfoResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileGetDownloadInfoResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileGetDownloadInfoResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileGetDownloadInfoResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileGetDownloadInfo"
          )
        )
      )
    }
  }
}

//
// BrainCloudServiceFileCancelDownloadArgs
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileCancelDownloadArgs {
  /// @BrainCloudFile_cloudPath
  cloud_path: String,
  /// @BrainCloudFile_cloudFileName
  cloud_filename: String,
  /// @BrainCloud_clientIndex_desc
  client_index: i32,
}

impl BrainCloudServiceFileCancelDownloadArgs {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileCancelDownloadArgs> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = None;
    let mut f_2: Option<String> = None;
    let mut f_3: Option<i32> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    verify_required_field_exists("BrainCloudServiceFileCancelDownloadArgs.cloud_path", &f_1)?;
    verify_required_field_exists("BrainCloudServiceFileCancelDownloadArgs.cloud_filename", &f_2)?;
    verify_required_field_exists("BrainCloudServiceFileCancelDownloadArgs.client_index", &f_3)?;
    let ret = BrainCloudServiceFileCancelDownloadArgs {
      cloud_path: f_1.expect("auto-generated code should have checked for presence of required fields"),
      cloud_filename: f_2.expect("auto-generated code should have checked for presence of required fields"),
      client_index: f_3.expect("auto-generated code should have checked for presence of required fields"),
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("File_CancelDownload_args");
    o_prot.write_struct_begin(&struct_ident)?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudPath", TType::String, 1))?;
    o_prot.write_string(&self.cloud_path)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("cloudFilename", TType::String, 2))?;
    o_prot.write_string(&self.cloud_filename)?;
    o_prot.write_field_end()?;
    o_prot.write_field_begin(&TFieldIdentifier::new("clientIndex", TType::I32, 3))?;
    o_prot.write_i32(self.client_index)?;
    o_prot.write_field_end()?;
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

//
// BrainCloudServiceFileCancelDownloadResult
//

#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct BrainCloudServiceFileCancelDownloadResult {
  result_value: Option<String>,
}

impl BrainCloudServiceFileCancelDownloadResult {
  fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<BrainCloudServiceFileCancelDownloadResult> {
    i_prot.read_struct_begin()?;
    let mut f_0: Option<String> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        0 => {
          let val = i_prot.read_string()?;
          f_0 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = BrainCloudServiceFileCancelDownloadResult {
      result_value: f_0,
    };
    Ok(ret)
  }
  fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("BrainCloudServiceFileCancelDownloadResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.result_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("result_value", TType::String, 0))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
  fn ok_or(self) -> thrift::Result<String> {
    if self.result_value.is_some() {
      Ok(self.result_value.unwrap())
    } else {
      Err(
        thrift::Error::Application(
          ApplicationError::new(
            ApplicationErrorKind::MissingResult,
            "no result received for BrainCloudServiceFileCancelDownload"
          )
        )
      )
    }
  }
}

