// Autogenerated by Thrift Compiler (0.12.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use common_type_s_d_k_data_types;

/// @NodeType_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum NodeType {
  Category = 1,
  SettingItem = 2,
  All = 3,
}

impl NodeType {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<NodeType> {
    let enum_value = i_prot.read_i32()?;
    NodeType::try_from(enum_value)  }
}

impl TryFrom<i32> for NodeType {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      1 => Ok(NodeType::Category),
      2 => Ok(NodeType::SettingItem),
      3 => Ok(NodeType::All),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to NodeType", i)
            )
          )
        )
      },
    }
  }
}

pub type JSON = String;

pub type _int = i32;

//
// RuyiNetworkSettingNameValue
//

/// @RuyiNetworkSettingNameValue_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiNetworkSettingNameValue {
  /// @RuyiNetworkSettingNameValue_name_desc
  pub name: Option<String>,
  /// @RuyiNetworkSettingNameValue_value_desc
  pub value: Option<String>,
}

impl RuyiNetworkSettingNameValue {
  pub fn new<F1, F2>(name: F1, value: F2) -> RuyiNetworkSettingNameValue where F1: Into<Option<String>>, F2: Into<Option<String>> {
    RuyiNetworkSettingNameValue {
      name: name.into(),
      value: value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiNetworkSettingNameValue> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiNetworkSettingNameValue {
      name: f_1,
      value: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiNetworkSettingNameValue");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.value {
      o_prot.write_field_begin(&TFieldIdentifier::new("value", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiNetworkSettingNameValue {
  fn default() -> Self {
    RuyiNetworkSettingNameValue{
      name: Some("".to_owned()),
      value: Some("".to_owned()),
    }
  }
}

//
// RuyiNetworkTestItem
//

/// @RuyiNetworkTestItem_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiNetworkTestItem {
  /// @RuyiNetworkTestItem_item_desc
  pub item: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkTestItem_result_desc
  pub result: Option<bool>,
}

impl RuyiNetworkTestItem {
  pub fn new<F1, F2>(item: F1, result: F2) -> RuyiNetworkTestItem where F1: Into<Option<RuyiNetworkSettingNameValue>>, F2: Into<Option<bool>> {
    RuyiNetworkTestItem {
      item: item.into(),
      result: result.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiNetworkTestItem> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_2: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiNetworkTestItem {
      item: f_1,
      result: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiNetworkTestItem");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.item {
      o_prot.write_field_begin(&TFieldIdentifier::new("item", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.result {
      o_prot.write_field_begin(&TFieldIdentifier::new("result", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiNetworkTestItem {
  fn default() -> Self {
    RuyiNetworkTestItem{
      item: None,
      result: Some(false),
    }
  }
}

//
// RuyiNetworkSettings
//

/// @RuyiNetworkSettings_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiNetworkSettings {
  /// @RuyiNetworkSettings_connection_desc
  pub connection: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_networkType_desc
  pub network_type: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_quality_desc
  pub quality: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_SSID_desc
  pub s_s_i_d: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_BSSID_desc
  pub b_s_s_i_d: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_Authentication_desc
  pub authentication: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_DHCPEnabled_desc
  pub d_h_c_p_enabled: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_IpAddress_desc
  pub ip_address: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_SubMask_desc
  pub sub_mask: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_Gateway_desc
  pub gateway: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_MainDNS_desc
  pub main_d_n_s: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_SubDNS_desc
  pub sub_d_n_s: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_MacAddress_desc
  pub mac_address: Option<RuyiNetworkSettingNameValue>,
  /// @RuyiNetworkSettings_Proxy_desc
  pub proxy: Option<RuyiNetworkSettingNameValue>,
}

impl RuyiNetworkSettings {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14>(connection: F1, network_type: F2, quality: F3, s_s_i_d: F4, b_s_s_i_d: F5, authentication: F6, d_h_c_p_enabled: F7, ip_address: F8, sub_mask: F9, gateway: F10, main_d_n_s: F11, sub_d_n_s: F12, mac_address: F13, proxy: F14) -> RuyiNetworkSettings where F1: Into<Option<RuyiNetworkSettingNameValue>>, F2: Into<Option<RuyiNetworkSettingNameValue>>, F3: Into<Option<RuyiNetworkSettingNameValue>>, F4: Into<Option<RuyiNetworkSettingNameValue>>, F5: Into<Option<RuyiNetworkSettingNameValue>>, F6: Into<Option<RuyiNetworkSettingNameValue>>, F7: Into<Option<RuyiNetworkSettingNameValue>>, F8: Into<Option<RuyiNetworkSettingNameValue>>, F9: Into<Option<RuyiNetworkSettingNameValue>>, F10: Into<Option<RuyiNetworkSettingNameValue>>, F11: Into<Option<RuyiNetworkSettingNameValue>>, F12: Into<Option<RuyiNetworkSettingNameValue>>, F13: Into<Option<RuyiNetworkSettingNameValue>>, F14: Into<Option<RuyiNetworkSettingNameValue>> {
    RuyiNetworkSettings {
      connection: connection.into(),
      network_type: network_type.into(),
      quality: quality.into(),
      s_s_i_d: s_s_i_d.into(),
      b_s_s_i_d: b_s_s_i_d.into(),
      authentication: authentication.into(),
      d_h_c_p_enabled: d_h_c_p_enabled.into(),
      ip_address: ip_address.into(),
      sub_mask: sub_mask.into(),
      gateway: gateway.into(),
      main_d_n_s: main_d_n_s.into(),
      sub_d_n_s: sub_d_n_s.into(),
      mac_address: mac_address.into(),
      proxy: proxy.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiNetworkSettings> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_2: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_3: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_4: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_5: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_6: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_7: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_8: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_9: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_10: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_11: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_12: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_13: Option<RuyiNetworkSettingNameValue> = None;
    let mut f_14: Option<RuyiNetworkSettingNameValue> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        4 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        5 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_5 = Some(val);
        },
        6 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_6 = Some(val);
        },
        7 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_7 = Some(val);
        },
        8 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_8 = Some(val);
        },
        9 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_9 = Some(val);
        },
        10 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_10 = Some(val);
        },
        11 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_11 = Some(val);
        },
        12 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_12 = Some(val);
        },
        13 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_13 = Some(val);
        },
        14 => {
          let val = RuyiNetworkSettingNameValue::read_from_in_protocol(i_prot)?;
          f_14 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiNetworkSettings {
      connection: f_1,
      network_type: f_2,
      quality: f_3,
      s_s_i_d: f_4,
      b_s_s_i_d: f_5,
      authentication: f_6,
      d_h_c_p_enabled: f_7,
      ip_address: f_8,
      sub_mask: f_9,
      gateway: f_10,
      main_d_n_s: f_11,
      sub_d_n_s: f_12,
      mac_address: f_13,
      proxy: f_14,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiNetworkSettings");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.connection {
      o_prot.write_field_begin(&TFieldIdentifier::new("connection", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.network_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("networkType", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.quality {
      o_prot.write_field_begin(&TFieldIdentifier::new("quality", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.s_s_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("SSID", TType::Struct, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.b_s_s_i_d {
      o_prot.write_field_begin(&TFieldIdentifier::new("BSSID", TType::Struct, 5))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.authentication {
      o_prot.write_field_begin(&TFieldIdentifier::new("Authentication", TType::Struct, 6))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.d_h_c_p_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("DHCPEnabled", TType::Struct, 7))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ip_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("IpAddress", TType::Struct, 8))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sub_mask {
      o_prot.write_field_begin(&TFieldIdentifier::new("SubMask", TType::Struct, 9))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.gateway {
      o_prot.write_field_begin(&TFieldIdentifier::new("Gateway", TType::Struct, 10))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.main_d_n_s {
      o_prot.write_field_begin(&TFieldIdentifier::new("MainDNS", TType::Struct, 11))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sub_d_n_s {
      o_prot.write_field_begin(&TFieldIdentifier::new("SubDNS", TType::Struct, 12))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.mac_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("MacAddress", TType::Struct, 13))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.proxy {
      o_prot.write_field_begin(&TFieldIdentifier::new("Proxy", TType::Struct, 14))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiNetworkSettings {
  fn default() -> Self {
    RuyiNetworkSettings{
      connection: None,
      network_type: None,
      quality: None,
      s_s_i_d: None,
      b_s_s_i_d: None,
      authentication: None,
      d_h_c_p_enabled: None,
      ip_address: None,
      sub_mask: None,
      gateway: None,
      main_d_n_s: None,
      sub_d_n_s: None,
      mac_address: None,
      proxy: None,
    }
  }
}

//
// RuyiNetworkStatus
//

/// @RuyiNetworkStatus_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiNetworkStatus {
  /// @RuyiNetworkStatus_isWifi_desc
  pub is_wifi: Option<bool>,
  /// @RuyiNetworkStatus_Name_desc
  pub name: Option<String>,
  /// @RuyiNetworkStatus_AdapterStatus_desc
  pub adapter_status: Option<bool>,
  /// @RuyiNetworkStatus_InternetStatus_desc
  pub internet_status: Option<bool>,
}

impl RuyiNetworkStatus {
  pub fn new<F1, F2, F3, F4>(is_wifi: F1, name: F2, adapter_status: F3, internet_status: F4) -> RuyiNetworkStatus where F1: Into<Option<bool>>, F2: Into<Option<String>>, F3: Into<Option<bool>>, F4: Into<Option<bool>> {
    RuyiNetworkStatus {
      is_wifi: is_wifi.into(),
      name: name.into(),
      adapter_status: adapter_status.into(),
      internet_status: internet_status.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiNetworkStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiNetworkStatus {
      is_wifi: f_1,
      name: f_2,
      adapter_status: f_3,
      internet_status: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiNetworkStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_wifi {
      o_prot.write_field_begin(&TFieldIdentifier::new("isWifi", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("Name", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.adapter_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("AdapterStatus", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.internet_status {
      o_prot.write_field_begin(&TFieldIdentifier::new("InternetStatus", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiNetworkStatus {
  fn default() -> Self {
    RuyiNetworkStatus{
      is_wifi: Some(false),
      name: Some("".to_owned()),
      adapter_status: Some(false),
      internet_status: Some(false),
    }
  }
}

//
// RuyiNetworkTestResult
//

/// @RuyiNetworkTestResult_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RuyiNetworkTestResult {
  /// @RuyiNetworkTestResult_localconnection_desc
  pub localconnection: Option<RuyiNetworkTestItem>,
  /// @RuyiNetworkTestResult_ipaddress_desc
  pub ipaddress: Option<RuyiNetworkTestItem>,
  /// @RuyiNetworkTestResult_internetconnection_desc
  pub internetconnection: Option<RuyiNetworkTestItem>,
}

impl RuyiNetworkTestResult {
  pub fn new<F1, F2, F3>(localconnection: F1, ipaddress: F2, internetconnection: F3) -> RuyiNetworkTestResult where F1: Into<Option<RuyiNetworkTestItem>>, F2: Into<Option<RuyiNetworkTestItem>>, F3: Into<Option<RuyiNetworkTestItem>> {
    RuyiNetworkTestResult {
      localconnection: localconnection.into(),
      ipaddress: ipaddress.into(),
      internetconnection: internetconnection.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<RuyiNetworkTestResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<RuyiNetworkTestItem> = None;
    let mut f_2: Option<RuyiNetworkTestItem> = None;
    let mut f_3: Option<RuyiNetworkTestItem> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = RuyiNetworkTestItem::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let val = RuyiNetworkTestItem::read_from_in_protocol(i_prot)?;
          f_2 = Some(val);
        },
        3 => {
          let val = RuyiNetworkTestItem::read_from_in_protocol(i_prot)?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = RuyiNetworkTestResult {
      localconnection: f_1,
      ipaddress: f_2,
      internetconnection: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("RuyiNetworkTestResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.localconnection {
      o_prot.write_field_begin(&TFieldIdentifier::new("localconnection", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.ipaddress {
      o_prot.write_field_begin(&TFieldIdentifier::new("ipaddress", TType::Struct, 2))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.internetconnection {
      o_prot.write_field_begin(&TFieldIdentifier::new("internetconnection", TType::Struct, 3))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for RuyiNetworkTestResult {
  fn default() -> Self {
    RuyiNetworkTestResult{
      localconnection: None,
      ipaddress: None,
      internetconnection: None,
    }
  }
}

//
// NetworkConnectionStatus
//

/// @NetworkConnectionStatus_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NetworkConnectionStatus {
  /// @NetworkConnectionStatus_preLanAdapter_desc
  pub pre_lan_adapter: Option<bool>,
  /// @NetworkConnectionStatus_curLanAdapter_desc
  pub cur_lan_adapter: Option<bool>,
  /// @NetworkConnectionStatus_preWlanAdapter_desc
  pub pre_wlan_adapter: Option<bool>,
  /// @NetworkConnectionStatus_curWlanAdapter_desc
  pub cur_wlan_adapter: Option<bool>,
  /// @NetworkConnectionStatus_preInternetConnection_desc
  pub pre_internet_connection: Option<bool>,
  /// @NetworkConnectionStatus_curInternetConnection_desc
  pub cur_internet_connection: Option<bool>,
}

impl NetworkConnectionStatus {
  pub fn new<F1, F2, F3, F4, F5, F6>(pre_lan_adapter: F1, cur_lan_adapter: F2, pre_wlan_adapter: F3, cur_wlan_adapter: F4, pre_internet_connection: F5, cur_internet_connection: F6) -> NetworkConnectionStatus where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<bool>>, F5: Into<Option<bool>>, F6: Into<Option<bool>> {
    NetworkConnectionStatus {
      pre_lan_adapter: pre_lan_adapter.into(),
      cur_lan_adapter: cur_lan_adapter.into(),
      pre_wlan_adapter: pre_wlan_adapter.into(),
      cur_wlan_adapter: cur_wlan_adapter.into(),
      pre_internet_connection: pre_internet_connection.into(),
      cur_internet_connection: cur_internet_connection.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<NetworkConnectionStatus> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<bool> = Some(false);
    let mut f_5: Option<bool> = Some(false);
    let mut f_6: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_bool()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_bool()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NetworkConnectionStatus {
      pre_lan_adapter: f_1,
      cur_lan_adapter: f_2,
      pre_wlan_adapter: f_3,
      cur_wlan_adapter: f_4,
      pre_internet_connection: f_5,
      cur_internet_connection: f_6,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NetworkConnectionStatus");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.pre_lan_adapter {
      o_prot.write_field_begin(&TFieldIdentifier::new("preLanAdapter", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cur_lan_adapter {
      o_prot.write_field_begin(&TFieldIdentifier::new("curLanAdapter", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.pre_wlan_adapter {
      o_prot.write_field_begin(&TFieldIdentifier::new("preWlanAdapter", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cur_wlan_adapter {
      o_prot.write_field_begin(&TFieldIdentifier::new("curWlanAdapter", TType::Bool, 4))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.pre_internet_connection {
      o_prot.write_field_begin(&TFieldIdentifier::new("preInternetConnection", TType::Bool, 5))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.cur_internet_connection {
      o_prot.write_field_begin(&TFieldIdentifier::new("curInternetConnection", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NetworkConnectionStatus {
  fn default() -> Self {
    NetworkConnectionStatus{
      pre_lan_adapter: Some(false),
      cur_lan_adapter: Some(false),
      pre_wlan_adapter: Some(false),
      cur_wlan_adapter: Some(false),
      pre_internet_connection: Some(false),
      cur_internet_connection: Some(false),
    }
  }
}

//
// NetworkSettings
//

/// @NetworkSettings_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NetworkSettings {
  /// @NetworkSettings_isWifi_desc
  pub is_wifi: Option<bool>,
  /// @NetworkSettings_proxyUsed_desc
  pub proxy_used: Option<bool>,
  /// @NetworkSettings_DHCPEnabled_desc
  pub d_h_c_p_enabled: Option<bool>,
  /// @NetworkSettings_NetworkName_desc
  pub network_name: Option<String>,
  /// @NetworkSettings_AuthType_desc
  pub auth_type: Option<String>,
  /// @NetworkSettings_IPAddress_desc
  pub i_p_address: Option<String>,
  /// @NetworkSettings_SubMask_desc
  pub sub_mask: Option<String>,
  /// @NetworkSettings_GateWay_desc
  pub gate_way: Option<String>,
  /// @NetworkSettings_mainDNS_desc
  pub main_d_n_s: Option<String>,
  /// @NetworkSettings_subDNS_desc
  pub sub_d_n_s: Option<String>,
  /// @NetworkSettings_proxyServer_desc
  pub proxy_server: Option<String>,
  /// @NetworkSettings_proxyPort_desc
  pub proxy_port: Option<String>,
}

impl NetworkSettings {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12>(is_wifi: F1, proxy_used: F2, d_h_c_p_enabled: F3, network_name: F4, auth_type: F5, i_p_address: F6, sub_mask: F7, gate_way: F8, main_d_n_s: F9, sub_d_n_s: F10, proxy_server: F11, proxy_port: F12) -> NetworkSettings where F1: Into<Option<bool>>, F2: Into<Option<bool>>, F3: Into<Option<bool>>, F4: Into<Option<String>>, F5: Into<Option<String>>, F6: Into<Option<String>>, F7: Into<Option<String>>, F8: Into<Option<String>>, F9: Into<Option<String>>, F10: Into<Option<String>>, F11: Into<Option<String>>, F12: Into<Option<String>> {
    NetworkSettings {
      is_wifi: is_wifi.into(),
      proxy_used: proxy_used.into(),
      d_h_c_p_enabled: d_h_c_p_enabled.into(),
      network_name: network_name.into(),
      auth_type: auth_type.into(),
      i_p_address: i_p_address.into(),
      sub_mask: sub_mask.into(),
      gate_way: gate_way.into(),
      main_d_n_s: main_d_n_s.into(),
      sub_d_n_s: sub_d_n_s.into(),
      proxy_server: proxy_server.into(),
      proxy_port: proxy_port.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<NetworkSettings> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<bool> = Some(false);
    let mut f_2: Option<bool> = Some(false);
    let mut f_3: Option<bool> = Some(false);
    let mut f_4: Option<String> = Some("".to_owned());
    let mut f_5: Option<String> = Some("".to_owned());
    let mut f_6: Option<String> = Some("".to_owned());
    let mut f_7: Option<String> = Some("".to_owned());
    let mut f_8: Option<String> = Some("".to_owned());
    let mut f_9: Option<String> = Some("".to_owned());
    let mut f_10: Option<String> = Some("".to_owned());
    let mut f_11: Option<String> = Some("".to_owned());
    let mut f_12: Option<String> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_bool()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_bool()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_bool()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_string()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_string()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_string()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_string()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_string()?;
          f_8 = Some(val);
        },
        9 => {
          let val = i_prot.read_string()?;
          f_9 = Some(val);
        },
        10 => {
          let val = i_prot.read_string()?;
          f_10 = Some(val);
        },
        11 => {
          let val = i_prot.read_string()?;
          f_11 = Some(val);
        },
        12 => {
          let val = i_prot.read_string()?;
          f_12 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NetworkSettings {
      is_wifi: f_1,
      proxy_used: f_2,
      d_h_c_p_enabled: f_3,
      network_name: f_4,
      auth_type: f_5,
      i_p_address: f_6,
      sub_mask: f_7,
      gate_way: f_8,
      main_d_n_s: f_9,
      sub_d_n_s: f_10,
      proxy_server: f_11,
      proxy_port: f_12,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NetworkSettings");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.is_wifi {
      o_prot.write_field_begin(&TFieldIdentifier::new("isWifi", TType::Bool, 1))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.proxy_used {
      o_prot.write_field_begin(&TFieldIdentifier::new("proxyUsed", TType::Bool, 2))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.d_h_c_p_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("DHCPEnabled", TType::Bool, 3))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.network_name {
      o_prot.write_field_begin(&TFieldIdentifier::new("NetworkName", TType::String, 4))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.auth_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("AuthType", TType::String, 5))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.i_p_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("IPAddress", TType::String, 6))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sub_mask {
      o_prot.write_field_begin(&TFieldIdentifier::new("SubMask", TType::String, 7))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.gate_way {
      o_prot.write_field_begin(&TFieldIdentifier::new("GateWay", TType::String, 8))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.main_d_n_s {
      o_prot.write_field_begin(&TFieldIdentifier::new("mainDNS", TType::String, 9))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.sub_d_n_s {
      o_prot.write_field_begin(&TFieldIdentifier::new("subDNS", TType::String, 10))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.proxy_server {
      o_prot.write_field_begin(&TFieldIdentifier::new("proxyServer", TType::String, 11))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.proxy_port {
      o_prot.write_field_begin(&TFieldIdentifier::new("proxyPort", TType::String, 12))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NetworkSettings {
  fn default() -> Self {
    NetworkSettings{
      is_wifi: Some(false),
      proxy_used: Some(false),
      d_h_c_p_enabled: Some(false),
      network_name: Some("".to_owned()),
      auth_type: Some("".to_owned()),
      i_p_address: Some("".to_owned()),
      sub_mask: Some("".to_owned()),
      gate_way: Some("".to_owned()),
      main_d_n_s: Some("".to_owned()),
      sub_d_n_s: Some("".to_owned()),
      proxy_server: Some("".to_owned()),
      proxy_port: Some("".to_owned()),
    }
  }
}

//
// CategoryNode
//

/// @CategoryNode_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CategoryNode {
  /// @CategoryNode_id_desc
  pub id: Option<String>,
  /// @CategoryNode_categoryId_desc
  pub category_id: Option<String>,
  /// @CategoryNode_sortingPriority_desc
  pub sorting_priority: Option<i32>,
  /// @CategoryNode_children_desc
  pub children: Option<Vec<Box<CategoryNode>>>,
}

impl CategoryNode {
  pub fn new<F1, F2, F3, F4>(id: F1, category_id: F2, sorting_priority: F3, children: F4) -> CategoryNode where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i32>>, F4: Into<Option<Vec<Box<CategoryNode>>>> {
    CategoryNode {
      id: id.into(),
      category_id: category_id.into(),
      sorting_priority: sorting_priority.into(),
      children: children.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<CategoryNode> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i32> = Some(0);
    let mut f_4: Option<Vec<Box<CategoryNode>>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<Box<CategoryNode>> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = Box::new(CategoryNode::read_from_in_protocol(i_prot)?);
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = CategoryNode {
      id: f_1,
      category_id: f_2,
      sorting_priority: f_3,
      children: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("CategoryNode");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.id {
      o_prot.write_field_begin(&TFieldIdentifier::new("id", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.category_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("categoryId", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.sorting_priority {
      o_prot.write_field_begin(&TFieldIdentifier::new("sortingPriority", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.children {
      o_prot.write_field_begin(&TFieldIdentifier::new("children", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for CategoryNode {
  fn default() -> Self {
    CategoryNode{
      id: Some("".to_owned()),
      category_id: Some("".to_owned()),
      sorting_priority: Some(0),
      children: Some(Vec::new()),
    }
  }
}

//
// SettingSearchResult
//

/// @SettingSearchResult_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingSearchResult {
  /// @SettingSearchResult_Version_desc
  pub version: Option<String>,
  /// @SettingSearchResult_SettingItems_desc
  pub setting_items: Option<Vec<common_type_s_d_k_data_types::SettingItem>>,
}

impl SettingSearchResult {
  pub fn new<F1, F2>(version: F1, setting_items: F2) -> SettingSearchResult where F1: Into<Option<String>>, F2: Into<Option<Vec<common_type_s_d_k_data_types::SettingItem>>> {
    SettingSearchResult {
      version: version.into(),
      setting_items: setting_items.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingSearchResult> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<Vec<common_type_s_d_k_data_types::SettingItem>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common_type_s_d_k_data_types::SettingItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_1 = common_type_s_d_k_data_types::SettingItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_1);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingSearchResult {
      version: f_1,
      setting_items: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingSearchResult");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.version {
      o_prot.write_field_begin(&TFieldIdentifier::new("Version", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.setting_items {
      o_prot.write_field_begin(&TFieldIdentifier::new("SettingItems", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingSearchResult {
  fn default() -> Self {
    SettingSearchResult{
      version: Some("".to_owned()),
      setting_items: Some(Vec::new()),
    }
  }
}

//
// SettingTree
//

/// @SettingTree_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct SettingTree {
  /// @SettingTree_CateNode_desc
  pub cate_node: Option<CategoryNode>,
  /// @SettingTree_SettingCategories_desc
  pub setting_categories: Option<BTreeMap<String, common_type_s_d_k_data_types::SettingCategory>>,
  /// @SettingTree_SettingItems_desc
  pub setting_items: Option<BTreeMap<String, common_type_s_d_k_data_types::SettingItem>>,
}

impl SettingTree {
  pub fn new<F1, F2, F3>(cate_node: F1, setting_categories: F2, setting_items: F3) -> SettingTree where F1: Into<Option<CategoryNode>>, F2: Into<Option<BTreeMap<String, common_type_s_d_k_data_types::SettingCategory>>>, F3: Into<Option<BTreeMap<String, common_type_s_d_k_data_types::SettingItem>>> {
    SettingTree {
      cate_node: cate_node.into(),
      setting_categories: setting_categories.into(),
      setting_items: setting_items.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<SettingTree> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<CategoryNode> = None;
    let mut f_2: Option<BTreeMap<String, common_type_s_d_k_data_types::SettingCategory>> = Some(BTreeMap::new());
    let mut f_3: Option<BTreeMap<String, common_type_s_d_k_data_types::SettingItem>> = Some(BTreeMap::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = CategoryNode::read_from_in_protocol(i_prot)?;
          f_1 = Some(val);
        },
        2 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, common_type_s_d_k_data_types::SettingCategory> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_2 = i_prot.read_string()?;
            let map_val_3 = common_type_s_d_k_data_types::SettingCategory::read_from_in_protocol(i_prot)?;
            val.insert(map_key_2, map_val_3);
          }
          i_prot.read_map_end()?;
          f_2 = Some(val);
        },
        3 => {
          let map_ident = i_prot.read_map_begin()?;
          let mut val: BTreeMap<String, common_type_s_d_k_data_types::SettingItem> = BTreeMap::new();
          for _ in 0..map_ident.size {
            let map_key_4 = i_prot.read_string()?;
            let map_val_5 = common_type_s_d_k_data_types::SettingItem::read_from_in_protocol(i_prot)?;
            val.insert(map_key_4, map_val_5);
          }
          i_prot.read_map_end()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = SettingTree {
      cate_node: f_1,
      setting_categories: f_2,
      setting_items: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("SettingTree");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.cate_node {
      o_prot.write_field_begin(&TFieldIdentifier::new("CateNode", TType::Struct, 1))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.setting_categories {
      o_prot.write_field_begin(&TFieldIdentifier::new("SettingCategories", TType::Map, 2))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.setting_items {
      o_prot.write_field_begin(&TFieldIdentifier::new("SettingItems", TType::Map, 3))?;
      o_prot.write_map_begin(&TMapIdentifier::new(TType::String, TType::Struct, fld_var.len() as i32))?;
      for (k, v) in fld_var {
        o_prot.write_string(k)?;
        v.write_to_out_protocol(o_prot)?;
        o_prot.write_map_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for SettingTree {
  fn default() -> Self {
    SettingTree{
      cate_node: None,
      setting_categories: Some(BTreeMap::new()),
      setting_items: Some(BTreeMap::new()),
    }
  }
}

//
// NodeList
//

/// @NodeList_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct NodeList {
  /// @NodeList_SettingCategories_desc
  pub setting_categories: Option<Vec<common_type_s_d_k_data_types::SettingCategory>>,
  /// @NodeList_SettingItems_desc
  pub setting_items: Option<Vec<common_type_s_d_k_data_types::SettingItem>>,
}

impl NodeList {
  pub fn new<F1, F2>(setting_categories: F1, setting_items: F2) -> NodeList where F1: Into<Option<Vec<common_type_s_d_k_data_types::SettingCategory>>>, F2: Into<Option<Vec<common_type_s_d_k_data_types::SettingItem>>> {
    NodeList {
      setting_categories: setting_categories.into(),
      setting_items: setting_items.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<NodeList> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<Vec<common_type_s_d_k_data_types::SettingCategory>> = Some(Vec::new());
    let mut f_2: Option<Vec<common_type_s_d_k_data_types::SettingItem>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common_type_s_d_k_data_types::SettingCategory> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_6 = common_type_s_d_k_data_types::SettingCategory::read_from_in_protocol(i_prot)?;
            val.push(list_elem_6);
          }
          i_prot.read_list_end()?;
          f_1 = Some(val);
        },
        2 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<common_type_s_d_k_data_types::SettingItem> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_7 = common_type_s_d_k_data_types::SettingItem::read_from_in_protocol(i_prot)?;
            val.push(list_elem_7);
          }
          i_prot.read_list_end()?;
          f_2 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = NodeList {
      setting_categories: f_1,
      setting_items: f_2,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("NodeList");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.setting_categories {
      o_prot.write_field_begin(&TFieldIdentifier::new("SettingCategories", TType::List, 1))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.setting_items {
      o_prot.write_field_begin(&TFieldIdentifier::new("SettingItems", TType::List, 2))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for NodeList {
  fn default() -> Self {
    NodeList{
      setting_categories: Some(Vec::new()),
      setting_items: Some(Vec::new()),
    }
  }
}

//
// WifiEntity
//

/// @WifiEntity_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct WifiEntity {
  /// @WifiEntity_Name_desc
  pub name: Option<String>,
  /// @WifiEntity_MacAddress_desc
  pub mac_address: Option<String>,
  /// @WifiEntity_Channel_desc
  pub channel: Option<_int>,
  /// @WifiEntity_CenterFrequancy_desc
  pub center_frequancy: Option<_int>,
  /// @WifiEntity_Rssi_desc
  pub rssi: Option<_int>,
  /// @WifiEntity_Connected_desc
  pub connected: Option<bool>,
  /// @WifiEntity_SecurityEnabled_desc
  pub security_enabled: Option<bool>,
  /// @WifiEntity_HasProfile_desc
  pub has_profile: Option<bool>,
}

impl WifiEntity {
  pub fn new<F1, F2, F3, F4, F5, F6, F7, F8>(name: F1, mac_address: F2, channel: F3, center_frequancy: F4, rssi: F5, connected: F6, security_enabled: F7, has_profile: F8) -> WifiEntity where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<_int>>, F4: Into<Option<_int>>, F5: Into<Option<_int>>, F6: Into<Option<bool>>, F7: Into<Option<bool>>, F8: Into<Option<bool>> {
    WifiEntity {
      name: name.into(),
      mac_address: mac_address.into(),
      channel: channel.into(),
      center_frequancy: center_frequancy.into(),
      rssi: rssi.into(),
      connected: connected.into(),
      security_enabled: security_enabled.into(),
      has_profile: has_profile.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<WifiEntity> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<_int> = Some(0);
    let mut f_4: Option<_int> = Some(0);
    let mut f_5: Option<_int> = Some(0);
    let mut f_6: Option<bool> = Some(false);
    let mut f_7: Option<bool> = Some(false);
    let mut f_8: Option<bool> = Some(false);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i32()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i32()?;
          f_4 = Some(val);
        },
        5 => {
          let val = i_prot.read_i32()?;
          f_5 = Some(val);
        },
        6 => {
          let val = i_prot.read_bool()?;
          f_6 = Some(val);
        },
        7 => {
          let val = i_prot.read_bool()?;
          f_7 = Some(val);
        },
        8 => {
          let val = i_prot.read_bool()?;
          f_8 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = WifiEntity {
      name: f_1,
      mac_address: f_2,
      channel: f_3,
      center_frequancy: f_4,
      rssi: f_5,
      connected: f_6,
      security_enabled: f_7,
      has_profile: f_8,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("WifiEntity");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.name {
      o_prot.write_field_begin(&TFieldIdentifier::new("Name", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.mac_address {
      o_prot.write_field_begin(&TFieldIdentifier::new("MacAddress", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.channel {
      o_prot.write_field_begin(&TFieldIdentifier::new("Channel", TType::I32, 3))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.center_frequancy {
      o_prot.write_field_begin(&TFieldIdentifier::new("CenterFrequancy", TType::I32, 4))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.rssi {
      o_prot.write_field_begin(&TFieldIdentifier::new("Rssi", TType::I32, 5))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.connected {
      o_prot.write_field_begin(&TFieldIdentifier::new("Connected", TType::Bool, 6))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.security_enabled {
      o_prot.write_field_begin(&TFieldIdentifier::new("SecurityEnabled", TType::Bool, 7))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.has_profile {
      o_prot.write_field_begin(&TFieldIdentifier::new("HasProfile", TType::Bool, 8))?;
      o_prot.write_bool(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for WifiEntity {
  fn default() -> Self {
    WifiEntity{
      name: Some("".to_owned()),
      mac_address: Some("".to_owned()),
      channel: Some(0),
      center_frequancy: Some(0),
      rssi: Some(0),
      connected: Some(false),
      security_enabled: Some(false),
      has_profile: Some(false),
    }
  }
}

