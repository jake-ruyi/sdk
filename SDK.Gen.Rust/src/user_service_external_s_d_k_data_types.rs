// Autogenerated by Thrift Compiler (0.12.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![cfg_attr(feature = "cargo-clippy", allow(too_many_arguments, type_complexity))]
#![cfg_attr(rustfmt, rustfmt_skip)]

extern crate ordered_float;
extern crate thrift;
extern crate try_from;

use ordered_float::OrderedFloat;
use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::From;
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;
use try_from::TryFrom;

use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;

use common_type_s_d_k_data_types;

/// @UserGender_desc
#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum UserGender {
  /// @UserGender_Unknown
  Unknown = 0,
  /// @UserGender_Male
  Male = 1,
  /// @UserGender_Female
  Female = 2,
}

impl UserGender {
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    o_prot.write_i32(*self as i32)
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<UserGender> {
    let enum_value = i_prot.read_i32()?;
    UserGender::try_from(enum_value)  }
}

impl TryFrom<i32> for UserGender {
  type Err = thrift::Error;  fn try_from(i: i32) -> Result<Self, Self::Err> {
    match i {
      0 => Ok(UserGender::Unknown),
      1 => Ok(UserGender::Male),
      2 => Ok(UserGender::Female),
      _ => {
        Err(
          thrift::Error::Protocol(
            ProtocolError::new(
              ProtocolErrorKind::InvalidData,
              format!("cannot convert enum constant {} to UserGender", i)
            )
          )
        )
      },
    }
  }
}

pub type JSON = String;

//
// TriggerKeys
//

/// @TriggerKeys_summary
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TriggerKeys {
  /// @TriggerKeys_DeviceType_desc
  pub device_type: Option<i8>,
  /// @TriggerKeys_Key_desc
  pub key: Option<i32>,
  /// @TriggerKeys_NewValue_desc
  pub new_value: Option<i8>,
  /// @TriggerKeys_OldValue_desc
  pub old_value: Option<i8>,
}

impl TriggerKeys {
  pub fn new<F1, F2, F3, F4>(device_type: F1, key: F2, new_value: F3, old_value: F4) -> TriggerKeys where F1: Into<Option<i8>>, F2: Into<Option<i32>>, F3: Into<Option<i8>>, F4: Into<Option<i8>> {
    TriggerKeys {
      device_type: device_type.into(),
      key: key.into(),
      new_value: new_value.into(),
      old_value: old_value.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<TriggerKeys> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<i8> = Some(0);
    let mut f_2: Option<i32> = Some(0);
    let mut f_3: Option<i8> = Some(0);
    let mut f_4: Option<i8> = Some(0);
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_i8()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_i32()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i8()?;
          f_3 = Some(val);
        },
        4 => {
          let val = i_prot.read_i8()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = TriggerKeys {
      device_type: f_1,
      key: f_2,
      new_value: f_3,
      old_value: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("TriggerKeys");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(fld_var) = self.device_type {
      o_prot.write_field_begin(&TFieldIdentifier::new("DeviceType", TType::I08, 1))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.key {
      o_prot.write_field_begin(&TFieldIdentifier::new("Key", TType::I32, 2))?;
      o_prot.write_i32(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.new_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("NewValue", TType::I08, 3))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.old_value {
      o_prot.write_field_begin(&TFieldIdentifier::new("OldValue", TType::I08, 4))?;
      o_prot.write_i8(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for TriggerKeys {
  fn default() -> Self {
    TriggerKeys{
      device_type: Some(0),
      key: Some(0),
      new_value: Some(0),
      old_value: Some(0),
    }
  }
}

//
// InputActionEvent
//

/// @InputActionEvent_summary
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct InputActionEvent {
  /// @InputActionEvent_deviceId_desc
  pub user_id: Option<String>,
  /// @InputActionEvent_action_desc
  pub action: Option<String>,
  /// @InputActionEvent_timestamp_desc
  pub timestamp: Option<i64>,
  /// @InputActionEvent_timestamp_desc
  pub triggers: Option<Vec<TriggerKeys>>,
}

impl InputActionEvent {
  pub fn new<F1, F2, F3, F4>(user_id: F1, action: F2, timestamp: F3, triggers: F4) -> InputActionEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<i64>>, F4: Into<Option<Vec<TriggerKeys>>> {
    InputActionEvent {
      user_id: user_id.into(),
      action: action.into(),
      timestamp: timestamp.into(),
      triggers: triggers.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<InputActionEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<i64> = Some(0);
    let mut f_4: Option<Vec<TriggerKeys>> = Some(Vec::new());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_i64()?;
          f_3 = Some(val);
        },
        4 => {
          let list_ident = i_prot.read_list_begin()?;
          let mut val: Vec<TriggerKeys> = Vec::with_capacity(list_ident.size as usize);
          for _ in 0..list_ident.size {
            let list_elem_0 = TriggerKeys::read_from_in_protocol(i_prot)?;
            val.push(list_elem_0);
          }
          i_prot.read_list_end()?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = InputActionEvent {
      user_id: f_1,
      action: f_2,
      timestamp: f_3,
      triggers: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("InputActionEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action {
      o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(fld_var) = self.timestamp {
      o_prot.write_field_begin(&TFieldIdentifier::new("timestamp", TType::I64, 3))?;
      o_prot.write_i64(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.triggers {
      o_prot.write_field_begin(&TFieldIdentifier::new("Triggers", TType::List, 4))?;
      o_prot.write_list_begin(&TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
      for e in fld_var {
        e.write_to_out_protocol(o_prot)?;
        o_prot.write_list_end()?;
      }
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for InputActionEvent {
  fn default() -> Self {
    InputActionEvent{
      user_id: Some("".to_owned()),
      action: Some("".to_owned()),
      timestamp: Some(0),
      triggers: Some(Vec::new()),
    }
  }
}

//
// UserEvent
//

/// @UserEvent_summary
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserEvent {
  /// @UserEvent_userId_desc
  pub user_id: Option<String>,
  /// @UserEvent_action_desc
  pub action: Option<String>,
  /// @UserEvent_parameters_desc
  pub json_data: Option<JSON>,
}

impl UserEvent {
  pub fn new<F1, F2, F3>(user_id: F1, action: F2, json_data: F3) -> UserEvent where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<JSON>> {
    UserEvent {
      user_id: user_id.into(),
      action: action.into(),
      json_data: json_data.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<UserEvent> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<JSON> = Some("".to_owned());
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserEvent {
      user_id: f_1,
      action: f_2,
      json_data: f_3,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserEvent");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.action {
      o_prot.write_field_begin(&TFieldIdentifier::new("action", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.json_data {
      o_prot.write_field_begin(&TFieldIdentifier::new("jsonData", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UserEvent {
  fn default() -> Self {
    UserEvent{
      user_id: Some("".to_owned()),
      action: Some("".to_owned()),
      json_data: Some("".to_owned()),
    }
  }
}

//
// UserInfoPublic
//

/// @UserInfo_Public_desc
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct UserInfoPublic {
  /// @UserInfo_Public_userId_desc
  pub user_id: Option<String>,
  /// @UserInfo_Public_nickname_desc
  pub nickname: Option<String>,
  /// @UserInfo_Public_portrait_desc
  pub portrait: Option<String>,
  /// @UserInfo_Public_gender_desc
  pub gender: Option<UserGender>,
}

impl UserInfoPublic {
  pub fn new<F1, F2, F3, F4>(user_id: F1, nickname: F2, portrait: F3, gender: F4) -> UserInfoPublic where F1: Into<Option<String>>, F2: Into<Option<String>>, F3: Into<Option<String>>, F4: Into<Option<UserGender>> {
    UserInfoPublic {
      user_id: user_id.into(),
      nickname: nickname.into(),
      portrait: portrait.into(),
      gender: gender.into(),
    }
  }
  pub fn read_from_in_protocol(i_prot: &mut TInputProtocol) -> thrift::Result<UserInfoPublic> {
    i_prot.read_struct_begin()?;
    let mut f_1: Option<String> = Some("".to_owned());
    let mut f_2: Option<String> = Some("".to_owned());
    let mut f_3: Option<String> = Some("".to_owned());
    let mut f_4: Option<UserGender> = None;
    loop {
      let field_ident = i_prot.read_field_begin()?;
      if field_ident.field_type == TType::Stop {
        break;
      }
      let field_id = field_id(&field_ident)?;
      match field_id {
        1 => {
          let val = i_prot.read_string()?;
          f_1 = Some(val);
        },
        2 => {
          let val = i_prot.read_string()?;
          f_2 = Some(val);
        },
        3 => {
          let val = i_prot.read_string()?;
          f_3 = Some(val);
        },
        4 => {
          let val = UserGender::read_from_in_protocol(i_prot)?;
          f_4 = Some(val);
        },
        _ => {
          i_prot.skip(field_ident.field_type)?;
        },
      };
      i_prot.read_field_end()?;
    }
    i_prot.read_struct_end()?;
    let ret = UserInfoPublic {
      user_id: f_1,
      nickname: f_2,
      portrait: f_3,
      gender: f_4,
    };
    Ok(ret)
  }
  pub fn write_to_out_protocol(&self, o_prot: &mut TOutputProtocol) -> thrift::Result<()> {
    let struct_ident = TStructIdentifier::new("UserInfo_Public");
    o_prot.write_struct_begin(&struct_ident)?;
    if let Some(ref fld_var) = self.user_id {
      o_prot.write_field_begin(&TFieldIdentifier::new("userId", TType::String, 1))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.nickname {
      o_prot.write_field_begin(&TFieldIdentifier::new("nickname", TType::String, 2))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.portrait {
      o_prot.write_field_begin(&TFieldIdentifier::new("portrait", TType::String, 3))?;
      o_prot.write_string(fld_var)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    if let Some(ref fld_var) = self.gender {
      o_prot.write_field_begin(&TFieldIdentifier::new("gender", TType::I32, 4))?;
      fld_var.write_to_out_protocol(o_prot)?;
      o_prot.write_field_end()?;
      ()
    } else {
      ()
    }
    o_prot.write_field_stop()?;
    o_prot.write_struct_end()
  }
}

impl Default for UserInfoPublic {
  fn default() -> Self {
    UserInfoPublic{
      user_id: Some("".to_owned()),
      nickname: Some("".to_owned()),
      portrait: Some("".to_owned()),
      gender: None,
    }
  }
}

