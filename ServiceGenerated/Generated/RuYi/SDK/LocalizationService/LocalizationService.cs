/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading.Tasks;
using Thrift;
using Thrift.Collections;
using System.Runtime.Serialization;
using Thrift.Protocol;
using Thrift.Transport;

namespace Ruyi.SDK.LocalizationService
{
  public partial class LocalizationService {
    public interface ISync {
      /// <summary>
      /// Switch language to specified one.
      /// </summary>
      /// <param name="language">Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN</param>
      /// <param name="loadAllContext">Whether or not to load all context of the language</param>
      /// <param name="removeOld">Whether or not to remove old language</param>
      bool SwitchLanguage(string language, bool loadAllContext, bool removeOld);
      /// <summary>
      /// Get currently active language
      /// </summary>
      string GetCurrentLanguage();
      /// <summary>
      /// Switch a context of the language.
      /// </summary>
      /// <param name="context">Which context to switch to.</param>
      /// <param name="language">Which language that the context belong to</param>
      bool SwitchContext(string context, string language);
      /// <summary>
      /// Get currently active context.
      /// </summary>
      string HintContext();
      /// <summary>
      /// Get a localization string.
      /// Return: localization string.
      /// </summary>
      /// <param name="key">The key of the string</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      string GetString(string key, string context, string language);
      /// <summary>
      /// Get a set of localization string.
      /// </summary>
      /// <param name="filter">A regular expresion used to filter the strings</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      Dictionary<string, string> GetStrings(string filter, string context, string language);
      /// <summary>
      /// Get the file name/path in the language.
      /// 
      /// The search will go through the context and its sub context to find the file name. Eg. If file name is not found in context com.ruyi, then the search will go on to find it in com.ruyi.moduleA and com.ruyi.moduleB.
      /// </summary>
      /// <param name="filename">File name with the path to the language pack root.</param>
      /// <param name="isVirtualPath">True to get the virtual path, false to get the exact path to the file.</param>
      /// <param name="context">The context of the file. If null, then while use system context "com.ruyi"</param>
      string GetFileName(string filename, bool isVirtualPath, string context);
    }

    public interface IAsync {
      /// <summary>
      /// Switch language to specified one.
      /// </summary>
      /// <param name="language">Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN</param>
      /// <param name="loadAllContext">Whether or not to load all context of the language</param>
      /// <param name="removeOld">Whether or not to remove old language</param>
      Task<bool> SwitchLanguageAsync(string language, bool loadAllContext, bool removeOld);
      /// <summary>
      /// Get currently active language
      /// </summary>
      Task<string> GetCurrentLanguageAsync();
      /// <summary>
      /// Switch a context of the language.
      /// </summary>
      /// <param name="context">Which context to switch to.</param>
      /// <param name="language">Which language that the context belong to</param>
      Task<bool> SwitchContextAsync(string context, string language);
      /// <summary>
      /// Get currently active context.
      /// </summary>
      Task<string> HintContextAsync();
      /// <summary>
      /// Get a localization string.
      /// Return: localization string.
      /// </summary>
      /// <param name="key">The key of the string</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      Task<string> GetStringAsync(string key, string context, string language);
      /// <summary>
      /// Get a set of localization string.
      /// </summary>
      /// <param name="filter">A regular expresion used to filter the strings</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      Task<Dictionary<string, string>> GetStringsAsync(string filter, string context, string language);
      /// <summary>
      /// Get the file name/path in the language.
      /// 
      /// The search will go through the context and its sub context to find the file name. Eg. If file name is not found in context com.ruyi, then the search will go on to find it in com.ruyi.moduleA and com.ruyi.moduleB.
      /// </summary>
      /// <param name="filename">File name with the path to the language pack root.</param>
      /// <param name="isVirtualPath">True to get the virtual path, false to get the exact path to the file.</param>
      /// <param name="context">The context of the file. If null, then while use system context "com.ruyi"</param>
      Task<string> GetFileNameAsync(string filename, bool isVirtualPath, string context);
    }

    public interface Iface : ISync, IAsync {
      /// <summary>
      /// Switch language to specified one.
      /// </summary>
      /// <param name="language">Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN</param>
      /// <param name="loadAllContext">Whether or not to load all context of the language</param>
      /// <param name="removeOld">Whether or not to remove old language</param>
      IAsyncResult Begin_SwitchLanguage(AsyncCallback callback, object state, string language, bool loadAllContext, bool removeOld);
      bool End_SwitchLanguage(IAsyncResult asyncResult);
      /// <summary>
      /// Get currently active language
      /// </summary>
      IAsyncResult Begin_GetCurrentLanguage(AsyncCallback callback, object state);
      string End_GetCurrentLanguage(IAsyncResult asyncResult);
      /// <summary>
      /// Switch a context of the language.
      /// </summary>
      /// <param name="context">Which context to switch to.</param>
      /// <param name="language">Which language that the context belong to</param>
      IAsyncResult Begin_SwitchContext(AsyncCallback callback, object state, string context, string language);
      bool End_SwitchContext(IAsyncResult asyncResult);
      /// <summary>
      /// Get currently active context.
      /// </summary>
      IAsyncResult Begin_HintContext(AsyncCallback callback, object state);
      string End_HintContext(IAsyncResult asyncResult);
      /// <summary>
      /// Get a localization string.
      /// Return: localization string.
      /// </summary>
      /// <param name="key">The key of the string</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      IAsyncResult Begin_GetString(AsyncCallback callback, object state, string key, string context, string language);
      string End_GetString(IAsyncResult asyncResult);
      /// <summary>
      /// Get a set of localization string.
      /// </summary>
      /// <param name="filter">A regular expresion used to filter the strings</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      IAsyncResult Begin_GetStrings(AsyncCallback callback, object state, string filter, string context, string language);
      Dictionary<string, string> End_GetStrings(IAsyncResult asyncResult);
      /// <summary>
      /// Get the file name/path in the language.
      /// 
      /// The search will go through the context and its sub context to find the file name. Eg. If file name is not found in context com.ruyi, then the search will go on to find it in com.ruyi.moduleA and com.ruyi.moduleB.
      /// </summary>
      /// <param name="filename">File name with the path to the language pack root.</param>
      /// <param name="isVirtualPath">True to get the virtual path, false to get the exact path to the file.</param>
      /// <param name="context">The context of the file. If null, then while use system context "com.ruyi"</param>
      IAsyncResult Begin_GetFileName(AsyncCallback callback, object state, string filename, bool isVirtualPath, string context);
      string End_GetFileName(IAsyncResult asyncResult);
    }

    public class Client : IDisposable, Iface {
      public Client(TProtocol prot) : this(prot, prot)
      {
      }

      public Client(TProtocol iprot, TProtocol oprot)
      {
        iprot_ = iprot;
        oprot_ = oprot;
      }

      protected TProtocol iprot_;
      protected TProtocol oprot_;
      protected int seqid_;

      public TProtocol InputProtocol
      {
        get { return iprot_; }
      }
      public TProtocol OutputProtocol
      {
        get { return oprot_; }
      }


      #region " IDisposable Support "
      private bool _IsDisposed;

      // IDisposable
      public void Dispose()
      {
        Dispose(true);
      }
      

      protected virtual void Dispose(bool disposing)
      {
        if (!_IsDisposed)
        {
          if (disposing)
          {
            if (iprot_ != null)
            {
              ((IDisposable)iprot_).Dispose();
            }
            if (oprot_ != null)
            {
              ((IDisposable)oprot_).Dispose();
            }
          }
        }
        _IsDisposed = true;
      }
      #endregion


      
      public IAsyncResult Begin_SwitchLanguage(AsyncCallback callback, object state, string language, bool loadAllContext, bool removeOld)
      {
        return send_SwitchLanguage(callback, state, language, loadAllContext, removeOld);
      }

      public bool End_SwitchLanguage(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_SwitchLanguage();
      }

      public async Task<bool> SwitchLanguageAsync(string language, bool loadAllContext, bool removeOld)
      {
        bool retval;
        retval = await Task.Run(() =>
        {
          return SwitchLanguage(language, loadAllContext, removeOld);
        });
        return retval;
      }

      /// <summary>
      /// Switch language to specified one.
      /// </summary>
      /// <param name="language">Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN</param>
      /// <param name="loadAllContext">Whether or not to load all context of the language</param>
      /// <param name="removeOld">Whether or not to remove old language</param>
      public bool SwitchLanguage(string language, bool loadAllContext, bool removeOld)
      {
        var asyncResult = Begin_SwitchLanguage(null, null, language, loadAllContext, removeOld);
        return End_SwitchLanguage(asyncResult);

      }
      public IAsyncResult send_SwitchLanguage(AsyncCallback callback, object state, string language, bool loadAllContext, bool removeOld)
      {
        oprot_.WriteMessageBegin(new TMessage("SwitchLanguage", TMessageType.Call, seqid_));
        SwitchLanguage_args args = new SwitchLanguage_args();
        args.Language = language;
        args.LoadAllContext = loadAllContext;
        args.RemoveOld = removeOld;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public bool recv_SwitchLanguage()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        SwitchLanguage_result result = new SwitchLanguage_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "SwitchLanguage failed: unknown result");
      }

      
      public IAsyncResult Begin_GetCurrentLanguage(AsyncCallback callback, object state)
      {
        return send_GetCurrentLanguage(callback, state);
      }

      public string End_GetCurrentLanguage(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_GetCurrentLanguage();
      }

      public async Task<string> GetCurrentLanguageAsync()
      {
        string retval;
        retval = await Task.Run(() =>
        {
          return GetCurrentLanguage();
        });
        return retval;
      }

      /// <summary>
      /// Get currently active language
      /// </summary>
      public string GetCurrentLanguage()
      {
        var asyncResult = Begin_GetCurrentLanguage(null, null);
        return End_GetCurrentLanguage(asyncResult);

      }
      public IAsyncResult send_GetCurrentLanguage(AsyncCallback callback, object state)
      {
        oprot_.WriteMessageBegin(new TMessage("GetCurrentLanguage", TMessageType.Call, seqid_));
        GetCurrentLanguage_args args = new GetCurrentLanguage_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public string recv_GetCurrentLanguage()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        GetCurrentLanguage_result result = new GetCurrentLanguage_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "GetCurrentLanguage failed: unknown result");
      }

      
      public IAsyncResult Begin_SwitchContext(AsyncCallback callback, object state, string context, string language)
      {
        return send_SwitchContext(callback, state, context, language);
      }

      public bool End_SwitchContext(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_SwitchContext();
      }

      public async Task<bool> SwitchContextAsync(string context, string language)
      {
        bool retval;
        retval = await Task.Run(() =>
        {
          return SwitchContext(context, language);
        });
        return retval;
      }

      /// <summary>
      /// Switch a context of the language.
      /// </summary>
      /// <param name="context">Which context to switch to.</param>
      /// <param name="language">Which language that the context belong to</param>
      public bool SwitchContext(string context, string language)
      {
        var asyncResult = Begin_SwitchContext(null, null, context, language);
        return End_SwitchContext(asyncResult);

      }
      public IAsyncResult send_SwitchContext(AsyncCallback callback, object state, string context, string language)
      {
        oprot_.WriteMessageBegin(new TMessage("SwitchContext", TMessageType.Call, seqid_));
        SwitchContext_args args = new SwitchContext_args();
        args.Context = context;
        args.Language = language;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public bool recv_SwitchContext()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        SwitchContext_result result = new SwitchContext_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "SwitchContext failed: unknown result");
      }

      
      public IAsyncResult Begin_HintContext(AsyncCallback callback, object state)
      {
        return send_HintContext(callback, state);
      }

      public string End_HintContext(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_HintContext();
      }

      public async Task<string> HintContextAsync()
      {
        string retval;
        retval = await Task.Run(() =>
        {
          return HintContext();
        });
        return retval;
      }

      /// <summary>
      /// Get currently active context.
      /// </summary>
      public string HintContext()
      {
        var asyncResult = Begin_HintContext(null, null);
        return End_HintContext(asyncResult);

      }
      public IAsyncResult send_HintContext(AsyncCallback callback, object state)
      {
        oprot_.WriteMessageBegin(new TMessage("HintContext", TMessageType.Call, seqid_));
        HintContext_args args = new HintContext_args();
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public string recv_HintContext()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        HintContext_result result = new HintContext_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "HintContext failed: unknown result");
      }

      
      public IAsyncResult Begin_GetString(AsyncCallback callback, object state, string key, string context, string language)
      {
        return send_GetString(callback, state, key, context, language);
      }

      public string End_GetString(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_GetString();
      }

      public async Task<string> GetStringAsync(string key, string context, string language)
      {
        string retval;
        retval = await Task.Run(() =>
        {
          return GetString(key, context, language);
        });
        return retval;
      }

      /// <summary>
      /// Get a localization string.
      /// Return: localization string.
      /// </summary>
      /// <param name="key">The key of the string</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      public string GetString(string key, string context, string language)
      {
        var asyncResult = Begin_GetString(null, null, key, context, language);
        return End_GetString(asyncResult);

      }
      public IAsyncResult send_GetString(AsyncCallback callback, object state, string key, string context, string language)
      {
        oprot_.WriteMessageBegin(new TMessage("GetString", TMessageType.Call, seqid_));
        GetString_args args = new GetString_args();
        args.Key = key;
        args.Context = context;
        args.Language = language;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public string recv_GetString()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        GetString_result result = new GetString_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "GetString failed: unknown result");
      }

      
      public IAsyncResult Begin_GetStrings(AsyncCallback callback, object state, string filter, string context, string language)
      {
        return send_GetStrings(callback, state, filter, context, language);
      }

      public Dictionary<string, string> End_GetStrings(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_GetStrings();
      }

      public async Task<Dictionary<string, string>> GetStringsAsync(string filter, string context, string language)
      {
        Dictionary<string, string> retval;
        retval = await Task.Run(() =>
        {
          return GetStrings(filter, context, language);
        });
        return retval;
      }

      /// <summary>
      /// Get a set of localization string.
      /// </summary>
      /// <param name="filter">A regular expresion used to filter the strings</param>
      /// <param name="context">The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.</param>
      /// <param name="language">The language to search</param>
      public Dictionary<string, string> GetStrings(string filter, string context, string language)
      {
        var asyncResult = Begin_GetStrings(null, null, filter, context, language);
        return End_GetStrings(asyncResult);

      }
      public IAsyncResult send_GetStrings(AsyncCallback callback, object state, string filter, string context, string language)
      {
        oprot_.WriteMessageBegin(new TMessage("GetStrings", TMessageType.Call, seqid_));
        GetStrings_args args = new GetStrings_args();
        args.Filter = filter;
        args.Context = context;
        args.Language = language;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public Dictionary<string, string> recv_GetStrings()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        GetStrings_result result = new GetStrings_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "GetStrings failed: unknown result");
      }

      
      public IAsyncResult Begin_GetFileName(AsyncCallback callback, object state, string filename, bool isVirtualPath, string context)
      {
        return send_GetFileName(callback, state, filename, isVirtualPath, context);
      }

      public string End_GetFileName(IAsyncResult asyncResult)
      {
        oprot_.Transport.EndFlush(asyncResult);
        return recv_GetFileName();
      }

      public async Task<string> GetFileNameAsync(string filename, bool isVirtualPath, string context)
      {
        string retval;
        retval = await Task.Run(() =>
        {
          return GetFileName(filename, isVirtualPath, context);
        });
        return retval;
      }

      /// <summary>
      /// Get the file name/path in the language.
      /// 
      /// The search will go through the context and its sub context to find the file name. Eg. If file name is not found in context com.ruyi, then the search will go on to find it in com.ruyi.moduleA and com.ruyi.moduleB.
      /// </summary>
      /// <param name="filename">File name with the path to the language pack root.</param>
      /// <param name="isVirtualPath">True to get the virtual path, false to get the exact path to the file.</param>
      /// <param name="context">The context of the file. If null, then while use system context "com.ruyi"</param>
      public string GetFileName(string filename, bool isVirtualPath, string context)
      {
        var asyncResult = Begin_GetFileName(null, null, filename, isVirtualPath, context);
        return End_GetFileName(asyncResult);

      }
      public IAsyncResult send_GetFileName(AsyncCallback callback, object state, string filename, bool isVirtualPath, string context)
      {
        oprot_.WriteMessageBegin(new TMessage("GetFileName", TMessageType.Call, seqid_));
        GetFileName_args args = new GetFileName_args();
        args.Filename = filename;
        args.IsVirtualPath = isVirtualPath;
        args.Context = context;
        args.Write(oprot_);
        oprot_.WriteMessageEnd();
        return oprot_.Transport.BeginFlush(callback, state);
      }

      public string recv_GetFileName()
      {
        TMessage msg = iprot_.ReadMessageBegin();
        if (msg.Type == TMessageType.Exception) {
          TApplicationException x = TApplicationException.Read(iprot_);
          iprot_.ReadMessageEnd();
          throw x;
        }
        GetFileName_result result = new GetFileName_result();
        result.Read(iprot_);
        iprot_.ReadMessageEnd();
        if (result.__isset.success) {
          return result.Success;
        }
        throw new TApplicationException(TApplicationException.ExceptionType.MissingResult, "GetFileName failed: unknown result");
      }

    }
    public class AsyncProcessor : TAsyncProcessor {
      public AsyncProcessor(IAsync iface)
      {
        iface_ = iface;
        processMap_["SwitchLanguage"] = SwitchLanguage_ProcessAsync;
        processMap_["GetCurrentLanguage"] = GetCurrentLanguage_ProcessAsync;
        processMap_["SwitchContext"] = SwitchContext_ProcessAsync;
        processMap_["HintContext"] = HintContext_ProcessAsync;
        processMap_["GetString"] = GetString_ProcessAsync;
        processMap_["GetStrings"] = GetStrings_ProcessAsync;
        processMap_["GetFileName"] = GetFileName_ProcessAsync;
      }

      protected delegate Task ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private IAsync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public async Task<bool> ProcessAsync(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          await fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public async Task SwitchLanguage_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        SwitchLanguage_args args = new SwitchLanguage_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        SwitchLanguage_result result = new SwitchLanguage_result();
        try
        {
          result.Success = await iface_.SwitchLanguageAsync(args.Language, args.LoadAllContext, args.RemoveOld);
          oprot.WriteMessageBegin(new TMessage("SwitchLanguage", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("SwitchLanguage", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public async Task GetCurrentLanguage_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetCurrentLanguage_args args = new GetCurrentLanguage_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetCurrentLanguage_result result = new GetCurrentLanguage_result();
        try
        {
          result.Success = await iface_.GetCurrentLanguageAsync();
          oprot.WriteMessageBegin(new TMessage("GetCurrentLanguage", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetCurrentLanguage", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public async Task SwitchContext_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        SwitchContext_args args = new SwitchContext_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        SwitchContext_result result = new SwitchContext_result();
        try
        {
          result.Success = await iface_.SwitchContextAsync(args.Context, args.Language);
          oprot.WriteMessageBegin(new TMessage("SwitchContext", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("SwitchContext", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public async Task HintContext_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        HintContext_args args = new HintContext_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        HintContext_result result = new HintContext_result();
        try
        {
          result.Success = await iface_.HintContextAsync();
          oprot.WriteMessageBegin(new TMessage("HintContext", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("HintContext", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public async Task GetString_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetString_args args = new GetString_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetString_result result = new GetString_result();
        try
        {
          result.Success = await iface_.GetStringAsync(args.Key, args.Context, args.Language);
          oprot.WriteMessageBegin(new TMessage("GetString", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetString", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public async Task GetStrings_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetStrings_args args = new GetStrings_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetStrings_result result = new GetStrings_result();
        try
        {
          result.Success = await iface_.GetStringsAsync(args.Filter, args.Context, args.Language);
          oprot.WriteMessageBegin(new TMessage("GetStrings", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetStrings", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public async Task GetFileName_ProcessAsync(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetFileName_args args = new GetFileName_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetFileName_result result = new GetFileName_result();
        try
        {
          result.Success = await iface_.GetFileNameAsync(args.Filename, args.IsVirtualPath, args.Context);
          oprot.WriteMessageBegin(new TMessage("GetFileName", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetFileName", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }

    public class Processor : TProcessor {
      public Processor(ISync iface)
      {
        iface_ = iface;
        processMap_["SwitchLanguage"] = SwitchLanguage_Process;
        processMap_["GetCurrentLanguage"] = GetCurrentLanguage_Process;
        processMap_["SwitchContext"] = SwitchContext_Process;
        processMap_["HintContext"] = HintContext_Process;
        processMap_["GetString"] = GetString_Process;
        processMap_["GetStrings"] = GetStrings_Process;
        processMap_["GetFileName"] = GetFileName_Process;
      }

      protected delegate void ProcessFunction(int seqid, TProtocol iprot, TProtocol oprot);
      private ISync iface_;
      protected Dictionary<string, ProcessFunction> processMap_ = new Dictionary<string, ProcessFunction>();

      public bool Process(TProtocol iprot, TProtocol oprot)
      {
        try
        {
          TMessage msg = iprot.ReadMessageBegin();
          ProcessFunction fn;
          processMap_.TryGetValue(msg.Name, out fn);
          if (fn == null) {
            TProtocolUtil.Skip(iprot, TType.Struct);
            iprot.ReadMessageEnd();
            TApplicationException x = new TApplicationException (TApplicationException.ExceptionType.UnknownMethod, "Invalid method name: '" + msg.Name + "'");
            oprot.WriteMessageBegin(new TMessage(msg.Name, TMessageType.Exception, msg.SeqID));
            x.Write(oprot);
            oprot.WriteMessageEnd();
            oprot.Transport.Flush();
            return true;
          }
          fn(msg.SeqID, iprot, oprot);
        }
        catch (IOException)
        {
          return false;
        }
        return true;
      }

      public void SwitchLanguage_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        SwitchLanguage_args args = new SwitchLanguage_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        SwitchLanguage_result result = new SwitchLanguage_result();
        try
        {
          result.Success = iface_.SwitchLanguage(args.Language, args.LoadAllContext, args.RemoveOld);
          oprot.WriteMessageBegin(new TMessage("SwitchLanguage", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("SwitchLanguage", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void GetCurrentLanguage_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetCurrentLanguage_args args = new GetCurrentLanguage_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetCurrentLanguage_result result = new GetCurrentLanguage_result();
        try
        {
          result.Success = iface_.GetCurrentLanguage();
          oprot.WriteMessageBegin(new TMessage("GetCurrentLanguage", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetCurrentLanguage", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void SwitchContext_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        SwitchContext_args args = new SwitchContext_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        SwitchContext_result result = new SwitchContext_result();
        try
        {
          result.Success = iface_.SwitchContext(args.Context, args.Language);
          oprot.WriteMessageBegin(new TMessage("SwitchContext", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("SwitchContext", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void HintContext_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        HintContext_args args = new HintContext_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        HintContext_result result = new HintContext_result();
        try
        {
          result.Success = iface_.HintContext();
          oprot.WriteMessageBegin(new TMessage("HintContext", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("HintContext", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void GetString_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetString_args args = new GetString_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetString_result result = new GetString_result();
        try
        {
          result.Success = iface_.GetString(args.Key, args.Context, args.Language);
          oprot.WriteMessageBegin(new TMessage("GetString", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetString", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void GetStrings_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetStrings_args args = new GetStrings_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetStrings_result result = new GetStrings_result();
        try
        {
          result.Success = iface_.GetStrings(args.Filter, args.Context, args.Language);
          oprot.WriteMessageBegin(new TMessage("GetStrings", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetStrings", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

      public void GetFileName_Process(int seqid, TProtocol iprot, TProtocol oprot)
      {
        GetFileName_args args = new GetFileName_args();
        args.Read(iprot);
        iprot.ReadMessageEnd();
        GetFileName_result result = new GetFileName_result();
        try
        {
          result.Success = iface_.GetFileName(args.Filename, args.IsVirtualPath, args.Context);
          oprot.WriteMessageBegin(new TMessage("GetFileName", TMessageType.Reply, seqid)); 
          result.Write(oprot);
        }
        catch (TTransportException)
        {
          throw;
        }
        catch (Exception ex)
        {
          Console.Error.WriteLine("Error occurred in processor:");
          Console.Error.WriteLine(ex.ToString());
          TApplicationException x = new TApplicationException        (TApplicationException.ExceptionType.InternalError," Internal error.");
          oprot.WriteMessageBegin(new TMessage("GetFileName", TMessageType.Exception, seqid));
          x.Write(oprot);
        }
        oprot.WriteMessageEnd();
        oprot.Transport.Flush();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class SwitchLanguage_args : TBase
    {
      private string _language;
      private bool _loadAllContext;
      private bool _removeOld;

      /// <summary>
      /// Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN
      /// </summary>
      public string Language
      {
        get
        {
          return _language;
        }
        set
        {
          __isset.language = true;
          this._language = value;
        }
      }

      /// <summary>
      /// Whether or not to load all context of the language
      /// </summary>
      public bool LoadAllContext
      {
        get
        {
          return _loadAllContext;
        }
        set
        {
          __isset.loadAllContext = true;
          this._loadAllContext = value;
        }
      }

      /// <summary>
      /// Whether or not to remove old language
      /// </summary>
      public bool RemoveOld
      {
        get
        {
          return _removeOld;
        }
        set
        {
          __isset.removeOld = true;
          this._removeOld = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool language;
        public bool loadAllContext;
        public bool removeOld;
      }

      public SwitchLanguage_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Language = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Bool) {
                  LoadAllContext = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.Bool) {
                  RemoveOld = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("SwitchLanguage_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Language != null && __isset.language) {
            field.Name = "language";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Language);
            oprot.WriteFieldEnd();
          }
          if (__isset.loadAllContext) {
            field.Name = "loadAllContext";
            field.Type = TType.Bool;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(LoadAllContext);
            oprot.WriteFieldEnd();
          }
          if (__isset.removeOld) {
            field.Name = "removeOld";
            field.Type = TType.Bool;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(RemoveOld);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("SwitchLanguage_args(");
        bool __first = true;
        if (Language != null && __isset.language) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Language: ");
          __sb.Append(Language);
        }
        if (__isset.loadAllContext) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("LoadAllContext: ");
          __sb.Append(LoadAllContext);
        }
        if (__isset.removeOld) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("RemoveOld: ");
          __sb.Append(RemoveOld);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class SwitchLanguage_result : TBase
    {
      private bool _success;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public SwitchLanguage_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("SwitchLanguage_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("SwitchLanguage_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetCurrentLanguage_args : TBase
    {

      public GetCurrentLanguage_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetCurrentLanguage_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetCurrentLanguage_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetCurrentLanguage_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public GetCurrentLanguage_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetCurrentLanguage_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetCurrentLanguage_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class SwitchContext_args : TBase
    {
      private string _context;
      private string _language;

      /// <summary>
      /// Which context to switch to.
      /// </summary>
      public string Context
      {
        get
        {
          return _context;
        }
        set
        {
          __isset.context = true;
          this._context = value;
        }
      }

      /// <summary>
      /// Which language that the context belong to
      /// </summary>
      public string Language
      {
        get
        {
          return _language;
        }
        set
        {
          __isset.language = true;
          this._language = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool context;
        public bool language;
      }

      public SwitchContext_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Context = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Language = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("SwitchContext_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Context != null && __isset.context) {
            field.Name = "context";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Context);
            oprot.WriteFieldEnd();
          }
          if (Language != null && __isset.language) {
            field.Name = "language";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Language);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("SwitchContext_args(");
        bool __first = true;
        if (Context != null && __isset.context) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Context: ");
          __sb.Append(Context);
        }
        if (Language != null && __isset.language) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Language: ");
          __sb.Append(Language);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class SwitchContext_result : TBase
    {
      private bool _success;

      public bool Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public SwitchContext_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Bool) {
                  Success = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("SwitchContext_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            field.Name = "Success";
            field.Type = TType.Bool;
            field.ID = 0;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(Success);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("SwitchContext_result(");
        bool __first = true;
        if (__isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class HintContext_args : TBase
    {

      public HintContext_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("HintContext_args");
          oprot.WriteStructBegin(struc);
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("HintContext_args(");
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class HintContext_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public HintContext_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("HintContext_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("HintContext_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetString_args : TBase
    {
      private string _key;
      private string _context;
      private string _language;

      /// <summary>
      /// The key of the string
      /// </summary>
      public string Key
      {
        get
        {
          return _key;
        }
        set
        {
          __isset.key = true;
          this._key = value;
        }
      }

      /// <summary>
      /// The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.
      /// </summary>
      public string Context
      {
        get
        {
          return _context;
        }
        set
        {
          __isset.context = true;
          this._context = value;
        }
      }

      /// <summary>
      /// The language to search
      /// </summary>
      public string Language
      {
        get
        {
          return _language;
        }
        set
        {
          __isset.language = true;
          this._language = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool key;
        public bool context;
        public bool language;
      }

      public GetString_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Key = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Context = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Language = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetString_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Key != null && __isset.key) {
            field.Name = "key";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Key);
            oprot.WriteFieldEnd();
          }
          if (Context != null && __isset.context) {
            field.Name = "context";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Context);
            oprot.WriteFieldEnd();
          }
          if (Language != null && __isset.language) {
            field.Name = "language";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Language);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetString_args(");
        bool __first = true;
        if (Key != null && __isset.key) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Key: ");
          __sb.Append(Key);
        }
        if (Context != null && __isset.context) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Context: ");
          __sb.Append(Context);
        }
        if (Language != null && __isset.language) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Language: ");
          __sb.Append(Language);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetString_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public GetString_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetString_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetString_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetStrings_args : TBase
    {
      private string _filter;
      private string _context;
      private string _language;

      /// <summary>
      /// A regular expresion used to filter the strings
      /// </summary>
      public string Filter
      {
        get
        {
          return _filter;
        }
        set
        {
          __isset.filter = true;
          this._filter = value;
        }
      }

      /// <summary>
      /// The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.
      /// </summary>
      public string Context
      {
        get
        {
          return _context;
        }
        set
        {
          __isset.context = true;
          this._context = value;
        }
      }

      /// <summary>
      /// The language to search
      /// </summary>
      public string Language
      {
        get
        {
          return _language;
        }
        set
        {
          __isset.language = true;
          this._language = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool filter;
        public bool context;
        public bool language;
      }

      public GetStrings_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Filter = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.String) {
                  Context = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Language = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetStrings_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Filter != null && __isset.filter) {
            field.Name = "filter";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Filter);
            oprot.WriteFieldEnd();
          }
          if (Context != null && __isset.context) {
            field.Name = "context";
            field.Type = TType.String;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Context);
            oprot.WriteFieldEnd();
          }
          if (Language != null && __isset.language) {
            field.Name = "language";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Language);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetStrings_args(");
        bool __first = true;
        if (Filter != null && __isset.filter) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Filter: ");
          __sb.Append(Filter);
        }
        if (Context != null && __isset.context) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Context: ");
          __sb.Append(Context);
        }
        if (Language != null && __isset.language) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Language: ");
          __sb.Append(Language);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetStrings_result : TBase
    {
      private Dictionary<string, string> _success;

      public Dictionary<string, string> Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public GetStrings_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.Map) {
                  {
                    Success = new Dictionary<string, string>();
                    TMap _map0 = iprot.ReadMapBegin();
                    for( int _i1 = 0; _i1 < _map0.Count; ++_i1)
                    {
                      string _key2;
                      string _val3;
                      _key2 = iprot.ReadString();
                      _val3 = iprot.ReadString();
                      Success[_key2] = _val3;
                    }
                    iprot.ReadMapEnd();
                  }
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetStrings_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.Map;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              {
                oprot.WriteMapBegin(new TMap(TType.String, TType.String, Success.Count));
                foreach (string _iter4 in Success.Keys)
                {
                  oprot.WriteString(_iter4);
                  oprot.WriteString(Success[_iter4]);
                }
                oprot.WriteMapEnd();
              }
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetStrings_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetFileName_args : TBase
    {
      private string _filename;
      private bool _isVirtualPath;
      private string _context;

      /// <summary>
      /// File name with the path to the language pack root.
      /// </summary>
      public string Filename
      {
        get
        {
          return _filename;
        }
        set
        {
          __isset.filename = true;
          this._filename = value;
        }
      }

      /// <summary>
      /// True to get the virtual path, false to get the exact path to the file.
      /// </summary>
      public bool IsVirtualPath
      {
        get
        {
          return _isVirtualPath;
        }
        set
        {
          __isset.isVirtualPath = true;
          this._isVirtualPath = value;
        }
      }

      /// <summary>
      /// The context of the file. If null, then while use system context "com.ruyi"
      /// </summary>
      public string Context
      {
        get
        {
          return _context;
        }
        set
        {
          __isset.context = true;
          this._context = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool filename;
        public bool isVirtualPath;
        public bool context;
      }

      public GetFileName_args() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 1:
                if (field.Type == TType.String) {
                  Filename = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 2:
                if (field.Type == TType.Bool) {
                  IsVirtualPath = iprot.ReadBool();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              case 3:
                if (field.Type == TType.String) {
                  Context = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetFileName_args");
          oprot.WriteStructBegin(struc);
          TField field = new TField();
          if (Filename != null && __isset.filename) {
            field.Name = "filename";
            field.Type = TType.String;
            field.ID = 1;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Filename);
            oprot.WriteFieldEnd();
          }
          if (__isset.isVirtualPath) {
            field.Name = "isVirtualPath";
            field.Type = TType.Bool;
            field.ID = 2;
            oprot.WriteFieldBegin(field);
            oprot.WriteBool(IsVirtualPath);
            oprot.WriteFieldEnd();
          }
          if (Context != null && __isset.context) {
            field.Name = "context";
            field.Type = TType.String;
            field.ID = 3;
            oprot.WriteFieldBegin(field);
            oprot.WriteString(Context);
            oprot.WriteFieldEnd();
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetFileName_args(");
        bool __first = true;
        if (Filename != null && __isset.filename) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Filename: ");
          __sb.Append(Filename);
        }
        if (__isset.isVirtualPath) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("IsVirtualPath: ");
          __sb.Append(IsVirtualPath);
        }
        if (Context != null && __isset.context) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Context: ");
          __sb.Append(Context);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }


    #if !SILVERLIGHT
    [Serializable]
    #endif
    public partial class GetFileName_result : TBase
    {
      private string _success;

      public string Success
      {
        get
        {
          return _success;
        }
        set
        {
          __isset.success = true;
          this._success = value;
        }
      }


      public Isset __isset;
      #if !SILVERLIGHT
      [Serializable]
      #endif
      public struct Isset {
        public bool success;
      }

      public GetFileName_result() {
      }

      public void Read (TProtocol iprot)
      {
        iprot.IncrementRecursionDepth();
        try
        {
          TField field;
          iprot.ReadStructBegin();
          while (true)
          {
            field = iprot.ReadFieldBegin();
            if (field.Type == TType.Stop) { 
              break;
            }
            switch (field.ID)
            {
              case 0:
                if (field.Type == TType.String) {
                  Success = iprot.ReadString();
                } else { 
                  TProtocolUtil.Skip(iprot, field.Type);
                }
                break;
              default: 
                TProtocolUtil.Skip(iprot, field.Type);
                break;
            }
            iprot.ReadFieldEnd();
          }
          iprot.ReadStructEnd();
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
      }

      public void Write(TProtocol oprot) {
        oprot.IncrementRecursionDepth();
        try
        {
          TStruct struc = new TStruct("GetFileName_result");
          oprot.WriteStructBegin(struc);
          TField field = new TField();

          if (this.__isset.success) {
            if (Success != null) {
              field.Name = "Success";
              field.Type = TType.String;
              field.ID = 0;
              oprot.WriteFieldBegin(field);
              oprot.WriteString(Success);
              oprot.WriteFieldEnd();
            }
          }
          oprot.WriteFieldStop();
          oprot.WriteStructEnd();
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
      }

      public override string ToString() {
        StringBuilder __sb = new StringBuilder("GetFileName_result(");
        bool __first = true;
        if (Success != null && __isset.success) {
          if(!__first) { __sb.Append(", "); }
          __first = false;
          __sb.Append("Success: ");
          __sb.Append(Success);
        }
        __sb.Append(")");
        return __sb.ToString();
      }

    }

  }
}
