// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "BrainCloudService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace  ::Ruyi::SDK::BrainCloudApi;

class BrainCloudServiceHandler : virtual public BrainCloudServiceIf {
 public:
  BrainCloudServiceHandler() {
    // Your initialization goes here
  }

  /**
   * Creates an instance of an asynchronous match.
   * 
   * @param jsonOpponentIds JSON string identifying the opponent platform and id for this match.
   * 
   * Platforms are identified as:
   * BC - a brainCloud profile id
   * FB - a Facebook id
   * 
   * An exmaple of this string would be:
   * [
   *     {
   *         "platform": "BC",
   *         "id": "some-braincloud-profile"
   *     },
   *     {
   *         "platform": "FB",
   *         "id": "some-facebook-id"
   *     }
   * ]
   * 
   * @param pushNotificationMessage Optional push notification message to send to the other party.
   * Refer to the Push Notification functions for the syntax required.
   * 
   * @param clientIndex
   */
  void AsyncMatch_CreateMatch(std::string& _return, const std::string& jsonOpponentIds, const std::string& pushNotificationMessage, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_CreateMatch\n");
  }

  /**
   * Creates an instance of an asynchronous match with an initial turn.
   * 
   * @param jsonOpponentIds JSON string identifying the opponent platform and id for this match.
   * 
   * Platforms are identified as:
   * BC - a brainCloud profile id
   * FB - a Facebook id
   * 
   * An exmaple of this string would be:
   * [
   *     {
   *         "platform": "BC",
   *         "id": "some-braincloud-profile"
   *     },
   *     {
   *         "platform": "FB",
   *         "id": "some-facebook-id"
   *     }
   * ]
   * 
   * @param jsonMatchState JSON string blob provided by the caller
   * 
   * @param pushNotificationMessage Optional push notification message to send to the other party.
   * Refer to the Push Notification functions for the syntax required.
   * 
   * @param nextPlayer Optionally, force the next player player to be a specific player
   * 
   * @param jsonSummary Optional JSON string defining what the other player will see as a summary of the game when listing their games
   * 
   * @param clientIndex
   */
  void AsyncMatch_CreateMatchWithInitialTurn(std::string& _return, const std::string& jsonOpponentIds, const std::string& jsonMatchState, const std::string& pushNotificationMessage, const std::string& nextPlayer, const std::string& jsonSummary, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_CreateMatchWithInitialTurn\n");
  }

  /**
   * Submits a turn for the given match.
   * 
   * @param ownerId Match owner identfier
   * 
   * @param matchId Match identifier
   * 
   * @param version Game state version to ensure turns are submitted once and in order
   * 
   * @param jsonMatchState JSON string blob provided by the caller
   * 
   * @param pushNotificationMessage Optional push notification message to send to the other party.
   * Refer to the Push Notification functions for the syntax required.
   * 
   * @param nextPlayer Optionally, force the next player player to be a specific player
   * 
   * @param jsonSummary Optional JSON string that other players will see as a summary of the game when listing their games
   * 
   * @param jsonStatistics Optional JSON string blob provided by the caller
   * 
   * @param clientIndex
   */
  void AsyncMatch_SubmitTurn(std::string& _return, const std::string& ownerId, const std::string& matchId, const int64_t version, const std::string& jsonMatchState, const std::string& pushNotificationMessage, const std::string& nextPlayer, const std::string& jsonSummary, const std::string& jsonStatistics, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_SubmitTurn\n");
  }

  /**
   * Allows the current player (only) to update Summary data without having to submit a whole turn.
   * 
   * @param ownerId Match owner identfier
   * 
   * @param matchId Match identifier
   * 
   * @param version Game state version to ensure turns are submitted once and in order
   * 
   * @param jsonSummary JSON string provided by the caller that other players will see as a summary of the game when listing their games
   * 
   * @param clientIndex
   */
  void AsyncMatch_UpdateMatchSummaryData(std::string& _return, const std::string& ownerId, const std::string& matchId, const int64_t version, const std::string& jsonSummary, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_UpdateMatchSummaryData\n");
  }

  /**
   * Marks the given match as complete.
   * 
   * @param ownerId Match owner identifier
   * 
   * @param matchId Match identifier
   * 
   * @param clientIndex
   */
  void AsyncMatch_CompleteMatch(std::string& _return, const std::string& ownerId, const std::string& matchId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_CompleteMatch\n");
  }

  /**
   * Returns the current state of the given match.
   * 
   * @param ownerId Match owner identifier
   * 
   * @param matchId Match identifier
   * 
   * @param clientIndex
   */
  void AsyncMatch_ReadMatch(std::string& _return, const std::string& ownerId, const std::string& matchId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_ReadMatch\n");
  }

  /**
   * Returns the match history of the given match.
   * 
   * @param ownerId Match owner identifier
   * 
   * @param matchId Match identifier
   * 
   * @param clientIndex
   */
  void AsyncMatch_ReadMatchHistory(std::string& _return, const std::string& ownerId, const std::string& matchId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_ReadMatchHistory\n");
  }

  /**
   * Returns all matches that are NOT in a COMPLETE state for which the player is involved.
   * 
   * @param clientIndex
   */
  void AsyncMatch_FindMatches(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_FindMatches\n");
  }

  /**
   * Returns all matches that are in a COMPLETE state for which the player is involved.
   * 
   * @param clientIndex
   */
  void AsyncMatch_FindCompleteMatches(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_FindCompleteMatches\n");
  }

  /**
   * Marks the given match as abandoned.
   * 
   * @param ownerId Match owner identifier
   * 
   * @param matchId Match identifier
   * 
   * @param clientIndex
   */
  void AsyncMatch_AbandonMatch(std::string& _return, const std::string& ownerId, const std::string& matchId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_AbandonMatch\n");
  }

  /**
   * Removes the match and match history from the server. DEBUG ONLY, in production it is recommended
   * the user leave it as completed.
   * 
   * @param ownerId Match owner identifier
   * 
   * @param matchId Match identifier
   * 
   * @param clientIndex
   */
  void AsyncMatch_DeleteMatch(std::string& _return, const std::string& ownerId, const std::string& matchId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("AsyncMatch_DeleteMatch\n");
  }

  /**
   * Used to create the anonymous installation id for the brainCloud profile.
   * 
   * @param clientIndex
   */
  void Authentication_GenerateAnonymousId(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_GenerateAnonymousId\n");
  }

  /**
   * Initialize - initializes the identity service with a saved
   * anonymous installation id and most recently used profile id
   * 
   * @param profileId The id of the profile id that was most recently used by the app (on this device)
   * 
   * @param anonymousId The anonymous installation id that was generated for this device
   * 
   * @param clientIndex
   */
  void Authentication_Initialize(const std::string& profileId, const std::string& anonymousId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_Initialize\n");
  }

  /**
   * Used to clear the saved profile id - to use in cases when the user is
   * attempting to switch to a different app profile.
   * 
   * @param clientIndex
   */
  void Authentication_ClearSavedProfileID(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_ClearSavedProfileID\n");
  }

  /**
   * Authenticate a user anonymously with brainCloud - used for apps that don't want to bother
   * the user to login, or for users who are sensitive to their privacy
   * 
   * @param forceCreate Should a new profile be created if it does not exist?
   * 
   * @param clientIndex
   */
  void Authentication_AuthenticateAnonymous(std::string& _return, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_AuthenticateAnonymous\n");
  }

  /**
   * Authenticate the user with a custom Email and Password.  Note that the client app
   * is responsible for collecting (and storing) the e-mail and potentially password
   * (for convenience) in the client data.  For the greatest security,
   * force the user to re-enter their password at each login.
   * (Or at least give them that option).
   * 
   * @param email The e-mail address of the user
   * 
   * @param password The password of the user
   * 
   * @param forceCreate Should a new profile be created for this user if the account does not exist?
   * 
   * @param clientIndex
   */
  void Authentication_AuthenticateEmailPassword(std::string& _return, const std::string& email, const std::string& password, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_AuthenticateEmailPassword\n");
  }

  /**
   * Authenticate the user using a userId and password (without any validation on the userId).
   * Similar to AuthenticateEmailPassword - except that that method has additional features to
   * allow for e-mail validation, password resets, etc.
   * 
   * @param userId
   * @param password The password of the user
   * 
   * @param forceCreate Should a new profile be created for this user if the account does not exist?
   * 
   * @param clientIndex
   */
  void Authentication_AuthenticateUniversal(std::string& _return, const std::string& userId, const std::string& password, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_AuthenticateUniversal\n");
  }

  /**
   * Authenticate the user via cloud code (which in turn validates the supplied credentials against an external system).
   * This allows the developer to extend brainCloud authentication to support other backend authentication systems.
   * 
   * @param userId The user id
   * 
   * @param token The user token (password etc)
   * 
   * @param externalAuthName The name of the cloud script to call for external authentication
   * 
   * @param forceCreate Should a new profile be created for this user if the account does not exist?
   * 
   * @param clientIndex
   */
  void Authentication_AuthenticateExternal(std::string& _return, const std::string& userId, const std::string& token, const std::string& externalAuthName, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_AuthenticateExternal\n");
  }

  /**
   * Authenticate the user via wechat
   * 
   * @param phoneNumber The phone number to authenticate with
   * 
   * @param authCode The code sent to the mobile phone
   * 
   * @param forceCreate Should a new profile be created for this user if the account does not exist?
   * 
   * @param clientIndex
   */
  void Authentication_AuthenticatePhone(std::string& _return, const std::string& phoneNumber, const std::string& authCode, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_AuthenticatePhone\n");
  }

  /**
   * Authenticate the user via wechat
   * 
   * @param openId The open id passed from wechat
   * 
   * @param token The access token passed from wechat
   * 
   * @param forceCreate Should a new profile be created for this user if the account does not exist?
   * 
   * @param clientIndex
   */
  void Authentication_AuthenticateWechat(std::string& _return, const std::string& openId, const std::string& token, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_AuthenticateWechat\n");
  }

  /**
   * Reset Email password - Sends a password reset email to the specified address
   * 
   * @param externalId The email address to send the reset email to.
   * 
   * @param clientIndex
   */
  void Authentication_ResetEmailPassword(std::string& _return, const std::string& externalId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_ResetEmailPassword\n");
  }

  /**
   * Request an SMS code sent to a phone prior to authentication.
   * 
   * @param phoneNumber The phone number to send the code to.
   * 
   * @param forceCreate Whether or not to create a new player if they don't exist.
   * 
   * @param clientIndex
   */
  void Authentication_RequestSmsCode(std::string& _return, const std::string& phoneNumber, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_RequestSmsCode\n");
  }

  /**
   * Returns the sessionId or empty string if no session present.
   * 
   * @param clientIndex
   */
  void Client_GetSessionId(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_GetSessionId\n");
  }

  /**
   * Returns true if the user is currently authenticated.
   * If a session time out or session invalidation is returned from executing a
   * sever API call, this flag will reset back to false.
   * 
   * @param clientIndex
   */
  bool Client_IsAuthenticated(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_IsAuthenticated\n");
  }

  /**
   * Returns true if brainCloud has been initialized.
   * 
   * @param clientIndex
   */
  bool Client_IsInitialized(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_IsInitialized\n");
  }

  /**
   * Method initializes the BrainCloudClient.
   * 
   * @param secretKey The secret key for your app
   * 
   * @param appId
   * @param appVersion The app version
   * 
   * @param clientIndex
   */
  void Client_Initialize_SSS(const std::string& secretKey, const std::string& appId, const std::string& appVersion, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_Initialize_SSS\n");
  }

  /**
   * Method initializes the BrainCloudClient.
   * 
   * @param serverURL The URL to the brainCloud server
   * 
   * @param secretKey The secret key for your app
   * 
   * @param appId The app id
   * 
   * @param appVersion The app version
   * 
   * @param clientIndex
   */
  void Client_Initialize_SSSS(const std::string& serverURL, const std::string& secretKey, const std::string& appId, const std::string& appVersion, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_Initialize_SSSS\n");
  }

  /**
   * Initialize the identity aspects of brainCloud.
   * 
   * @param profileId The profile id
   * 
   * @param anonymousId The anonymous id
   * 
   * @param clientIndex
   */
  void Client_InitializeIdentity(const std::string& profileId, const std::string& anonymousId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_InitializeIdentity\n");
  }

  /**
   * Update method needs to be called regularly in order
   * to process incoming and outgoing messages.
   * 
   * @param clientIndex
   */
  void Client_Update(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_Update\n");
  }

  /**
   * Enable logging of brainCloud transactions (comms etc)
   * 
   * @param enable True if logging is to be enabled
   * 
   * @param clientIndex
   */
  void Client_EnableLogging(const bool enable, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_EnableLogging\n");
  }

  /**
   * Resets all messages and calls to the server
   * 
   * @param clientIndex
   */
  void Client_ResetCommunication(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_ResetCommunication\n");
  }

  /**
   * Sets the packet timeouts using a list of integers that
   * represent timeout values for each packet retry. The
   * first item in the list represents the timeout for the first packet
   * attempt, the second for the second packet attempt, and so on.
   * 
   * The number of entries in this array determines how many packet
   * retries will occur.
   * 
   * By default, the packet timeout array is {10, 10, 10}
   * 
   * Note that this method does not change the timeout for authentication
   * packets (use SetAuthenticationPacketTimeout method).
   * 
   * @param timeouts An array of packet timeouts.
   * 
   * @param clientIndex
   */
  void Client_SetPacketTimeouts(const std::vector<int32_t> & timeouts, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_SetPacketTimeouts\n");
  }

  /**
   * Sets the packet timeouts back to default.
   * 
   * @param clientIndex
   */
  void Client_SetPacketTimeoutsToDefault(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_SetPacketTimeoutsToDefault\n");
  }

  /**
   * Returns the list of packet timeouts.
   * 
   * @param clientIndex
   */
  void Client_GetPacketTimeouts(std::vector<int32_t> & _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_GetPacketTimeouts\n");
  }

  /**
   * Sets the authentication packet timeout which is tracked separately
   * from all other packets. Note that authentication packets are never
   * retried and so this value represents the total time a client would
   * wait to receive a reply to an authentication API call. By default
   * this timeout is set to 15 seconds.
   * 
   * @param timeoutSecs
   * @param clientIndex
   */
  void Client_SetAuthenticationPacketTimeout(const int32_t timeoutSecs, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_SetAuthenticationPacketTimeout\n");
  }

  /**
   * Gets the authentication packet timeout which is tracked separately
   * from all other packets. Note that authentication packets are never
   * retried and so this value represents the total time a client would
   * wait to receive a reply to an authentication API call. By default
   * this timeout is set to 15 seconds.
   * 
   * @param clientIndex
   */
  int32_t Client_GetAuthenticationPacketTimeout(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_GetAuthenticationPacketTimeout\n");
  }

  /**
   * Returns the low transfer rate timeout in secs
   * 
   * @param clientIndex
   */
  int32_t Client_GetUploadLowTransferRateTimeout(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_GetUploadLowTransferRateTimeout\n");
  }

  /**
   * Sets the timeout in seconds of a low speed upload
   * (i.e. transfer rate which is underneath the low transfer rate threshold).
   * By default this is set to 120 secs.Setting this value to 0 will
   * turn off the timeout. Note that this timeout method
   * does not work on Unity mobile platforms.
   * 
   * @param timeoutSecs
   * @param clientIndex
   */
  void Client_SetUploadLowTransferRateTimeout(const int32_t timeoutSecs, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_SetUploadLowTransferRateTimeout\n");
  }

  /**
   * Returns the low transfer rate threshold in bytes/sec
   * 
   * @param clientIndex
   */
  int32_t Client_GetUploadLowTransferRateThreshold(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_GetUploadLowTransferRateThreshold\n");
  }

  /**
   * Sets the low transfer rate threshold of an upload in bytes/sec.
   * If the transfer rate dips below the given threshold longer
   * than the specified timeout, the transfer will fail.
   * By default this is set to 50 bytes/sec. Note that this timeout method
   * does not work on Unity mobile platforms.
   * 
   * @param bytesPerSec The low transfer rate threshold in bytes/sec
   * 
   * @param clientIndex
   */
  void Client_SetUploadLowTransferRateThreshold(const int32_t bytesPerSec, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_SetUploadLowTransferRateThreshold\n");
  }

  /**
   * Enables the timeout message caching which is disabled by default.
   * Once enabled, if a client side timeout is encountered
   * (i.e. brainCloud server is unreachable presumably due to the client
   * network being down) the SDK will do the following:
   * 
   * 1 - cache the currently queued messages to brainCloud
   * 2 - call the network error callback
   * 3 - then expect the app to call either:
   *     a) RetryCachedMessages() to retry sending to brainCloud
   *     b) FlushCachedMessages() to dump all messages in the queue.
   * 
   * Between steps 2 and 3, the app can prompt the user to retry connecting
   * to brainCloud to determine whether to follow path 3a or 3b.
   * 
   * Note that if path 3a is followed, and another timeout is encountered,
   * the process will begin all over again from step 1.
   * 
   * WARNING - the brainCloud SDK will cache *all* API calls sent
   * when a timeout is encountered if this mechanism is enabled.
   * This effectively freezes all communication with brainCloud.
   * Apps must call either RetryCachedMessages() or FlushCachedMessages()
   * for the brainCloud SDK to resume sending messages.
   * ResetCommunication() will also clear the message cache.
   * 
   * @param enabled True if message should be cached on timeout
   * 
   * @param clientIndex
   */
  void Client_EnableNetworkErrorMessageCaching(const bool enabled, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_EnableNetworkErrorMessageCaching\n");
  }

  /**
   * Attempts to resend any cached messages. If no messages are in the cache,
   * this method does nothing.
   * 
   * @param clientIndex
   */
  void Client_RetryCachedMessages(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_RetryCachedMessages\n");
  }

  /**
   * Flushes the cached messages to resume API call processing. This will dump
   * all of the cached messages in the queue.
   * 
   * @param sendApiErrorCallbacks If set to true API error callbacks will
   * be called for every cached message with statusCode CLIENT_NETWORK_ERROR and reasonCode CLIENT_NETWORK_ERROR_TIMEOUT.
   * 
   * @param clientIndex
   */
  void Client_FlushCachedMessages(const bool sendApiErrorCallbacks, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_FlushCachedMessages\n");
  }

  /**
   * Inserts a marker which will tell the brainCloud comms layer
   * to close the message bundle off at this point. Any messages queued
   * before this method was called will likely be bundled together in
   * the next send to the server.
   * 
   * To ensure that only a single message is sent to the server you would
   * do something like this:
   * 
   * InsertEndOfMessageBundleMarker()
   * SomeApiCall()
   * InsertEndOfMessageBundleMarker()
   * 
   * @param clientIndex
   */
  void Client_InsertEndOfMessageBundleMarker(const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_InsertEndOfMessageBundleMarker\n");
  }

  /**
   * Sets the country code sent to brainCloud when a user authenticates.
   * Will override any auto detected country.
   * 
   * @param countryCode ISO 3166-1 two-letter country code
   * 
   * @param clientIndex
   */
  void Client_OverrideCountryCode(const std::string& countryCode, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_OverrideCountryCode\n");
  }

  /**
   * Sets the language code sent to brainCloud when a user authenticates.
   * If the language is set to a non-ISO 639-1 standard value the game default will be used instead.
   * Will override any auto detected language.
   * 
   * @param languageCode ISO 639-1 two-letter language code
   * 
   * @param clientIndex
   */
  void Client_OverrideLanguageCode(const std::string& languageCode, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Client_OverrideLanguageCode\n");
  }

  /**
   * Creates custom data stream page event
   * 
   * @param eventName The name of the event
   * 
   * @param jsonEventProperties The properties of the event
   * 
   * @param clientIndex
   */
  void DataStream_CustomPageEvent(std::string& _return, const std::string& eventName, const std::string& jsonEventProperties, const int32_t clientIndex) {
    // Your implementation goes here
    printf("DataStream_CustomPageEvent\n");
  }

  /**
   * Creates custom data stream screen event
   * 
   * @param eventName The name of the event
   * 
   * @param jsonEventProperties The properties of the event
   * 
   * @param clientIndex
   */
  void DataStream_CustomScreenEvent(std::string& _return, const std::string& eventName, const std::string& jsonEventProperties, const int32_t clientIndex) {
    // Your implementation goes here
    printf("DataStream_CustomScreenEvent\n");
  }

  /**
   * Creates custom data stream track event
   * 
   * @param eventName The name of the event
   * 
   * @param jsonEventProperties The properties of the event
   * 
   * @param clientIndex
   */
  void DataStream_CustomTrackEvent(std::string& _return, const std::string& eventName, const std::string& jsonEventProperties, const int32_t clientIndex) {
    // Your implementation goes here
    printf("DataStream_CustomTrackEvent\n");
  }

  /**
   * Method creates a new entity on the server.
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param jsonEntityData The entity's data as a json string
   * 
   * @param jsonEntityAcl The entity's access control list as json. A null acl implies default
   * permissions which make the entity readable/writeable by only the user.
   * 
   * @param clientIndex
   */
  void Entity_CreateEntity(std::string& _return, const std::string& entityType, const std::string& jsonEntityData, const std::string& jsonEntityAcl, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_CreateEntity\n");
  }

  /**
   * Method returns all user entities that match the given type.
   * 
   * @param entityType The entity type to search for
   * 
   * @param clientIndex
   */
  void Entity_GetEntitiesByType(std::string& _return, const std::string& entityType, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetEntitiesByType\n");
  }

  /**
   * Method updates a new entity on the server. This operation results in the entity
   * data being completely replaced by the passed in JSON string.
   * 
   * @param entityId The id of the entity to update
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param jsonEntityData The entity's data as a json string.
   * 
   * @param jsonEntityAcl The entity's access control list as json. A null acl implies default
   * permissions which make the entity readable/writeable by only the user.
   * 
   * @param version Current version of the entity. If the version of the
   * entity on the server does not match the version passed in, the
   * server operation will fail. Use -1 to skip version checking.
   * 
   * @param clientIndex
   */
  void Entity_UpdateEntity(std::string& _return, const std::string& entityId, const std::string& entityType, const std::string& jsonEntityData, const std::string& jsonEntityAcl, const int32_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_UpdateEntity\n");
  }

  /**
   * Method updates a shared entity owned by another user. This operation results in the entity
   * data being completely replaced by the passed in JSON string.
   * 
   * @param entityId The id of the entity to update
   * 
   * @param targetProfileId The id of the entity's owner
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param jsonEntityData The entity's data as a json string.
   * 
   * @param version Current version of the entity. If the version of the
   * entity on the server does not match the version passed in, the
   * server operation will fail. Use -1 to skip version checking.
   * 
   * @param clientIndex
   */
  void Entity_UpdateSharedEntity(std::string& _return, const std::string& entityId, const std::string& targetProfileId, const std::string& entityType, const std::string& jsonEntityData, const int32_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_UpdateSharedEntity\n");
  }

  /**
   * Method deletes the given entity on the server.
   * 
   * @param entityId The id of the entity to update
   * 
   * @param version Current version of the entity. If the version of the
   * entity on the server does not match the version passed in, the
   * server operation will fail. Use -1 to skip version checking.
   * 
   * @param clientIndex
   */
  void Entity_DeleteEntity(std::string& _return, const std::string& entityId, const int32_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_DeleteEntity\n");
  }

  /**
   * Method updates a singleton entity on the server. This operation results in the entity
   * data being completely replaced by the passed in JSON string. If the entity doesn't exist it is created.
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param jsonEntityData The entity's data as a json string.
   * 
   * @param jsonEntityAcl The entity's access control list as json. A null acl implies default
   * 
   * @param version Current version of the entity. If the version of the
   * entity on the server does not match the version passed in, the
   * server operation will fail. Use -1 to skip version checking.
   * 
   * @param clientIndex
   */
  void Entity_UpdateSingleton(std::string& _return, const std::string& entityType, const std::string& jsonEntityData, const std::string& jsonEntityAcl, const int32_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_UpdateSingleton\n");
  }

  /**
   * Method deletes the given singleton on the server.
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param version Current version of the entity. If the version of the
   * entity on the server does not match the version passed in, the
   * server operation will fail. Use -1 to skip version checking.
   * 
   * @param clientIndex
   */
  void Entity_DeleteSingleton(std::string& _return, const std::string& entityType, const int32_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_DeleteSingleton\n");
  }

  /**
   * Method to get a specific entity.
   * 
   * @param entityId The id of the entity
   * 
   * @param clientIndex
   */
  void Entity_GetEntity(std::string& _return, const std::string& entityId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetEntity\n");
  }

  /**
   * Method retrieves a singleton entity on the server. If the entity doesn't exist, null is returned.
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param clientIndex
   */
  void Entity_GetSingleton(std::string& _return, const std::string& entityType, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetSingleton\n");
  }

  /**
   * Method returns a shared entity for the given profile and entity ID.
   * An entity is shared if its ACL allows for the currently logged
   * in user to read the data.
   * 
   * @param profileId The the profile ID of the user who owns the entity
   * 
   * @param entityId The ID of the entity that will be retrieved
   * 
   * @param clientIndex
   */
  void Entity_GetSharedEntityForProfileId(std::string& _return, const std::string& profileId, const std::string& entityId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetSharedEntityForProfileId\n");
  }

  /**
   * Method returns all shared entities for the given profile id.
   * An entity is shared if its ACL allows for the currently logged
   * in user to read the data.
   * 
   * @param profileId The profile id to retrieve shared entities for
   * 
   * @param clientIndex
   */
  void Entity_GetSharedEntitiesForProfileId(std::string& _return, const std::string& profileId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetSharedEntitiesForProfileId\n");
  }

  /**
   * Method gets list of entities from the server base on type and/or where clause
   * 
   * @param whereJson Mongo style query string
   * 
   * @param orderByJson Sort order
   * 
   * @param maxReturn The maximum number of entities to return
   * 
   * @param clientIndex
   */
  void Entity_GetList(std::string& _return, const std::string& whereJson, const std::string& orderByJson, const int32_t maxReturn, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetList\n");
  }

  /**
   * Method gets list of shared entities for the specified user based on type and/or where clause
   * 
   * @param profileId The profile ID to retrieve shared entities for
   * 
   * @param whereJson Mongo style query string
   * 
   * @param orderByJson Sort order
   * 
   * @param maxReturn The maximum number of entities to return
   * 
   * @param clientIndex
   */
  void Entity_GetSharedEntitiesListForProfileId(std::string& _return, const std::string& profileId, const std::string& whereJson, const std::string& orderByJson, const int32_t maxReturn, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetSharedEntitiesListForProfileId\n");
  }

  /**
   * Method gets a count of entities based on the where clause
   * 
   * @param whereJson Mongo style query string
   * 
   * @param clientIndex
   */
  void Entity_GetListCount(std::string& _return, const std::string& whereJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetListCount\n");
  }

  /**
   * Method uses a paging system to iterate through user entities.
   * After retrieving a page of entities with this method,
   * use GetPageOffset() to retrieve previous or next pages.
   * 
   * @param jsonContext The json context for the page request.
   * See the portal appendix documentation for format
   * 
   * @param clientIndex
   */
  void Entity_GetPage(std::string& _return, const std::string& jsonContext, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetPage\n");
  }

  /**
   * Method to retrieve previous or next pages after having called
   * the GetPage method.
   * 
   * @param context The context string returned from the server from a previous call
   * to GetPage() or GetPageOffset()
   * 
   * @param pageOffset The positive or negative page offset to fetch. Uses the last page
   * retrieved using the context string to determine a starting point.
   * 
   * @param clientIndex
   */
  void Entity_GetPageOffset(std::string& _return, const std::string& context, const int32_t pageOffset, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_GetPageOffset\n");
  }

  /**
   * Partial increment of entity data field items. Partial set of items incremented as specified.
   * 
   * @param entityId The entity to increment
   * 
   * @param jsonData The subset of data to increment
   * 
   * @param clientIndex
   */
  void Entity_IncrementUserEntityData(std::string& _return, const std::string& entityId, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_IncrementUserEntityData\n");
  }

  /**
   * Partial increment of shared entity data field items. Partial set of items incremented as specified.
   * 
   * @param entityId The entity to increment
   * 
   * @param targetProfileId Profile ID of the entity owner
   * 
   * @param jsonData The subset of data to increment
   * 
   * @param clientIndex
   */
  void Entity_IncrementSharedUserEntityData(std::string& _return, const std::string& entityId, const std::string& targetProfileId, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Entity_IncrementSharedUserEntityData\n");
  }

  /**
   * Sends an event to the designated profile id with the attached json data.
   * Any events that have been sent to a user will show up in their
   * incoming event mailbox. If the recordLocally flag is set to true,
   * a copy of this event (with the exact same event id) will be stored
   * in the sending user's "sent" event mailbox.
   * 
   * @param toProfileId The id of the user who is being sent the event
   * 
   * @param eventType The user-defined type of the event.
   * 
   * @param jsonEventData The user-defined data for this event encoded in JSON.
   * 
   * @param clientIndex
   */
  void Event_SendEvent(std::string& _return, const std::string& toProfileId, const std::string& eventType, const std::string& jsonEventData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Event_SendEvent\n");
  }

  /**
   * Updates an event in the user's incoming event mailbox.
   * 
   * @param evId The event id
   * 
   * @param jsonEventData The user-defined data for this event encoded in JSON.
   * 
   * @param clientIndex
   */
  void Event_UpdateIncomingEventData(std::string& _return, const std::string& evId, const std::string& jsonEventData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Event_UpdateIncomingEventData\n");
  }

  /**
   * Delete an event out of the user's incoming mailbox.
   * 
   * @param evId The event id
   * 
   * @param clientIndex
   */
  void Event_DeleteIncomingEvent(std::string& _return, const std::string& evId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Event_DeleteIncomingEvent\n");
  }

  /**
   * Get the events currently queued for the user.
   * 
   * @param clientIndex
   */
  void Event_GetEvents(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Event_GetEvents\n");
  }

  /**
   * Prepares a user file upload. On success the file will begin uploading
   * to the brainCloud server.To be informed of success/failure of the upload
   * register an IFileUploadCallback with the BrainCloudClient class.
   * 
   * @param cloudPath The desired cloud path of the file
   * 
   * @param cloudFilename The desired cloud fileName of the file
   * 
   * @param shareable True if the file is shareable
   * 
   * @param replaceIfExists Whether to replace file if it exists
   * 
   * @param localPath The path and fileName of the local file
   * 
   * @param clientIndex
   */
  void File_UploadFile(std::string& _return, const std::string& cloudPath, const std::string& cloudFilename, const bool shareable, const bool replaceIfExists, const std::string& localPath, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_UploadFile\n");
  }

  /**
   * Method cancels an upload. If an IFileUploadCallback has been registered with the BrainCloudClient class,
   * the fileUploadFailed callback method will be called once the upload has been canceled.
   * NOTE: The upload will still continue in the background on versions of Unity before 5.3
   * and on Unity mobile platforms.
   * 
   * @param uploadId Upload ID of the file to cancel
   * 
   * @param clientIndex
   */
  void File_CancelUpload(const std::string& uploadId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_CancelUpload\n");
  }

  /**
   * Returns the progress of the given upload from 0.0 to 1.0 or -1 if upload not found.
   * NOTE: This will always return 1 on Unity mobile platforms.
   * 
   * @param uploadId The id of the upload
   * 
   * @param clientIndex
   */
  double File_GetUploadProgress(const std::string& uploadId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_GetUploadProgress\n");
  }

  /**
   * Returns the number of bytes uploaded or -1 if upload not found.
   * NOTE: This will always return the total bytes to transfer on Unity mobile platforms.
   * 
   * @param uploadId The id of the upload
   * 
   * @param clientIndex
   */
  int64_t File_GetUploadBytesTransferred(const std::string& uploadId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_GetUploadBytesTransferred\n");
  }

  /**
   * Returns the total number of bytes that will be uploaded or -1 if upload not found.
   * 
   * @param uploadId The id of the upload
   * 
   * @param clientIndex
   */
  int64_t File_GetUploadTotalBytesToTransfer(const std::string& uploadId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_GetUploadTotalBytesToTransfer\n");
  }

  /**
   * List all user files
   * 
   * @param clientIndex
   */
  void File_ListUserFiles_SFO(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_ListUserFiles_SFO\n");
  }

  /**
   * List user files from the given cloud path
   * 
   * @param cloudPath File path
   * 
   * @param recurse Whether to recurse down the path
   * 
   * @param clientIndex
   */
  void File_ListUserFiles_SNSFO(std::string& _return, const std::string& cloudPath, const bool recurse, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_ListUserFiles_SNSFO\n");
  }

  /**
   * Deletes a single user file.
   * 
   * @param cloudPath File path
   * 
   * @param cloudFileName
   * @param clientIndex
   */
  void File_DeleteUserFile(std::string& _return, const std::string& cloudPath, const std::string& cloudFileName, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_DeleteUserFile\n");
  }

  /**
   * Delete multiple user files
   * 
   * @param cloudPath File path
   * 
   * @param recurse Whether to recurse down the path
   * 
   * @param clientIndex
   */
  void File_DeleteUserFiles(std::string& _return, const std::string& cloudPath, const bool recurse, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_DeleteUserFiles\n");
  }

  /**
   * Returns the CDN URL for a file object.
   * 
   * @param cloudPath File path
   * 
   * @param cloudFilename Name of file
   * 
   * @param clientIndex
   */
  void File_GetCDNUrl(std::string& _return, const std::string& cloudPath, const std::string& cloudFilename, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_GetCDNUrl\n");
  }

  /**
   * Returns a particular entity of a particular friend.
   * 
   * @param entityId Id of entity to retrieve.
   * 
   * @param friendId Profile Id of friend who owns entity.
   * 
   * @param clientIndex
   */
  void Friend_ReadFriendEntity(std::string& _return, const std::string& entityId, const std::string& friendId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_ReadFriendEntity\n");
  }

  /**
   * Returns entities of all friends based on type and/or subtype.
   * 
   * @param entityType Types of entities to retrieve.
   * 
   * @param clientIndex
   */
  void Friend_ReadFriendsEntities(std::string& _return, const std::string& entityType, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_ReadFriendsEntities\n");
  }

  /**
   * Returns user state of a particular friend.
   * 
   * @param friendId Profile Id of friend to retrieve user state for.
   * 
   * @param clientIndex
   */
  void Friend_ReadFriendUserState(std::string& _return, const std::string& friendId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_ReadFriendUserState\n");
  }

  /**
   * Returns user state of a particular user.
   * 
   * @param playerId
   * @param clientIndex
   */
  void Friend_GetSummaryDataForProfileId(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_GetSummaryDataForProfileId\n");
  }

  /**
   * Returns user state of a set of users.
   * 
   * @param playerIds Player Ids of users to retrieve player state for.
   * 
   * @param clientIndex
   */
  void Friend_GetSummaryDataForProfileIds(std::string& _return, const std::vector<std::string> & playerIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_GetSummaryDataForProfileIds\n");
  }

  /**
   * Returns user state of the player's friends.
   * 
   * @param clientIndex
   */
  void Friend_GetSummaryDataForFriends(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_GetSummaryDataForFriends\n");
  }

  /**
   * Returns user state of player's recently met.
   * 
   * @param clientIndex
   */
  void Friend_GetSummaryDataForRecentlyMetPlayers(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_GetSummaryDataForRecentlyMetPlayers\n");
  }

  /**
   * Finds a list of users matching the search text by performing an exact
   * search of all user names.
   * 
   * @param searchText The string to search for.
   * 
   * @param maxResults Maximum number of results to return.
   * 
   * @param clientIndex
   */
  void Friend_FindUsersByExactName(std::string& _return, const std::string& searchText, const int32_t maxResults, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_FindUsersByExactName\n");
  }

  /**
   * Finds a list of users matching the search text by performing a substring
   * search of all user names.
   * 
   * @param searchText The substring to search for. Minimum length of 3 characters.
   * 
   * @param maxResults Maximum number of results to return.
   * 
   * @param clientIndex
   */
  void Friend_FindUsersBySubstrName(std::string& _return, const std::string& searchText, const int32_t maxResults, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_FindUsersBySubstrName\n");
  }

  /**
   * Retrieves a list of user and friend platform information for all friends of the current user.
   * 
   * @param friendPlatform Friend platform to query.
   * 
   * @param includeSummaryData True if including summary data; false otherwise.
   * 
   * @param clientIndex
   */
  void Friend_ListFriends(std::string& _return, const  ::Ruyi::SDK::BrainCloudApi::FriendPlatform::type friendPlatform, const bool includeSummaryData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_ListFriends\n");
  }

  /**
   * Links the current user and the specified users as brainCloud friends.
   * 
   * @param profileIds Collection of profile IDs.
   * 
   * @param clientIndex
   */
  void Friend_AddFriends(std::string& _return, const std::vector<std::string> & profileIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_AddFriends\n");
  }

  /**
   * Unlinks the current user and the specified users as brainCloud friends.
   * 
   * @param profileIds Collection of profile IDs.
   * 
   * @param clientIndex
   */
  void Friend_RemoveFriends(std::string& _return, const std::vector<std::string> & profileIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_RemoveFriends\n");
  }

  /**
   * Get users online status
   * 
   * @param profileIds Collection of profile IDs.
   * 
   * @param clientIndex
   */
  void Friend_GetUsersOnlineStatus(std::string& _return, const std::vector<std::string> & profileIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_GetUsersOnlineStatus\n");
  }

  void Friend_SendFriendInvitation(std::string& _return, const std::string& toPlayerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_SendFriendInvitation\n");
  }

  void Friend_ListFriendInvitationsReceived(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_ListFriendInvitationsReceived\n");
  }

  void Friend_ListFriendInvitationsSent(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_ListFriendInvitationsSent\n");
  }

  void Friend_AcceptFriendInvitation(std::string& _return, const std::string& fromPlayerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_AcceptFriendInvitation\n");
  }

  void Friend_RejectFriendInvitation(std::string& _return, const std::string& fromPlayerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_RejectFriendInvitation\n");
  }

  void Friend_RemoveFriend(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Friend_RemoveFriend\n");
  }

  /**
   * Method retrieves all gamification data for the player.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadAllGamification(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadAllGamification\n");
  }

  /**
   * Method retrieves all milestones defined for the game.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadMilestones(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadMilestones\n");
  }

  /**
   * Read all of the achievements defined for the game.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadAchievements(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadAchievements\n");
  }

  /**
   * Method returns all defined xp levels and any rewards associated
   * with those xp levels.
   * 
   * @param clientIndex
   */
  void Gamification_ReadXpLevelsMetaData(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadXpLevelsMetaData\n");
  }

  /**
   * Method retrives the list of achieved achievements.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadAchievedAchievements(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadAchievedAchievements\n");
  }

  /**
   * Method retrieves the list of completed milestones.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadCompletedMilestones(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadCompletedMilestones\n");
  }

  /**
   * Method retrieves the list of in progress milestones
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadInProgressMilestones(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadInProgressMilestones\n");
  }

  /**
   * Method retrieves milestones of the given category.
   * 
   * @param category The milestone category
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadMilestonesByCategory(std::string& _return, const std::string& category, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadMilestonesByCategory\n");
  }

  /**
   * Method will award the achievements specified. On success, this will
   * call AwardThirdPartyAchievement to hook into the client-side Achievement
   * service (ie GameCentre, Facebook etc).
   * 
   * @param achievementIds A collection of achievement ids to award
   * 
   * @param clientIndex
   */
  void Gamification_AwardAchievements(std::string& _return, const std::vector<std::string> & achievementIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_AwardAchievements\n");
  }

  /**
   * Method retrieves all of the quests defined for the game.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadQuests(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadQuests\n");
  }

  /**
   * Method returns all completed quests.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadCompletedQuests(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadCompletedQuests\n");
  }

  /**
   * Method returns all in progress quests.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadInProgressQuests(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadInProgressQuests\n");
  }

  /**
   * Method returns all quests that haven't been started.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadNotStartedQuests(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadNotStartedQuests\n");
  }

  /**
   * Method returns all quests with status.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadQuestsWithStatus(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadQuestsWithStatus\n");
  }

  /**
   * Method returns all quests with a basic percentage.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadQuestsWithBasicPercentage(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadQuestsWithBasicPercentage\n");
  }

  /**
   * Method returns all quests with a complex percentage.
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadQuestsWithComplexPercentage(std::string& _return, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadQuestsWithComplexPercentage\n");
  }

  /**
   * Method returns all quests for the given category.
   * 
   * @param category The quest category
   * 
   * @param includeMetaData
   * @param clientIndex
   */
  void Gamification_ReadQuestsByCategory(std::string& _return, const std::string& category, const bool includeMetaData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ReadQuestsByCategory\n");
  }

  /**
   * Sets the specified milestones' statuses to LOCKED.
   * 
   * @param milestoneIds List of milestones to reset
   * 
   * @param clientIndex
   */
  void Gamification_ResetMilestones(std::string& _return, const std::vector<std::string> & milestoneIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Gamification_ResetMilestones\n");
  }

  /**
   * Method reads all the global properties of the game
   * 
   * @param clientIndex
   */
  void GlobalApp_ReadProperties(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalApp_ReadProperties\n");
  }

  /**
   * Method creates a new entity on the server.
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param timeToLive Sets expiry time for entity in milliseconds if > 0
   * 
   * @param jsonEntityAcl The entity's access control list as json. A null acl implies default
   * 
   * @param jsonEntityData The entity's data as a json string
   * 
   * @param clientIndex
   */
  void GlobalEntity_CreateEntity(std::string& _return, const std::string& entityType, const int64_t timeToLive, const std::string& jsonEntityAcl, const std::string& jsonEntityData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_CreateEntity\n");
  }

  /**
   * Method creates a new entity on the server with an indexed id.
   * 
   * @param entityType The entity type as defined by the user
   * 
   * @param indexedId A secondary ID that will be indexed
   * 
   * @param timeToLive Sets expiry time for entity in milliseconds if > 0
   * 
   * @param jsonEntityAcl The entity's access control list as json. A null acl implies default
   * 
   * @param jsonEntityData The entity's data as a json string
   * 
   * @param clientIndex
   */
  void GlobalEntity_CreateEntityWithIndexedId(std::string& _return, const std::string& entityType, const std::string& indexedId, const int64_t timeToLive, const std::string& jsonEntityAcl, const std::string& jsonEntityData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_CreateEntityWithIndexedId\n");
  }

  /**
   * Method updates an existing entity on the server.
   * 
   * @param entityId The entity ID
   * 
   * @param version The version of the entity to update
   * 
   * @param jsonEntityData The entity's data as a json string
   * 
   * @param clientIndex
   */
  void GlobalEntity_UpdateEntity(std::string& _return, const std::string& entityId, const int32_t version, const std::string& jsonEntityData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_UpdateEntity\n");
  }

  /**
   * Method updates an existing entity's Acl on the server.
   * 
   * @param entityId The entity ID
   * 
   * @param version The version of the entity to update
   * 
   * @param jsonEntityAcl The entity's access control list as json.
   * 
   * @param clientIndex
   */
  void GlobalEntity_UpdateEntityAcl(std::string& _return, const std::string& entityId, const int32_t version, const std::string& jsonEntityAcl, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_UpdateEntityAcl\n");
  }

  /**
   * Method updates an existing entity's time to live on the server.
   * 
   * @param entityId The entity ID
   * 
   * @param version The version of the entity to update
   * 
   * @param timeToLive Sets expiry time for entity in milliseconds if > 0
   * 
   * @param clientIndex
   */
  void GlobalEntity_UpdateEntityTimeToLive(std::string& _return, const std::string& entityId, const int32_t version, const int64_t timeToLive, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_UpdateEntityTimeToLive\n");
  }

  /**
   * Method deletes an existing entity on the server.
   * 
   * @param entityId The entity ID
   * 
   * @param version The version of the entity to delete
   * 
   * @param clientIndex
   */
  void GlobalEntity_DeleteEntity(std::string& _return, const std::string& entityId, const int32_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_DeleteEntity\n");
  }

  /**
   * Method reads an existing entity from the server.
   * 
   * @param entityId The entity ID
   * 
   * @param clientIndex
   */
  void GlobalEntity_ReadEntity(std::string& _return, const std::string& entityId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_ReadEntity\n");
  }

  /**
   * Method gets list of entities from the server base on type and/or where clause
   * 
   * @param whereJson Mongo style query string
   * 
   * @param orderByJson Sort order
   * 
   * @param maxReturn The maximum number of entities to return
   * 
   * @param clientIndex
   */
  void GlobalEntity_GetList(std::string& _return, const std::string& whereJson, const std::string& orderByJson, const int32_t maxReturn, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_GetList\n");
  }

  /**
   * Method gets list of entities from the server base on indexed id
   * 
   * @param entityIndexedId The entity indexed Id
   * 
   * @param maxReturn The maximum number of entities to return
   * 
   * @param clientIndex
   */
  void GlobalEntity_GetListByIndexedId(std::string& _return, const std::string& entityIndexedId, const int32_t maxReturn, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_GetListByIndexedId\n");
  }

  /**
   * Method gets a count of entities based on the where clause
   * 
   * @param whereJson Mongo style query string
   * 
   * @param clientIndex
   */
  void GlobalEntity_GetListCount(std::string& _return, const std::string& whereJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_GetListCount\n");
  }

  /**
   * Method uses a paging system to iterate through Global Entities.
   * After retrieving a page of Global Entities with this method,
   * use GetPageOffset() to retrieve previous or next pages.
   * 
   * @param jsonContext The json context for the page request.
   * See the portal appendix documentation for format
   * 
   * @param clientIndex
   */
  void GlobalEntity_GetPage(std::string& _return, const std::string& jsonContext, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_GetPage\n");
  }

  /**
   * Method to retrieve previous or next pages after having called
   * the GetPage method.
   * 
   * @param context The context string returned from the server from a previous call
   * to GetPage() or GetPageOffset()
   * 
   * @param pageOffset The positive or negative page offset to fetch. Uses the last page
   * retrieved using the context string to determine a starting point.
   * 
   * @param clientIndex
   */
  void GlobalEntity_GetPageOffset(std::string& _return, const std::string& context, const int32_t pageOffset, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_GetPageOffset\n");
  }

  /**
   * Partial increment of global entity data field items. Partial set of items incremented as specified.
   * 
   * @param entityId The entity to increment
   * 
   * @param jsonData The subset of data to increment
   * 
   * @param clientIndex
   */
  void GlobalEntity_IncrementGlobalEntityData(std::string& _return, const std::string& entityId, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_IncrementGlobalEntityData\n");
  }

  /**
   * Gets a list of up to randomCount randomly selected entities from the server based on the where condition and specified maximum return count.
   * 
   * @param whereJson
   * @param maxReturn The maximum number of entities to return
   * 
   * @param clientIndex
   */
  void GlobalEntity_GetRandomEntitiesMatching(std::string& _return, const std::string& whereJson, const int32_t maxReturn, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_GetRandomEntitiesMatching\n");
  }

  /**
   * Method updates an existing entity's Owner and Acl on the server.
   * 
   * @param entityId The entity ID
   * 
   * @param version The version of the entity
   * 
   * @param ownerId The owner ID
   * 
   * @param acl The entity's access control list
   * 
   * @param clientIndex
   */
  void GlobalEntity_UpdateEntityOwnerAndAcl(std::string& _return, const std::string& entityId, const int64_t version, const std::string& ownerId, const  ::Ruyi::SDK::BrainCloudApi::JSON& acl, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_UpdateEntityOwnerAndAcl\n");
  }

  /**
   * Method clears the owner id of an existing entity and sets the Acl on the server.
   * 
   * @param entityId The entity ID
   * 
   * @param version The version of the entity
   * 
   * @param acl The entity's access control list
   * 
   * @param clientIndex
   */
  void GlobalEntity_MakeSystemEntity(std::string& _return, const std::string& entityId, const int64_t version, const  ::Ruyi::SDK::BrainCloudApi::JSON& acl, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalEntity_MakeSystemEntity\n");
  }

  /**
   * Method returns all of the global statistics.
   * 
   * @param clientIndex
   */
  void GlobalStatistics_ReadAllGlobalStats(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalStatistics_ReadAllGlobalStats\n");
  }

  /**
   * Reads a subset of global statistics as defined by the input JSON.
   * 
   * @param globalStats A list containing the statistics to read
   * 
   * @param clientIndex
   */
  void GlobalStatistics_ReadGlobalStatsSubset(std::string& _return, const std::vector<std::string> & globalStats, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalStatistics_ReadGlobalStatsSubset\n");
  }

  /**
   * Method retrieves the global statistics for the given category.
   * 
   * @param category The global statistics category
   * 
   * @param clientIndex
   */
  void GlobalStatistics_ReadGlobalStatsForCategory(std::string& _return, const std::string& category, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalStatistics_ReadGlobalStatsForCategory\n");
  }

  /**
   * Atomically increment (or decrement) global statistics.
   * Global statistics are defined through the brainCloud portal.
   * 
   * @param jsonData The JSON encoded data to be sent to the server as follows:
   * {
   *   stat1: 10,
   *   stat2: -5.5,
   * }
   * would increment stat1 by 10 and decrement stat2 by 5.5.
   * For the full statistics grammer see the api.braincloudservers.com site.
   * There are many more complex operations supported such as:
   * {
   *   stat1:INC_TO_LIMIT#9#30
   * }
   * which increments stat1 by 9 up to a limit of 30.
   * 
   * @param clientIndex
   */
  void GlobalStatistics_IncrementGlobalStats(std::string& _return, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalStatistics_IncrementGlobalStats\n");
  }

  /**
   * Apply statistics grammar to a partial set of statistics.
   * 
   * @param statisticsData Example data to be passed to method:
   * {
   *     "DEAD_CATS": "RESET",
   *     "LIVES_LEFT": "SET#9",
   *     "MICE_KILLED": "INC#2",
   *     "DOG_SCARE_BONUS_POINTS": "INC#10",
   *     "TREES_CLIMBED": 1
   * }
   * 
   * @param clientIndex
   */
  void GlobalStatistics_ProcessStatistics(std::string& _return, const std::map<std::string,  ::Ruyi::SDK::BrainCloudApi::JSON> & statisticsData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("GlobalStatistics_ProcessStatistics\n");
  }

  /**
   * Accept an outstanding invitation to join the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_AcceptGroupInvitation(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_AcceptGroupInvitation\n");
  }

  /**
   * Add a member to the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the member being added.
   * 
   * @param role Role of the member being added.
   * 
   * @param jsonAttributes Attributes of the member being added.
   * 
   * @param clientIndex
   */
  void Group_AddGroupMember(std::string& _return, const std::string& groupId, const std::string& profileId, const  ::Ruyi::SDK::BrainCloudApi::Role::type role, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_AddGroupMember\n");
  }

  /**
   * Approve an outstanding request to join the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the invitation being deleted.
   * 
   * @param role Role of the member being invited.
   * 
   * @param jsonAttributes Attributes of the member being invited.
   * 
   * @param clientIndex
   */
  void Group_ApproveGroupJoinRequest(std::string& _return, const std::string& groupId, const std::string& profileId, const  ::Ruyi::SDK::BrainCloudApi::Role::type role, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ApproveGroupJoinRequest\n");
  }

  /**
   * Automatically join an open group that matches the search criteria and has space available.
   * 
   * @param groupType Name of the associated group type.
   * 
   * @param autoJoinStrategy Selection strategy to employ when there are multiple matches
   * 
   * @param dataQueryJson Query parameters (optional)
   * 
   * @param clientIndex
   */
  void Group_AutoJoinGroup(std::string& _return, const std::string& groupType, const  ::Ruyi::SDK::BrainCloudApi::AutoJoinStrategy::type autoJoinStrategy, const std::string& dataQueryJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_AutoJoinGroup\n");
  }

  /**
   * Cancel an outstanding invitation to the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the invitation being deleted.
   * 
   * @param clientIndex
   */
  void Group_CancelGroupInvitation(std::string& _return, const std::string& groupId, const std::string& profileId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_CancelGroupInvitation\n");
  }

  /**
   * Create a group.
   * 
   * @param name Name of the group.
   * 
   * @param groupType Name of the type of group.
   * 
   * @param isOpenGroup true if group is open; false if closed.
   * 
   * @param acl The group's access control list. A null ACL implies default.
   * 
   * @param jsonData Custom application data.
   * 
   * @param jsonOwnerAttributes Attributes for the group owner (current user).
   * 
   * @param jsonDefaultMemberAttributes Default attributes for group members.
   * 
   * @param clientIndex
   */
  void Group_CreateGroup(std::string& _return, const std::string& name, const std::string& groupType, const bool isOpenGroup, const  ::Ruyi::SDK::BrainCloudApi::JSON& acl, const std::string& jsonData, const std::string& jsonOwnerAttributes, const std::string& jsonDefaultMemberAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_CreateGroup\n");
  }

  /**
   * Create a group entity.
   * 
   * @param groupId ID of the group.
   * 
   * @param entityType
   * @param isOwnedByGroupMember true if entity is owned by a member; false if owned by the entire group.
   * 
   * @param acl Access control list for the group entity.
   * 
   * @param jsonData Custom application data.
   * 
   * @param clientIndex
   */
  void Group_CreateGroupEntity(std::string& _return, const std::string& groupId, const std::string& entityType, const bool isOwnedByGroupMember, const  ::Ruyi::SDK::BrainCloudApi::JSON& acl, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_CreateGroupEntity\n");
  }

  /**
   * Delete a group.
   * 
   * @param groupId ID of the group.
   * 
   * @param version Current version of the group
   * 
   * @param clientIndex
   */
  void Group_DeleteGroup(std::string& _return, const std::string& groupId, const int64_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_DeleteGroup\n");
  }

  /**
   * Delete a group entity.
   * 
   * @param groupId ID of the group.
   * 
   * @param entityId ID of the entity.
   * 
   * @param version The current version of the group entity (for concurrency checking).
   * 
   * @param clientIndex
   */
  void Group_DeleteGroupEntity(std::string& _return, const std::string& groupId, const std::string& entityId, const int64_t version, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_DeleteGroupEntity\n");
  }

  /**
   * Read information on groups to which the current user belongs.
   * 
   * @param clientIndex
   */
  void Group_GetMyGroups(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_GetMyGroups\n");
  }

  /**
   * Increment elements for the group's data field.
   * 
   * @param groupId ID of the group.
   * 
   * @param jsonData Partial data map with incremental values.
   * 
   * @param clientIndex
   */
  void Group_IncrementGroupData(std::string& _return, const std::string& groupId, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_IncrementGroupData\n");
  }

  /**
   * Increment elements for the group entity's data field.
   * 
   * @param groupId ID of the group.
   * 
   * @param entityId ID of the entity.
   * 
   * @param jsonData Partial data map with incremental values.
   * 
   * @param clientIndex
   */
  void Group_IncrementGroupEntityData(std::string& _return, const std::string& groupId, const std::string& entityId, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_IncrementGroupEntityData\n");
  }

  /**
   * Invite a member to the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the member being invited.
   * 
   * @param role Role of the member being invited.
   * 
   * @param jsonAttributes Attributes of the member being invited.
   * 
   * @param clientIndex
   */
  void Group_InviteGroupMember(std::string& _return, const std::string& groupId, const std::string& profileId, const  ::Ruyi::SDK::BrainCloudApi::Role::type role, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_InviteGroupMember\n");
  }

  /**
   * Join an open group or request to join a closed group.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_JoinGroup(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_JoinGroup\n");
  }

  /**
   * Leave a group in which the user is a member.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_LeaveGroup(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_LeaveGroup\n");
  }

  /**
   * Retrieve a page of group summary information based on the specified context.
   * 
   * @param jsonContext Query context.
   * 
   * @param clientIndex
   */
  void Group_ListGroupsPage(std::string& _return, const std::string& jsonContext, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ListGroupsPage\n");
  }

  /**
   * Retrieve a page of group summary information based on the encoded context
   * and specified page offset.
   * 
   * @param context Encoded reference query context.
   * 
   * @param pageOffset Number of pages by which to offset the query.
   * 
   * @param clientIndex
   */
  void Group_ListGroupsPageByOffset(std::string& _return, const std::string& context, const int32_t pageOffset, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ListGroupsPageByOffset\n");
  }

  /**
   * Read information on groups to which the specified user belongs.  Access is subject to restrictions.
   * 
   * @param profileId User to read groups for
   * 
   * @param clientIndex
   */
  void Group_ListGroupsWithMember(std::string& _return, const std::string& profileId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ListGroupsWithMember\n");
  }

  /**
   * Read the specified group.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_ReadGroup(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ReadGroup\n");
  }

  /**
   * Read the data of the specified group.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_ReadGroupData(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ReadGroupData\n");
  }

  /**
   * Read a page of group entity information.
   * 
   * @param jsonContext Query context.
   * 
   * @param clientIndex
   */
  void Group_ReadGroupEntitiesPage(std::string& _return, const std::string& jsonContext, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ReadGroupEntitiesPage\n");
  }

  /**
   * Read a page of group entity information.
   * 
   * @param encodedContext Encoded reference query context.
   * 
   * @param pageOffset Number of pages by which to offset the query.
   * 
   * @param clientIndex
   */
  void Group_ReadGroupEntitiesPageByOffset(std::string& _return, const std::string& encodedContext, const int32_t pageOffset, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ReadGroupEntitiesPageByOffset\n");
  }

  /**
   * Read the specified group entity.
   * 
   * @param groupId ID of the group.
   * 
   * @param entityId ID of the entity.
   * 
   * @param clientIndex
   */
  void Group_ReadGroupEntity(std::string& _return, const std::string& groupId, const std::string& entityId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ReadGroupEntity\n");
  }

  /**
   * Read the members of the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_ReadGroupMembers(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_ReadGroupMembers\n");
  }

  /**
   * Reject an outstanding invitation to join the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param clientIndex
   */
  void Group_RejectGroupInvitation(std::string& _return, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_RejectGroupInvitation\n");
  }

  /**
   * Reject an outstanding request to join the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the invitation being deleted.
   * 
   * @param clientIndex
   */
  void Group_RejectGroupJoinRequest(std::string& _return, const std::string& groupId, const std::string& profileId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_RejectGroupJoinRequest\n");
  }

  /**
   * Remove a member from the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the member being deleted.
   * 
   * @param clientIndex
   */
  void Group_RemoveGroupMember(std::string& _return, const std::string& groupId, const std::string& profileId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_RemoveGroupMember\n");
  }

  /**
   * Updates a group's data.
   * 
   * @param groupId ID of the group.
   * 
   * @param version Version to verify.
   * 
   * @param jsonData Data to apply.
   * 
   * @param clientIndex
   */
  void Group_UpdateGroupData(std::string& _return, const std::string& groupId, const int64_t version, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_UpdateGroupData\n");
  }

  /**
   * Update a group entity.
   * 
   * @param groupId ID of the group.
   * 
   * @param entityId ID of the entity.
   * 
   * @param version The current version of the group entity (for concurrency checking).
   * 
   * @param jsonData Custom application data.
   * 
   * @param clientIndex
   */
  void Group_UpdateGroupEntityData(std::string& _return, const std::string& groupId, const std::string& entityId, const int64_t version, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_UpdateGroupEntityData\n");
  }

  /**
   * Update a member of the group.
   * 
   * @param groupId ID of the group.
   * 
   * @param profileId Profile ID of the member being updated.
   * 
   * @param role Role of the member being updated (optional).
   * 
   * @param jsonAttributes Attributes of the member being updated (optional).
   * 
   * @param clientIndex
   */
  void Group_UpdateGroupMember(std::string& _return, const std::string& groupId, const std::string& profileId, const  ::Ruyi::SDK::BrainCloudApi::Role::type role, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_UpdateGroupMember\n");
  }

  /**
   * Updates a group's name.
   * 
   * @param groupId ID of the group.
   * 
   * @param name Name to apply.
   * 
   * @param clientIndex
   */
  void Group_UpdateGroupName(std::string& _return, const std::string& groupId, const std::string& name, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Group_UpdateGroupName\n");
  }

  /**
   * Attach a Email and Password identity to the current profile.
   * 
   * @param email The user's e-mail address
   * 
   * @param password The user's password
   * 
   * @param clientIndex
   */
  void Identity_AttachEmailIdentity(std::string& _return, const std::string& email, const std::string& password, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_AttachEmailIdentity\n");
  }

  /**
   * Merge the profile associated with the provided e=mail with the current profile.
   * 
   * @param email The user's e-mail address
   * 
   * @param password The user's password
   * 
   * @param clientIndex
   */
  void Identity_MergeEmailIdentity(std::string& _return, const std::string& email, const std::string& password, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_MergeEmailIdentity\n");
  }

  /**
   * Detach the e-mail identity from the current profile
   * 
   * @param email The user's e-mail address
   * 
   * @param continueAnon Proceed even if the profile will revert to anonymous?
   * 
   * @param clientIndex
   */
  void Identity_DetachEmailIdentity(std::string& _return, const std::string& email, const bool continueAnon, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_DetachEmailIdentity\n");
  }

  /**
   * Attach a Universal (userId + password) identity to the current profile.
   * 
   * @param userId The user's userId
   * 
   * @param password The user's password
   * 
   * @param clientIndex
   */
  void Identity_AttachUniversalIdentity(std::string& _return, const std::string& userId, const std::string& password, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_AttachUniversalIdentity\n");
  }

  /**
   * Merge the profile associated with the provided e=mail with the current profile.
   * 
   * @param userId The user's userId
   * 
   * @param password The user's password
   * 
   * @param clientIndex
   */
  void Identity_MergeUniversalIdentity(std::string& _return, const std::string& userId, const std::string& password, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_MergeUniversalIdentity\n");
  }

  /**
   * Detach the universal identity from the current profile
   * 
   * @param userId The user's userId
   * 
   * @param continueAnon Proceed even if the profile will revert to anonymous?
   * 
   * @param clientIndex
   */
  void Identity_DetachUniversalIdentity(std::string& _return, const std::string& userId, const bool continueAnon, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_DetachUniversalIdentity\n");
  }

  /**
   * Switch to a Child Profile
   * 
   * @param childProfileId The profileId of the child profile to switch to
   * If null and forceCreate is true a new profile will be created
   * 
   * @param childAppId The appId of the child game to switch to
   * 
   * @param forceCreate Should a new profile be created if it does not exist?
   * 
   * @param clientIndex
   */
  void Identity_SwitchToChildProfile(std::string& _return, const std::string& childProfileId, const std::string& childAppId, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_SwitchToChildProfile\n");
  }

  /**
   * Switches to the child profile of an app when only one profile exists
   * If multiple profiles exist this returns an error
   * 
   * @param childAppId The App ID of the child game to switch to
   * 
   * @param forceCreate Should a new profile be created if one does not exist?
   * 
   * @param clientIndex
   */
  void Identity_SwitchToSingletonChildProfile(std::string& _return, const std::string& childAppId, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_SwitchToSingletonChildProfile\n");
  }

  /**
   * Attach a new identity to a parent app
   * 
   * @param externalId User ID
   * 
   * @param authenticationToken Password or client side token
   * 
   * @param authenticationType Type of authentication
   * 
   * @param externalAuthName Optional - if using AuthenticationType of external
   * 
   * @param forceCreate If the profile does not exist, should it be created?
   * 
   * @param clientIndex
   */
  void Identity_AttachParentWithIdentity(std::string& _return, const std::string& externalId, const std::string& authenticationToken, const std::string& authenticationType, const std::string& externalAuthName, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_AttachParentWithIdentity\n");
  }

  /**
   * Switch to a Parent Profile
   * 
   * @param parentLevelName The level of the parent to switch to
   * 
   * @param clientIndex
   */
  void Identity_SwitchToParentProfile(std::string& _return, const std::string& parentLevelName, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_SwitchToParentProfile\n");
  }

  /**
   * Detaches parent from this user's profile
   * 
   * @param clientIndex
   */
  void Identity_DetachParent(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_DetachParent\n");
  }

  /**
   * Returns a list of all child profiles in child Apps
   * 
   * @param includeSummaryData Whether to return the summary friend data along with this call
   * 
   * @param clientIndex
   */
  void Identity_GetChildProfiles(std::string& _return, const bool includeSummaryData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_GetChildProfiles\n");
  }

  /**
   * Retrieve list of identities
   * 
   * @param clientIndex
   */
  void Identity_GetIdentities(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_GetIdentities\n");
  }

  /**
   * Retrieve list of expired identities
   * 
   * @param clientIndex
   */
  void Identity_GetExpiredIdentities(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_GetExpiredIdentities\n");
  }

  /**
   * Refreshes an identity for this user
   * 
   * @param externalId User ID
   * 
   * @param authenticationToken Password or client side token
   * 
   * @param authenticationType Type of authentication
   * 
   * @param clientIndex
   */
  void Identity_RefreshIdentity(std::string& _return, const std::string& externalId, const std::string& authenticationToken, const std::string& authenticationType, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_RefreshIdentity\n");
  }

  /**
   * Allows email identity email address to be changed
   * 
   * @param oldEmailAddress Old email address
   * 
   * @param password Password for identity
   * 
   * @param newEmailAddress New email address
   * 
   * @param updateContactEmail Whether to update contact email in profile
   * 
   * @param clientIndex
   */
  void Identity_ChangeEmailIdentity(std::string& _return, const std::string& oldEmailAddress, const std::string& password, const std::string& newEmailAddress, const bool updateContactEmail, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_ChangeEmailIdentity\n");
  }

  /**
   * Attaches a peer identity to this user's profile
   * 
   * @param peer Name of the peer to connect to
   * 
   * @param externalId User ID
   * 
   * @param authenticationToken Password or client side token
   * 
   * @param authenticationType Type of authentication
   * 
   * @param externalAuthName Optional - if using AuthenticationType of external
   * 
   * @param forceCreate If the profile does not exist, should it be created?
   * 
   * @param clientIndex
   */
  void Identity_AttachPeerProfile(std::string& _return, const std::string& peer, const std::string& externalId, const std::string& authenticationToken, const std::string& authenticationType, const std::string& externalAuthName, const bool forceCreate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_AttachPeerProfile\n");
  }

  /**
   * Detaches a peer identity from this user's profile
   * 
   * @param peer Name of the peer to connect to
   * 
   * @param clientIndex
   */
  void Identity_DetachPeer(std::string& _return, const std::string& peer, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_DetachPeer\n");
  }

  /**
   * Retrieves a list of attached peer profiles
   * 
   * @param clientIndex
   */
  void Identity_GetPeerProfiles(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Identity_GetPeerProfiles\n");
  }

  /**
   * Sends a simple text email to the specified user
   * 
   * @param profileId
   * @param subject The email subject
   * 
   * @param body The email body
   * 
   * @param clientIndex
   */
  void Mail_SendBasicEmail(std::string& _return, const std::string& profileId, const std::string& subject, const std::string& body, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Mail_SendBasicEmail\n");
  }

  /**
   * Sends an advanced email to the specified user
   * 
   * @param profileId
   * @param jsonServiceParams Parameters to send to the email service. See the documentation for
   * a full list. http://getbraincloud.com/apidocs/apiref/#capi-mail
   * 
   * @param clientIndex
   */
  void Mail_SendAdvancedEmail(std::string& _return, const std::string& profileId, const std::string& jsonServiceParams, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Mail_SendAdvancedEmail\n");
  }

  /**
   * Sends an advanced email to the specified email address
   * 
   * @param emailAddress The address to send the email to
   * 
   * @param jsonServiceParams Parameters to send to the email service. See the documentation for
   * a full list. http://getbraincloud.com/apidocs/apiref/#capi-mail
   * 
   * @param clientIndex
   */
  void Mail_SendAdvancedEmailByAddress(std::string& _return, const std::string& emailAddress, const std::string& jsonServiceParams, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Mail_SendAdvancedEmailByAddress\n");
  }

  /**
   * Read match making record
   * 
   * @param clientIndex
   */
  void MatchMaking_Read(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_Read\n");
  }

  /**
   * Sets player rating
   * 
   * @param playerRating The new player rating.
   * 
   * @param clientIndex
   */
  void MatchMaking_SetPlayerRating(std::string& _return, const int64_t playerRating, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_SetPlayerRating\n");
  }

  /**
   * Resets player rating
   * 
   * @param clientIndex
   */
  void MatchMaking_ResetPlayerRating(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_ResetPlayerRating\n");
  }

  /**
   * Increments player rating
   * 
   * @param increment The increment amount
   * 
   * @param clientIndex
   */
  void MatchMaking_IncrementPlayerRating(std::string& _return, const int64_t increment, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_IncrementPlayerRating\n");
  }

  /**
   * Decrements player rating
   * 
   * @param decrement The decrement amount
   * 
   * @param clientIndex
   */
  void MatchMaking_DecrementPlayerRating(std::string& _return, const int64_t decrement, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_DecrementPlayerRating\n");
  }

  /**
   * Turns shield on
   * 
   * @param clientIndex
   */
  void MatchMaking_TurnShieldOn(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_TurnShieldOn\n");
  }

  /**
   * Turns shield on for the specified number of minutes
   * 
   * @param minutes Number of minutes to turn the shield on for
   * 
   * @param clientIndex
   */
  void MatchMaking_TurnShieldOnFor(std::string& _return, const int32_t minutes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_TurnShieldOnFor\n");
  }

  /**
   * Turns shield off
   * 
   * @param clientIndex
   */
  void MatchMaking_TurnShieldOff(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_TurnShieldOff\n");
  }

  /**
   * Increases the shield on time by specified number of minutes
   * 
   * @param minutes Number of minutes to increase the shield time for
   * 
   * @param clientIndex
   */
  void MatchMaking_IncrementShieldOnFor(std::string& _return, const int32_t minutes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_IncrementShieldOnFor\n");
  }

  /**
   * Gets the shield expiry for the given player id. Passing in a null player id
   * will return the shield expiry for the current player. The value returned is
   * the time in UTC millis when the shield will expire.
   * 
   * @param playerId The player id or use null to retrieve for the current player
   * 
   * @param clientIndex
   */
  void MatchMaking_GetShieldExpiry(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_GetShieldExpiry\n");
  }

  /**
   * Finds matchmaking enabled players
   * 
   * @param rangeDelta The range delta
   * 
   * @param numMatches The maximum number of matches to return
   * 
   * @param clientIndex
   */
  void MatchMaking_FindPlayers(std::string& _return, const int64_t rangeDelta, const int64_t numMatches, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_FindPlayers\n");
  }

  /**
   * Finds matchmaking enabled players with additional attributes
   * 
   * @param rangeDelta The range delta
   * 
   * @param numMatches The maximum number of matches to return
   * 
   * @param jsonAttributes Attributes match criteria
   * 
   * @param clientIndex
   */
  void MatchMaking_FindPlayersWithAttributes(std::string& _return, const int64_t rangeDelta, const int64_t numMatches, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_FindPlayersWithAttributes\n");
  }

  /**
   * Finds matchmaking enabled players using a cloud code filter
   * 
   * @param rangeDelta The range delta
   * 
   * @param numMatches The maximum number of matches to return
   * 
   * @param jsonExtraParms Parameters to pass to the CloudCode filter script
   * 
   * @param clientIndex
   */
  void MatchMaking_FindPlayersUsingFilter(std::string& _return, const int64_t rangeDelta, const int64_t numMatches, const std::string& jsonExtraParms, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_FindPlayersUsingFilter\n");
  }

  /**
   * Finds matchmaking enabled players using a cloud code filter
   * and additional attributes
   * 
   * @param rangeDelta The range delta
   * 
   * @param numMatches The maximum number of matches to return
   * 
   * @param jsonAttributes Attributes match criteria
   * 
   * @param jsonExtraParms Parameters to pass to the CloudCode filter script
   * 
   * @param clientIndex
   */
  void MatchMaking_FindPlayersWithAttributesUsingFilter(std::string& _return, const int64_t rangeDelta, const int64_t numMatches, const std::string& jsonAttributes, const std::string& jsonExtraParms, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_FindPlayersWithAttributesUsingFilter\n");
  }

  /**
   * Enables Match Making for the Player
   * 
   * @param clientIndex
   */
  void MatchMaking_EnableMatchMaking(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_EnableMatchMaking\n");
  }

  /**
   * Disables Match Making for the Player
   * 
   * @param clientIndex
   */
  void MatchMaking_DisableMatchMaking(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("MatchMaking_DisableMatchMaking\n");
  }

  /**
   * Starts a match
   * 
   * @param otherPlayerId The player to start a match with
   * 
   * @param rangeDelta The range delta used for the initial match search
   * 
   * @param clientIndex
   */
  void OneWayMatch_StartMatch(std::string& _return, const std::string& otherPlayerId, const int64_t rangeDelta, const int32_t clientIndex) {
    // Your implementation goes here
    printf("OneWayMatch_StartMatch\n");
  }

  /**
   * Cancels a match
   * 
   * @param playbackStreamId The playback stream id returned in the start match
   * 
   * @param clientIndex
   */
  void OneWayMatch_CancelMatch(std::string& _return, const std::string& playbackStreamId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("OneWayMatch_CancelMatch\n");
  }

  /**
   * Completes a match
   * 
   * @param playbackStreamId The playback stream id returned in the initial start match
   * 
   * @param clientIndex
   */
  void OneWayMatch_CompleteMatch(std::string& _return, const std::string& playbackStreamId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("OneWayMatch_CompleteMatch\n");
  }

  /**
   * Starts a stream
   * 
   * @param targetPlayerId The player to start a stream with
   * 
   * @param includeSharedData Whether to include shared data in the stream
   * 
   * @param clientIndex
   */
  void PlaybackStream_StartStream(std::string& _return, const std::string& targetPlayerId, const bool includeSharedData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_StartStream\n");
  }

  /**
   * Reads a stream
   * 
   * @param playbackStreamId Identifies the stream to read
   * 
   * @param clientIndex
   */
  void PlaybackStream_ReadStream(std::string& _return, const std::string& playbackStreamId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_ReadStream\n");
  }

  /**
   * Ends a stream
   * 
   * @param playbackStreamId Identifies the stream to read
   * 
   * @param clientIndex
   */
  void PlaybackStream_EndStream(std::string& _return, const std::string& playbackStreamId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_EndStream\n");
  }

  /**
   * Deletes a stream
   * 
   * @param playbackStreamId Identifies the stream to read
   * 
   * @param clientIndex
   */
  void PlaybackStream_DeleteStream(std::string& _return, const std::string& playbackStreamId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_DeleteStream\n");
  }

  /**
   * Adds a stream event
   * 
   * @param playbackStreamId Identifies the stream to read
   * 
   * @param eventData Describes the event
   * 
   * @param summary Current summary data as of this event
   * 
   * @param clientIndex
   */
  void PlaybackStream_AddEvent(std::string& _return, const std::string& playbackStreamId, const std::string& eventData, const std::string& summary, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_AddEvent\n");
  }

  /**
   * Gets recent streams for initiating player
   * 
   * @param initiatingPlayerId The player that started the stream
   * 
   * @param maxNumStreams The player that started the stream
   * 
   * @param clientIndex
   */
  void PlaybackStream_GetRecentStreamsForInitiatingPlayer(std::string& _return, const std::string& initiatingPlayerId, const int32_t maxNumStreams, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_GetRecentStreamsForInitiatingPlayer\n");
  }

  /**
   * Gets recent streams for target player
   * 
   * @param targetPlayerId The player that started the stream
   * 
   * @param maxNumStreams The player that started the stream
   * 
   * @param clientIndex
   */
  void PlaybackStream_GetRecentStreamsForTargetPlayer(std::string& _return, const std::string& targetPlayerId, const int32_t maxNumStreams, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlaybackStream_GetRecentStreamsForTargetPlayer\n");
  }

  /**
   * Read the state of the currently logged in user.
   * This method returns a JSON object describing most of the
   * player's data: entities, statistics, level, currency.
   * Apps will typically call this method after authenticating to get an
   * up-to-date view of the user's data.
   * 
   * @param clientIndex
   */
  void PlayerState_ReadUserState(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_ReadUserState\n");
  }

  /**
   * Completely deletes the user record and all data fully owned
   * by the user. After calling this method, the user will need
   * to re-authenticate and create a new profile.
   * This is mostly used for debugging/qa.
   * 
   * @param clientIndex
   */
  void PlayerState_DeleteUser(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_DeleteUser\n");
  }

  /**
   * This method will delete *most* data for the currently logged in user.
   * Data which is not deleted includes: currency, credentials, and
   * purchase transactions. ResetUser is different from DeleteUser in that
   * the player record will continue to exist after the reset (so the user
   * does not need to re-authenticate).
   * 
   * @param clientIndex
   */
  void PlayerState_ResetUser(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_ResetUser\n");
  }

  /**
   * Logs user out of server.
   * 
   * @param clientIndex
   */
  void PlayerState_Logout(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_Logout\n");
  }

  /**
   * Sets the user name.
   * 
   * @param userName The name of the user
   * 
   * @param clientIndex
   */
  void PlayerState_UpdateUserName(std::string& _return, const std::string& userName, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_UpdateUserName\n");
  }

  /**
   * Updates the "friend summary data" associated with the logged in user.
   * Some operations will return this summary data. For instance the social
   * leaderboards will return the player's score in the leaderboard along
   * with the friend summary data. Generally this data is used to provide
   * a quick overview of the player without requiring a separate API call
   * to read their public stats or entity data.
   * 
   * @param jsonSummaryData A JSON string defining the summary data.
   * For example:
   * {
   *   "xp":123,
   *   "level":12,
   *   "highScore":45123
   * }
   * 
   * @param clientIndex
   */
  void PlayerState_UpdateSummaryFriendData(std::string& _return, const std::string& jsonSummaryData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_UpdateSummaryFriendData\n");
  }

  /**
   * Retrieve the user's attributes.
   * 
   * @param clientIndex
   */
  void PlayerState_GetAttributes(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_GetAttributes\n");
  }

  /**
   * Update user's attributes.
   * 
   * @param jsonAttributes Single layer json string that is a set of key-value pairs
   * 
   * @param wipeExisting Whether to wipe existing attributes prior to update.
   * 
   * @param clientIndex
   */
  void PlayerState_UpdateAttributes(std::string& _return, const std::string& jsonAttributes, const bool wipeExisting, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_UpdateAttributes\n");
  }

  /**
   * Remove user's attributes.
   * 
   * @param attributeNames List of attribute names.
   * 
   * @param clientIndex
   */
  void PlayerState_RemoveAttributes(std::string& _return, const std::vector<std::string> & attributeNames, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_RemoveAttributes\n");
  }

  /**
   * Updates player's picture URL.
   * 
   * @param pictureUrl URL to apply.
   * 
   * @param clientIndex
   */
  void PlayerState_UpdateUserPictureUrl(std::string& _return, const std::string& pictureUrl, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_UpdateUserPictureUrl\n");
  }

  /**
   * Update the user's contact email.
   * Note this is unrelated to email authentication.
   * 
   * @param contactEmail Updated email
   * 
   * @param clientIndex
   */
  void PlayerState_UpdateContactEmail(std::string& _return, const std::string& contactEmail, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerState_UpdateContactEmail\n");
  }

  /**
   * Read all available user statistics.
   * 
   * @param clientIndex
   */
  void PlayerStatistics_ReadAllUserStats(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_ReadAllUserStats\n");
  }

  /**
   * Reads a subset of user statistics as defined by the input JSON.
   * 
   * @param playerStats
   * @param clientIndex
   */
  void PlayerStatistics_ReadUserStatsSubset(std::string& _return, const std::vector<std::string> & playerStats, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_ReadUserStatsSubset\n");
  }

  /**
   * Method retrieves the user statistics for the given category.
   * 
   * @param category The user statistics category
   * 
   * @param clientIndex
   */
  void PlayerStatistics_ReadUserStatsForCategory(std::string& _return, const std::string& category, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_ReadUserStatsForCategory\n");
  }

  /**
   * Reset all of the statistics for this user back to their initial value.
   * 
   * @param clientIndex
   */
  void PlayerStatistics_ResetAllUserStats(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_ResetAllUserStats\n");
  }

  /**
   * Atomically increment (or decrement) user statistics.
   * Any rewards that are triggered from user statistic increments
   * will be considered. User statistics are defined through the brainCloud portal.
   * Note also that the "xpCapped" property is returned (true/false depending on whether
   * the xp cap is turned on and whether the user has hit it).
   * 
   * @param jsonData The JSON encoded data to be sent to the server as follows:
   * {
   *   stat1: 10,
   *   stat2: -5.5,
   * }
   * would increment stat1 by 10 and decrement stat2 by 5.5.
   * For the full statistics grammer see the api.braincloudservers.com site.
   * There are many more complex operations supported such as:
   * {
   *   stat1:INC_TO_LIMIT#9#30
   * }
   * which increments stat1 by 9 up to a limit of 30.
   * 
   * @param clientIndex
   */
  void PlayerStatistics_IncrementUserStats_SSFO(std::string& _return, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_IncrementUserStats_SSFO\n");
  }

  /**
   * Atomically increment (or decrement) user statistics.
   * Any rewards that are triggered from user statistic increments
   * will be considered. User statistics are defined through the brainCloud portal.
   * Note also that the "xpCapped" property is returned (true/false depending on whether
   * the xp cap is turned on and whether the user has hit it).
   * 
   * @param dictData Stats name and their increments:
   * {
   *  {"stat1", 10},
   *  {"stat1", -5}
   * }
   * 
   * would increment stat1 by 10 and decrement stat2 by 5.
   * For the full statistics grammer see the api.braincloudservers.com site.
   * There are many more complex operations supported such as:
   * {
   *   stat1:INC_TO_LIMIT#9#30
   * }
   * which increments stat1 by 9 up to a limit of 30.
   * 
   * @param clientIndex
   */
  void PlayerStatistics_IncrementUserStats_DSFO(std::string& _return, const std::map<std::string,  ::Ruyi::SDK::BrainCloudApi::JSON> & dictData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_IncrementUserStats_DSFO\n");
  }

  /**
   * Apply statistics grammar to a partial set of statistics.
   * 
   * @param statisticsData Example data to be passed to method:
   * {
   *     "DEAD_CATS": "RESET",
   *     "LIVES_LEFT": "SET#9",
   *     "MICE_KILLED": "INC#2",
   *     "DOG_SCARE_BONUS_POINTS": "INC#10",
   *     "TREES_CLIMBED": 1
   * }
   * 
   * @param clientIndex
   */
  void PlayerStatistics_ProcessStatistics(std::string& _return, const std::map<std::string,  ::Ruyi::SDK::BrainCloudApi::JSON> & statisticsData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_ProcessStatistics\n");
  }

  /**
   * Returns JSON representing the next experience level for the user.
   * 
   * @param clientIndex
   */
  void PlayerStatistics_GetNextExperienceLevel(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_GetNextExperienceLevel\n");
  }

  /**
   * Increments the user's experience. If the user goes up a level,
   * the new level details will be returned along with a list of rewards.
   * 
   * @param xpValue The amount to increase the user's experience by
   * 
   * @param clientIndex
   */
  void PlayerStatistics_IncrementExperiencePoints(std::string& _return, const int32_t xpValue, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_IncrementExperiencePoints\n");
  }

  /**
   * Sets the user's experience to an absolute value. Note that this
   * is simply a set and will not reward the user if their level changes
   * as a result.
   * 
   * @param xpValue The amount to set the the player's experience to
   * 
   * @param clientIndex
   */
  void PlayerStatistics_SetExperiencePoints(std::string& _return, const int32_t xpValue, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatistics_SetExperiencePoints\n");
  }

  /**
   * Trigger an event server side that will increase the user statistics.
   * This may cause one or more awards to be sent back to the user -
   * could be achievements, experience, etc. Achievements will be sent by this
   * client library to the appropriate awards service (Apple Game Center, etc).
   * 
   * This mechanism supercedes the PlayerStatisticsService API methods, since
   * PlayerStatisticsService API method only update the raw statistics without
   * triggering the rewards.
   * 
   * @param eventName
   * @param eventMultiplier
   * @param clientIndex
   */
  void PlayerStatisticsEvent_TriggerStatsEvent(std::string& _return, const std::string& eventName, const int32_t eventMultiplier, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatisticsEvent_TriggerStatsEvent\n");
  }

  /**
   * See documentation for TriggerStatsEvent for more
   * documentation.
   * 
   * @param jsonData jsonData
   * [
   *   {
   *     "eventName": "event1",
   *     "eventMultiplier": 1
   *   },
   *   {
   *     "eventName": "event2",
   *     "eventMultiplier": 1
   *   }
   * ]
   * 
   * @param clientIndex
   */
  void PlayerStatisticsEvent_TriggerStatsEvents(std::string& _return, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PlayerStatisticsEvent_TriggerStatsEvents\n");
  }

  /**
   * Gets the player's currency for the given currency type
   * or all currency types if null passed in.
   * 
   * @param currencyType The currency type to retrieve or null
   * if all currency types are being requested.
   * 
   * @param clientIndex
   */
  void Product_GetCurrency(std::string& _return, const std::string& currencyType, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Product_GetCurrency\n");
  }

  /**
   * Method gets the active sales inventory for the passed-in
   * currency type.
   * 
   * @param platform The store platform. Valid stores are:
   * - itunes
   * - facebook
   * - appworld
   * - steam
   * - windows
   * - windowsPhone
   * - googlePlay
   * 
   * @param userCurrency The currency to retrieve the sales
   * inventory for. This is only used for Steam and Facebook stores.
   * 
   * @param clientIndex
   */
  void Product_GetSalesInventory(std::string& _return, const std::string& platform, const std::string& userCurrency, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Product_GetSalesInventory\n");
  }

  /**
   * Method gets the active sales inventory for the passed-in
   * currency type and category.
   * 
   * @param platform The store platform. Valid stores are:
   * - itunes
   * - facebook
   * - appworld
   * - steam
   * - windows
   * - windowsPhone
   * - googlePlay
   * 
   * @param userCurrency The currency to retrieve the sales
   * inventory for. This is only used for Steam and Facebook stores.
   * 
   * @param category The product category
   * 
   * @param clientIndex
   */
  void Product_GetSalesInventoryByCategory(std::string& _return, const std::string& platform, const std::string& userCurrency, const std::string& category, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Product_GetSalesInventoryByCategory\n");
  }

  /**
   * Verify Microsoft Receipt. On success, the player will be awarded the
   * associated currencies.
   * 
   * @param receipt Receipt XML
   * 
   * @param clientIndex
   */
  void Product_VerifyMicrosoftReceipt(std::string& _return, const std::string& receipt, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Product_VerifyMicrosoftReceipt\n");
  }

  /**
   * Returns the eligible promotions for the player.
   * 
   * @param clientIndex
   */
  void Product_GetEligiblePromotions(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Product_GetEligiblePromotions\n");
  }

  /**
   * Verify ITunes Receipt. On success, the player will be awarded the
   * associated currencies.
   * 
   * @param base64EncReceiptData Base64 encoded receipt data
   * 
   * @param clientIndex
   */
  void Product_VerifyItunesReceipt(std::string& _return, const std::string& base64EncReceiptData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Product_VerifyItunesReceipt\n");
  }

  /**
   * Checks supplied text for profanity.
   * 
   * @param text The text to check
   * 
   * @param languages Optional comma delimited list of two character language codes
   * 
   * @param flagEmail Optional processing of email addresses
   * 
   * @param flagPhone Optional processing of phone numbers
   * 
   * @param flagUrls Optional processing of urls
   * 
   * @param clientIndex
   */
  void Profanity_ProfanityCheck(std::string& _return, const std::string& text, const std::string& languages, const bool flagEmail, const bool flagPhone, const bool flagUrls, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Profanity_ProfanityCheck\n");
  }

  /**
   * Replaces the characters of profanity text with a passed character(s).
   * 
   * @param text The text to check
   * 
   * @param replaceSymbol The text to replace individual characters of profanity text with
   * 
   * @param languages Optional comma delimited list of two character language codes
   * 
   * @param flagEmail Optional processing of email addresses
   * 
   * @param flagPhone Optional processing of phone numbers
   * 
   * @param flagUrls Optional processing of urls
   * 
   * @param clientIndex
   */
  void Profanity_ProfanityReplaceText(std::string& _return, const std::string& text, const std::string& replaceSymbol, const std::string& languages, const bool flagEmail, const bool flagPhone, const bool flagUrls, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Profanity_ProfanityReplaceText\n");
  }

  /**
   * Checks supplied text for profanity and returns a list of bad wors.
   * 
   * @param text The text to check
   * 
   * @param languages Optional comma delimited list of two character language codes
   * 
   * @param flagEmail Optional processing of email addresses
   * 
   * @param flagPhone Optional processing of phone numbers
   * 
   * @param flagUrls Optional processing of urls
   * 
   * @param clientIndex
   */
  void Profanity_ProfanityIdentifyBadWords(std::string& _return, const std::string& text, const std::string& languages, const bool flagEmail, const bool flagPhone, const bool flagUrls, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Profanity_ProfanityIdentifyBadWords\n");
  }

  /**
   * Deregisters all device tokens currently registered to the user.
   * 
   * @param clientIndex
   */
  void PushNotification_DeregisterAllPushNotificationDeviceTokens(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_DeregisterAllPushNotificationDeviceTokens\n");
  }

  /**
   * Deregisters the given device token from the server to disable this device
   * from receiving push notifications.
   * 
   * @param platform The device platform being registered.
   * 
   * @param token The platform-dependant device token needed for push notifications.
   * 
   * @param clientIndex
   */
  void PushNotification_DeregisterPushNotificationDeviceToken(std::string& _return, const std::string& platform, const std::string& token, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_DeregisterPushNotificationDeviceToken\n");
  }

  /**
   * Registers the given device token with the server to enable this device
   * to receive push notifications.
   * 
   * @param platform
   * @param token The platform-dependant device token needed for push notifications.
   * 
   * @param clientIndex
   */
  void PushNotification_RegisterPushNotificationDeviceToken(std::string& _return, const std::string& platform, const std::string& token, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_RegisterPushNotificationDeviceToken\n");
  }

  /**
   * Sends a simple push notification based on the passed in message.
   * NOTE: It is possible to send a push notification to oneself.
   * 
   * @param toProfileId The braincloud profileId of the user to receive the notification
   * 
   * @param message Text of the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_SendSimplePushNotification(std::string& _return, const std::string& toProfileId, const std::string& message, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendSimplePushNotification\n");
  }

  /**
   * Sends a notification to a user based on a brainCloud portal configured notification template.
   * NOTE: It is possible to send a push notification to oneself.
   * 
   * @param toProfileId The braincloud profileId of the user to receive the notification
   * 
   * @param notificationTemplateId Id of the notification template
   * 
   * @param clientIndex
   */
  void PushNotification_SendRichPushNotification(std::string& _return, const std::string& toProfileId, const int32_t notificationTemplateId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendRichPushNotification\n");
  }

  /**
   * Sends a notification to a user based on a brainCloud portal configured notification template.
   * Includes JSON defining the substitution params to use with the template.
   * See the Portal documentation for more info.
   * NOTE: It is possible to send a push notification to oneself.
   * 
   * @param toProfileId The braincloud profileId of the user to receive the notification
   * 
   * @param notificationTemplateId Id of the notification template
   * 
   * @param substitutionJson JSON defining the substitution params to use with the template
   * 
   * @param clientIndex
   */
  void PushNotification_SendRichPushNotificationWithParams(std::string& _return, const std::string& toProfileId, const int32_t notificationTemplateId, const std::string& substitutionJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendRichPushNotificationWithParams\n");
  }

  /**
   * Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
   * Includes JSON defining the substitution params to use with the template.
   * See the Portal documentation for more info.
   * 
   * @param groupId Target group
   * 
   * @param notificationTemplateId Id of the notification template
   * 
   * @param substitutionsJson JSON defining the substitution params to use with the template
   * 
   * @param clientIndex
   */
  void PushNotification_SendTemplatedPushNotificationToGroup(std::string& _return, const std::string& groupId, const int32_t notificationTemplateId, const std::string& substitutionsJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendTemplatedPushNotificationToGroup\n");
  }

  /**
   * Sends a notification to a "group" of user based on a brainCloud portal configured notification template.
   * Includes JSON defining the substitution params to use with the template.
   * See the Portal documentation for more info.
   * 
   * @param groupId Target group
   * 
   * @param alertContentJson Body and title of alert
   * 
   * @param customDataJson Optional custom data
   * 
   * @param clientIndex
   */
  void PushNotification_SendNormalizedPushNotificationToGroup(std::string& _return, const std::string& groupId, const std::string& alertContentJson, const std::string& customDataJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendNormalizedPushNotificationToGroup\n");
  }

  /**
   * Schedules raw notifications based on user local time.
   * 
   * @param profileId The profileId of the user to receive the notification
   * 
   * @param fcmContent Valid Fcm data content
   * 
   * @param iosContent Valid ios data content
   * 
   * @param facebookContent Facebook template string
   * 
   * @param startTime Start time of sending the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_ScheduleRawPushNotificationUTC(std::string& _return, const std::string& profileId, const std::string& fcmContent, const std::string& iosContent, const std::string& facebookContent, const int32_t startTime, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_ScheduleRawPushNotificationUTC\n");
  }

  /**
   * Schedules raw notifications based on user local time.
   * 
   * @param profileId The profileId of the user to receive the notification
   * 
   * @param fcmContent Valid Fcm data content
   * 
   * @param iosContent Valid ios data content
   * 
   * @param facebookContent Facebook template string
   * 
   * @param minutesFromNow Minutes from now to send the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_ScheduleRawPushNotificationMinutes(std::string& _return, const std::string& profileId, const std::string& fcmContent, const std::string& iosContent, const std::string& facebookContent, const int32_t minutesFromNow, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_ScheduleRawPushNotificationMinutes\n");
  }

  /**
   * Sends a raw push notification to a target user.
   * 
   * @param toProfileId The profileId of the user to receive the notification
   * 
   * @param fcmContent Valid Fcm data content
   * 
   * @param iosContent Valid ios data content
   * 
   * @param facebookContent Facebook template string
   * 
   * @param clientIndex
   */
  void PushNotification_SendRawPushNotification(std::string& _return, const std::string& toProfileId, const std::string& fcmContent, const std::string& iosContent, const std::string& facebookContent, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendRawPushNotification\n");
  }

  /**
   * Sends a raw push notification to a target list of users.
   * 
   * @param profileIds Collection of profile IDs to send the notification to
   * 
   * @param fcmContent Valid Fcm data content
   * 
   * @param iosContent Valid ios data content
   * 
   * @param facebookContent Facebook template string
   * 
   * @param clientIndex
   */
  void PushNotification_SendRawPushNotificationBatch(std::string& _return, const std::vector<std::string> & profileIds, const std::string& fcmContent, const std::string& iosContent, const std::string& facebookContent, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendRawPushNotificationBatch\n");
  }

  /**
   * Sends a raw push notification to a target group.
   * 
   * @param groupId Target group
   * 
   * @param fcmContent Valid Fcm data content
   * 
   * @param iosContent Valid ios data content
   * 
   * @param facebookContent Facebook template string
   * 
   * @param clientIndex
   */
  void PushNotification_SendRawPushNotificationToGroup(std::string& _return, const std::string& groupId, const std::string& fcmContent, const std::string& iosContent, const std::string& facebookContent, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendRawPushNotificationToGroup\n");
  }

  /**
   * Schedules a normalized push notification to a user
   * 
   * @param profileId The profileId of the user to receive the notification
   * 
   * @param alertContentJson Body and title of alert
   * 
   * @param customDataJson Optional custom data
   * 
   * @param startTime Start time of sending the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_ScheduleNormalizedPushNotificationUTC(std::string& _return, const std::string& profileId, const std::string& alertContentJson, const std::string& customDataJson, const int32_t startTime, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_ScheduleNormalizedPushNotificationUTC\n");
  }

  /**
   * Schedules a normalized push notification to a user
   * 
   * @param profileId The profileId of the user to receive the notification
   * 
   * @param alertContentJson Body and title of alert
   * 
   * @param customDataJson Optional custom data
   * 
   * @param minutesFromNow Minutes from now to send the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_ScheduleNormalizedPushNotificationMinutes(std::string& _return, const std::string& profileId, const std::string& alertContentJson, const std::string& customDataJson, const int32_t minutesFromNow, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_ScheduleNormalizedPushNotificationMinutes\n");
  }

  /**
   * Schedules a rich push notification to a user
   * 
   * @param profileId The profileId of the user to receive the notification
   * 
   * @param notificationTemplateId Body and title of alert
   * 
   * @param substitutionsJson Optional custom data
   * 
   * @param startTime Start time of sending the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_ScheduleRichPushNotificationUTC(std::string& _return, const std::string& profileId, const int32_t notificationTemplateId, const std::string& substitutionsJson, const int32_t startTime, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_ScheduleRichPushNotificationUTC\n");
  }

  /**
   * Schedules a rich push notification to a user
   * 
   * @param profileId The profileId of the user to receive the notification
   * 
   * @param notificationTemplateId Body and title of alert
   * 
   * @param substitutionsJson Optional custom data
   * 
   * @param minutesFromNow Minutes from now to send the push notification
   * 
   * @param clientIndex
   */
  void PushNotification_ScheduleRichPushNotificationMinutes(std::string& _return, const std::string& profileId, const int32_t notificationTemplateId, const std::string& substitutionsJson, const int32_t minutesFromNow, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_ScheduleRichPushNotificationMinutes\n");
  }

  /**
   * Sends a notification to a user consisting of alert content and custom data.
   * 
   * @param toProfileId The profileId of the user to receive the notification
   * 
   * @param alertContentJson Body and title of alert
   * 
   * @param customDataJson Optional custom data
   * 
   * @param clientIndex
   */
  void PushNotification_SendNormalizedPushNotification(std::string& _return, const std::string& toProfileId, const std::string& alertContentJson, const std::string& customDataJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendNormalizedPushNotification\n");
  }

  /**
   * Sends a notification to multiple users consisting of alert content and custom data.
   * 
   * @param profileIds Collection of profile IDs to send the notification to
   * 
   * @param alertContentJson Body and title of alert
   * 
   * @param customDataJson Optional custom data
   * 
   * @param clientIndex
   */
  void PushNotification_SendNormalizedPushNotificationBatch(std::string& _return, const std::vector<std::string> & profileIds, const std::string& alertContentJson, const std::string& customDataJson, const int32_t clientIndex) {
    // Your implementation goes here
    printf("PushNotification_SendNormalizedPushNotificationBatch\n");
  }

  /**
   * Executes a script on the server.
   * 
   * @param scriptName The name of the script to be run
   * 
   * @param jsonScriptData Data to be sent to the script in json format
   * 
   * @param clientIndex
   */
  void Script_RunScript(std::string& _return, const std::string& scriptName, const std::string& jsonScriptData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_RunScript\n");
  }

  /**
   * Allows cloud script executions to be scheduled
   * 
   * @param scriptName Name of script
   * 
   * @param jsonScriptData JSON bundle to pass to script
   * 
   * @param startDateInUTC The start date as a DateTime object
   * 
   * @param clientIndex
   */
  void Script_ScheduleRunScriptUTC(std::string& _return, const std::string& scriptName, const std::string& jsonScriptData, const  ::Ruyi::SDK::BrainCloudApi::date startDateInUTC, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_ScheduleRunScriptUTC\n");
  }

  /**
   * Allows cloud script executions to be scheduled
   * 
   * @param scriptName Name of script
   * 
   * @param jsonScriptData JSON bundle to pass to script
   * 
   * @param minutesFromNow Number of minutes from now to run script
   * 
   * @param clientIndex
   */
  void Script_ScheduleRunScriptMinutes(std::string& _return, const std::string& scriptName, const std::string& jsonScriptData, const int64_t minutesFromNow, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_ScheduleRunScriptMinutes\n");
  }

  /**
   * Run a cloud script in a parent app
   * 
   * @param scriptName Name of script
   * 
   * @param jsonScriptData JSON bundle to pass to script
   * 
   * @param parentLevel The level name of the parent to run the script from
   * 
   * @param clientIndex
   */
  void Script_RunParentScript(std::string& _return, const std::string& scriptName, const std::string& jsonScriptData, const std::string& parentLevel, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_RunParentScript\n");
  }

  /**
   * Cancels a scheduled cloud code script
   * 
   * @param jobId ID of script job to cancel
   * 
   * @param clientIndex
   */
  void Script_CancelScheduledScript(std::string& _return, const std::string& jobId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_CancelScheduledScript\n");
  }

  /**
   * Runs a script from the context of a peer
   * 
   * @param scriptName The name of the script to run
   * 
   * @param jsonScriptData JSON data to pass into the script
   * 
   * @param peer Identifies the peer
   * 
   * @param clientIndex
   */
  void Script_RunPeerScript(std::string& _return, const std::string& scriptName, const std::string& jsonScriptData, const std::string& peer, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_RunPeerScript\n");
  }

  /**
   * Runs a script asynchronously from the context of a peer
   * This operation does not wait for the script to complete before returning
   * 
   * @param scriptName The name of the script to run
   * 
   * @param jsonScriptData JSON data to pass into the script
   * 
   * @param peer Identifies the peer
   * 
   * @param clientIndex
   */
  void Script_RunPeerScriptAsynch(std::string& _return, const std::string& scriptName, const std::string& jsonScriptData, const std::string& peer, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Script_RunPeerScriptAsynch\n");
  }

  /**
   * Method returns the social leaderboard. A player's social leaderboard is
   * comprised of players who are recognized as being your friend.
   * For now, this applies solely to Facebook connected players who are
   * friends with the logged in player (who also must be Facebook connected).
   * In the future this will expand to other identification means (such as
   * Game Centre, Google circles etc).
   * 
   * Leaderboards entries contain the player's score and optionally, some user-defined
   * data associated with the score. The currently logged in player will also
   * be returned in the social leaderboard.
   * 
   * Note: If no friends have played the game, the bestScore, createdAt, updatedAt
   * will contain NULL.
   * 
   * @param leaderboardId The id of the leaderboard to retrieve
   * 
   * @param replaceName If true, the currently logged in player's name will be replaced
   * by the string "You".
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetSocialLeaderboard(std::string& _return, const std::string& leaderboardId, const bool replaceName, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetSocialLeaderboard\n");
  }

  /**
   * Reads multiple social leaderboards.
   * 
   * @param leaderboardIds Array of leaderboard id strings
   * 
   * @param leaderboardResultCount Maximum count of entries to return for each leaderboard.
   * 
   * @param replaceName If true, the currently logged in player's name will be replaced
   * by the string "You".
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetMultiSocialLeaderboard(std::string& _return, const std::vector<std::string> & leaderboardIds, const int32_t leaderboardResultCount, const bool replaceName, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetMultiSocialLeaderboard\n");
  }

  /**
   * Method returns a page of global leaderboard results.
   * 
   * Leaderboards entries contain the player's score and optionally, some user-defined
   * data associated with the score.
   * 
   * Note: This method allows the client to retrieve pages from within the global leaderboard list
   * 
   * @param leaderboardId The id of the leaderboard to retrieve.
   * 
   * @param sort Sort key Sort order of page.
   * 
   * @param startIndex The index at which to start the page.
   * 
   * @param endIndex The index at which to end the page.
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardPage(std::string& _return, const std::string& leaderboardId, const  ::Ruyi::SDK::BrainCloudApi::SortOrder::type sort, const int32_t startIndex, const int32_t endIndex, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardPage\n");
  }

  /**
   * Method returns a page of global leaderboard results. By using a non-current version id,
   * the user can retrieve a historical leaderboard. See GetGlobalLeaderboardVersions method
   * to retrieve the version id.
   * 
   * @param leaderboardId The id of the leaderboard to retrieve.
   * 
   * @param sort Sort key Sort order of page.
   * 
   * @param startIndex The index at which to start the page.
   * 
   * @param endIndex The index at which to end the page.
   * 
   * @param versionId The historical version to retrieve.
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardPageByVersion(std::string& _return, const std::string& leaderboardId, const  ::Ruyi::SDK::BrainCloudApi::SortOrder::type sort, const int32_t startIndex, const int32_t endIndex, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardPageByVersion\n");
  }

  /**
   * Method returns a view of global leaderboard results that centers on the current player.
   * 
   * Leaderboards entries contain the player's score and optionally, some user-defined
   * data associated with the score.
   * 
   * @param leaderboardId The id of the leaderboard to retrieve.
   * 
   * @param sort Sort key Sort order of page.
   * 
   * @param beforeCount The count of number of players before the current player to include.
   * 
   * @param afterCount The count of number of players after the current player to include.
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardView(std::string& _return, const std::string& leaderboardId, const  ::Ruyi::SDK::BrainCloudApi::SortOrder::type sort, const int32_t beforeCount, const int32_t afterCount, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardView\n");
  }

  /**
   * Method returns a view of global leaderboard results that centers on the current player.
   * By using a non-current version id, the user can retrieve a historical leaderboard.
   * See GetGlobalLeaderboardVersions method to retrieve the version id.
   * 
   * @param leaderboardId The id of the leaderboard to retrieve.
   * 
   * @param sort Sort key Sort order of page.
   * 
   * @param beforeCount The count of number of players before the current player to include.
   * 
   * @param afterCount The count of number of players after the current player to include.
   * 
   * @param versionId The historial version to retrieve. Use -1 for current leaderboard.
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardViewByVersion(std::string& _return, const std::string& leaderboardId, const  ::Ruyi::SDK::BrainCloudApi::SortOrder::type sort, const int32_t beforeCount, const int32_t afterCount, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardViewByVersion\n");
  }

  /**
   * Gets the global leaderboard versions.
   * 
   * @param leaderboardId In_leaderboard identifier.
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardVersions(std::string& _return, const std::string& leaderboardId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardVersions\n");
  }

  /**
   * Retrieve the social leaderboard for a group.
   * 
   * @param leaderboardId The leaderboard to read
   * 
   * @param groupId The group ID
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGroupSocialLeaderboard(std::string& _return, const std::string& leaderboardId, const std::string& groupId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGroupSocialLeaderboard\n");
  }

  /**
   * Post the players score to the given social leaderboard.
   * You can optionally send a user-defined json string of data
   * with the posted score. This string could include information
   * relevant to the posted score.
   * 
   * Note that the behaviour of posting a score can be modified in
   * the brainCloud portal. By default, the server will only keep
   * the player's best score.
   * 
   * @param leaderboardId The leaderboard to post to
   * 
   * @param score The score to post
   * 
   * @param jsonData
   * @param clientIndex
   */
  void SocialLeaderboard_PostScoreToLeaderboard(std::string& _return, const std::string& leaderboardId, const int64_t score, const std::string& jsonData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_PostScoreToLeaderboard\n");
  }

  /**
   * Removes a player's score from the leaderboard
   * 
   * @param leaderboardId The ID of the leaderboard
   * 
   * @param versionId The version of the leaderboard
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_RemovePlayerScore(std::string& _return, const std::string& leaderboardId, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_RemovePlayerScore\n");
  }

  /**
   * Post the players score to the given social leaderboard.
   * Pass leaderboard config data to dynamically create if necessary.
   * You can optionally send a user-defined json string of data
   * with the posted score. This string could include information
   * relevant to the posted score.
   * 
   * @param leaderboardId The leaderboard to post to
   * 
   * @param score The score to post
   * 
   * @param jsonData
   * @param leaderboardType leaderboard type
   * 
   * @param rotationType Type of rotation
   * 
   * @param rotationReset Date to reset the leaderboard UTC
   * 
   * @param retainedCount How many rotations to keep
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_PostScoreToDynamicLeaderboard(std::string& _return, const std::string& leaderboardId, const int64_t score, const std::string& jsonData, const  ::Ruyi::SDK::BrainCloudApi::SocialLeaderboardType::type leaderboardType, const  ::Ruyi::SDK::BrainCloudApi::RotationType::type rotationType, const  ::Ruyi::SDK::BrainCloudApi::date rotationReset, const int32_t retainedCount, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_PostScoreToDynamicLeaderboard\n");
  }

  /**
   * Post the players score to the given social leaderboard with a rotation type of DAYS.
   * Pass leaderboard config data to dynamically create if necessary.
   * You can optionally send a user-defined json string of data
   * with the posted score. This string could include information
   * relevant to the posted score.
   * 
   * @param leaderboardId The leaderboard to post to
   * 
   * @param score The score to post
   * 
   * @param jsonData
   * @param leaderboardType leaderboard type
   * 
   * @param rotationReset Date to reset the leaderboard UTC
   * 
   * @param retainedCount How many rotations to keep
   * 
   * @param numDaysToRotate How many days between each rotation
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_PostScoreToDynamicLeaderboardDays(std::string& _return, const std::string& leaderboardId, const int64_t score, const std::string& jsonData, const  ::Ruyi::SDK::BrainCloudApi::SocialLeaderboardType::type leaderboardType, const  ::Ruyi::SDK::BrainCloudApi::date rotationReset, const int32_t retainedCount, const int32_t numDaysToRotate, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_PostScoreToDynamicLeaderboardDays\n");
  }

  /**
   * Retrieve the social leaderboard for a list of players.
   * 
   * @param leaderboardId The ID of the leaderboard
   * 
   * @param profileIds The IDs of the players
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetPlayersSocialLeaderboard(std::string& _return, const std::string& leaderboardId, const std::vector<std::string> & profileIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetPlayersSocialLeaderboard\n");
  }

  /**
   * Retrieve a list of all leaderboards
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_ListLeaderboards(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_ListLeaderboards\n");
  }

  /**
   * Gets the number of entries in a global leaderboard
   * 
   * @param leaderboardId The ID of the leaderboard
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardEntryCount(std::string& _return, const std::string& leaderboardId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardEntryCount\n");
  }

  /**
   * Gets the number of entries in a global leaderboard
   * 
   * @param leaderboardId The ID of the leaderboard
   * 
   * @param versionId The version of the leaderboard
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion(std::string& _return, const std::string& leaderboardId, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetGlobalLeaderboardEntryCountByVersion\n");
  }

  /**
   * Gets a player's score from a leaderboard
   * 
   * @param leaderboardId The ID of the leaderboard
   * 
   * @param versionId The version of the leaderboard. Use -1 for current.
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetPlayerScore(std::string& _return, const std::string& leaderboardId, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetPlayerScore\n");
  }

  /**
   * Gets a player's score from multiple leaderboards
   * 
   * @param leaderboardIds A collection of leaderboardIds to retrieve scores from
   * 
   * @param clientIndex
   */
  void SocialLeaderboard_GetPlayerScoresFromLeaderboards(std::string& _return, const std::vector<std::string> & leaderboardIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialLeaderboard_GetPlayerScoresFromLeaderboards\n");
  }

  /**
   * Method returns the server time in UTC. This is in UNIX millis time format.
   * For instance 1396378241893 represents 2014-04-01 2:50:41.893 in GMT-4.
   * 
   * @param clientIndex
   */
  void Time_ReadServerTime(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Time_ReadServerTime\n");
  }

  /**
   * Processes any outstanding rewards for the given player
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param versionId Version of the tournament to claim rewards for.
   * Use -1 for the latest version.
   * 
   * @param clientIndex
   */
  void Tournament_ClaimTournamentReward(std::string& _return, const std::string& leaderboardId, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_ClaimTournamentReward\n");
  }

  /**
   * Get tournament status associated with a leaderboard
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param versionId Version of the tournament. Use -1 for the latest version.
   * 
   * @param clientIndex
   */
  void Tournament_GetTournamentStatus(std::string& _return, const std::string& leaderboardId, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_GetTournamentStatus\n");
  }

  /**
   * Join the specified tournament.
   * Any entry fees will be automatically collected.
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param tournamentCode Tournament to join
   * 
   * @param initialScore The initial score for players first joining a tournament
   * Usually 0, unless leaderboard is LOW_VALUE
   * 
   * @param clientIndex
   */
  void Tournament_JoinTournament(std::string& _return, const std::string& leaderboardId, const std::string& tournamentCode, const int64_t initialScore, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_JoinTournament\n");
  }

  /**
   * Removes player's score from tournament leaderboard
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param clientIndex
   */
  void Tournament_LeaveTournament(std::string& _return, const std::string& leaderboardId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_LeaveTournament\n");
  }

  /**
   * Post the users score to the leaderboard
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param score The score to post
   * 
   * @param jsonData Optional data attached to the leaderboard entry
   * 
   * @param roundStartedTime Time the user started the match resulting in the score
   * being posted.
   * 
   * @param clientIndex
   */
  void Tournament_PostTournamentScore(std::string& _return, const std::string& leaderboardId, const int64_t score, const std::string& jsonData, const  ::Ruyi::SDK::BrainCloudApi::date roundStartedTime, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_PostTournamentScore\n");
  }

  /**
   * Post the users score to the leaderboard and returns the results
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param score The score to post
   * 
   * @param jsonData Optional data attached to the leaderboard entry
   * 
   * @param roundStartedTime Time the user started the match resulting in the score
   * being posted.
   * 
   * @param sort Sort key Sort order of page.
   * 
   * @param beforeCount The count of number of players before the current player to include.
   * 
   * @param afterCount The count of number of players after the current player to include.
   * 
   * @param initialScore The initial score for players first joining a tournament
   * Usually 0, unless leaderboard is LOW_VALUE
   * 
   * @param clientIndex
   */
  void Tournament_PostTournamentScoreWithResults(std::string& _return, const std::string& leaderboardId, const int64_t score, const std::string& jsonData, const  ::Ruyi::SDK::BrainCloudApi::date roundStartedTime, const  ::Ruyi::SDK::BrainCloudApi::SortOrder::type sort, const int32_t beforeCount, const int32_t afterCount, const int64_t initialScore, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_PostTournamentScoreWithResults\n");
  }

  /**
   * Returns the user's expected reward based on the current scores
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param clientIndex
   */
  void Tournament_ViewCurrentReward(std::string& _return, const std::string& leaderboardId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_ViewCurrentReward\n");
  }

  /**
   * Returns the user's reward from a finished tournament
   * 
   * @param leaderboardId The leaderboard for the tournament
   * 
   * @param versionId Version of the tournament. Use -1 for the latest version.
   * 
   * @param clientIndex
   */
  void Tournament_ViewReward(std::string& _return, const std::string& leaderboardId, const int32_t versionId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Tournament_ViewReward\n");
  }

  /**
   * Create a new lobby.
   * 
   * @param lobbyType The type of lobby to create, either "PLAYER" or "RANKED".
   * 
   * @param maxSlots The maximum number of players that can join the lobby.
   * 
   * @param isOpen Whether or not the lobby is open by default.
   * 
   * @param jsonAttributes A json string containing any custom attributes to attach to the lobby.
   * 
   * @param clientIndex
   */
  void Lobby_CreateLobby(std::string& _return, const  ::Ruyi::SDK::BrainCloudApi::LobbyType::type lobbyType, const int32_t maxSlots, const bool isOpen, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_CreateLobby\n");
  }

  /**
   * Open a lobby so players can join.
   * 
   * @param lobbyId The ID of the lobby to open.
   * 
   * @param clientIndex
   */
  void Lobby_OpenLobby(std::string& _return, const std::string& lobbyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_OpenLobby\n");
  }

  /**
   * Close a lobby so players can't join.
   * 
   * @param lobbyId The ID of the lobby to close.
   * 
   * @param clientIndex
   */
  void Lobby_CloseLobby(std::string& _return, const std::string& lobbyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_CloseLobby\n");
  }

  /**
   * Find lobbies the player can join.
   * 
   * @param freeSlots
   * @param maxResults
   * @param jsonAttributes A json string containing any custom attributes to search for.
   * 
   * @param clientIndex
   */
  void Lobby_FindLobbies(std::string& _return, const int32_t freeSlots, const int32_t maxResults, const std::string& jsonAttributes, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_FindLobbies\n");
  }

  /**
   * Find lobbies with the player's friends in them.
   * 
   * @param clientIndex
   */
  void Lobby_FindFriendsLobbies(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_FindFriendsLobbies\n");
  }

  /**
   * Join a lobby.
   * 
   * @param lobbyId The ID of the lobby to join.
   * 
   * @param clientIndex
   */
  void Lobby_JoinLobby(std::string& _return, const std::string& lobbyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_JoinLobby\n");
  }

  /**
   * Leave a lobby.
   * 
   * @param lobbyId The ID of the lobby to leave.
   * 
   * @param clientIndex
   */
  void Lobby_LeaveLobby(std::string& _return, const std::string& lobbyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_LeaveLobby\n");
  }

  /**
   * Destroy a lobby.
   * 
   * @param lobbyId The ID of the lobby to destroy.
   * 
   * @param clientIndex
   */
  void Lobby_DestroyLobby(std::string& _return, const std::string& lobbyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_DestroyLobby\n");
  }

  /**
   * Start a lobby game.
   * 
   * @param lobbyId The ID of the lobby to destroy.
   * 
   * @param connectionString A string that can be used to connect to a real game (e.g an IP Address/port).
   * 
   * @param clientIndex
   */
  void Lobby_StartGame(std::string& _return, const std::string& lobbyId, const std::string& connectionString, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_StartGame\n");
  }

  /**
   * Get a list of lobbies the player is a member of.
   * 
   * @param clientIndex
   */
  void Lobby_GetMyLobbies(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Lobby_GetMyLobbies\n");
  }

  void Party_AcceptPartyInvitation(std::string& _return, const std::string& partyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_AcceptPartyInvitation\n");
  }

  void Party_GetPartyInfo(std::string& _return, const std::string& partyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_GetPartyInfo\n");
  }

  void Party_JoinParty(std::string& _return, const std::string& partyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_JoinParty\n");
  }

  void Party_LeaveParty(std::string& _return, const std::string& partyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_LeaveParty\n");
  }

  void Party_RejectPartyInvitation(std::string& _return, const std::string& partyId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_RejectPartyInvitation\n");
  }

  void Party_SendPartyInvitation(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_SendPartyInvitation\n");
  }

  void Party_ListPartyInvitations(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_ListPartyInvitations\n");
  }

  void Party_GetFriendsParties(std::string& _return, const int32_t maxResults, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_GetFriendsParties\n");
  }

  void Party_GetMyParty(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Party_GetMyParty\n");
  }

  void Patch_GetGameManifest(std::string& _return, const std::string& gameId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Patch_GetGameManifest\n");
  }

  void SocialFeed_ShareVideo(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareVideo\n");
  }

  void SocialFeed_ShareScreenshot(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareScreenshot\n");
  }

  void SocialFeed_ShareAchievement(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareAchievement\n");
  }

  void SocialFeed_ShareApp(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareApp\n");
  }

  void SocialFeed_ShareChannel(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareChannel\n");
  }

  void SocialFeed_ShareLink(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareLink\n");
  }

  void SocialFeed_ShareGameGuide(std::string& _return, const int32_t timestamp, const std::string& resource, const std::vector<std::string> & tagged, const std::vector<std::string> & show, const std::vector<std::string> & block, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ShareGameGuide\n");
  }

  void SocialFeed_ReadSocialFeed(std::string& _return, const int32_t skip, const int32_t limit, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ReadSocialFeed\n");
  }

  void SocialFeed_ReadFilteredSocialFeed(std::string& _return, const int32_t skip, const int32_t limit, const std::vector<std::string> & playerIds, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ReadFilteredSocialFeed\n");
  }

  void SocialFeed_ReadFriendsSocialFeed(std::string& _return, const int32_t skip, const int32_t limit, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ReadFriendsSocialFeed\n");
  }

  void SocialFeed_PostComment(std::string& _return, const int32_t timestamp, const std::string& parentId, const std::string& content, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_PostComment\n");
  }

  void SocialFeed_PostCommentReply(std::string& _return, const int32_t timestamp, const std::string& parentId, const std::string& content, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_PostCommentReply\n");
  }

  void SocialFeed_ReadComments(std::string& _return, const int32_t skip, const int32_t limit, const std::string& parentId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ReadComments\n");
  }

  void SocialFeed_ReadCommentReplies(std::string& _return, const int32_t skip, const int32_t limit, const std::string& parentId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_ReadCommentReplies\n");
  }

  void SocialFeed_LikeComment(std::string& _return, const std::string& socialFeedId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_LikeComment\n");
  }

  void SocialFeed_LikeActivity(std::string& _return, const std::string& socialFeedId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_LikeActivity\n");
  }

  void SocialFeed_UnlikeComment(std::string& _return, const std::string& socialFeedId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_UnlikeComment\n");
  }

  void SocialFeed_UnlikeActivity(std::string& _return, const std::string& socialFeedId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_UnlikeActivity\n");
  }

  void SocialFeed_SetFeedVisibility(std::string& _return, const std::string& visibility, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_SetFeedVisibility\n");
  }

  void SocialFeed_BlockPlayer(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_BlockPlayer\n");
  }

  void SocialFeed_HidePlayer(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_HidePlayer\n");
  }

  void SocialFeed_UnblockPlayer(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_UnblockPlayer\n");
  }

  void SocialFeed_UnhidePlayer(std::string& _return, const std::string& playerId, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_UnhidePlayer\n");
  }

  void SocialFeed_GetActivity(std::string& _return, const std::string& socialFeedId, const int32_t depth, const int32_t skip, const int32_t limit, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_GetActivity\n");
  }

  void SocialFeed_GetComment(std::string& _return, const std::string& socialFeedId, const int32_t depth, const int32_t skip, const int32_t limit, const int32_t clientIndex) {
    // Your implementation goes here
    printf("SocialFeed_GetComment\n");
  }

  void Telemetry_StartTelemetrySession(std::string& _return, const int32_t timestamp, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Telemetry_StartTelemetrySession\n");
  }

  void Telemetry_EndTelemetrySession(std::string& _return, const std::string& telemetrySessionId, const int32_t timestamp, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Telemetry_EndTelemetrySession\n");
  }

  void Telemetry_LogTelemetryEvent(std::string& _return, const std::string& telemetrySessionId, const int32_t timestamp, const std::string& eventType, const std::string& participantId, const std::map<std::string,  ::Ruyi::SDK::BrainCloudApi::JSON> & customData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Telemetry_LogTelemetryEvent\n");
  }

  void Telemetry_StartTelemetryEvent(std::string& _return, const std::string& telemetrySessionId, const int32_t timestamp, const std::string& eventType, const std::string& participantId, const std::map<std::string,  ::Ruyi::SDK::BrainCloudApi::JSON> & customData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Telemetry_StartTelemetryEvent\n");
  }

  void Telemetry_EndTelemetryEvent(std::string& _return, const std::string& telemetrySessionId, const int32_t timestamp, const std::string& eventType, const std::string& participantId, const std::map<std::string,  ::Ruyi::SDK::BrainCloudApi::JSON> & customData, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Telemetry_EndTelemetryEvent\n");
  }

  void Authentication_GetWeChatQRPageURL(std::string& _return, const int32_t clientIndex) {
    // Your implementation goes here
    printf("Authentication_GetWeChatQRPageURL\n");
  }

  void File_DownloadFile(std::string& _return, const std::string& cloudPath, const std::string& cloudFilename, const bool replaceIfExists, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_DownloadFile\n");
  }

  void File_GetDownloadInfo(std::string& _return, const std::string& cloudPath, const std::string& cloudFilename, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_GetDownloadInfo\n");
  }

  void File_CancelDownload(std::string& _return, const std::string& cloudPath, const std::string& cloudFilename, const int32_t clientIndex) {
    // Your implementation goes here
    printf("File_CancelDownload\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  ::apache::thrift::stdcxx::shared_ptr<BrainCloudServiceHandler> handler(new BrainCloudServiceHandler());
  ::apache::thrift::stdcxx::shared_ptr<TProcessor> processor(new BrainCloudServiceProcessor(handler));
  ::apache::thrift::stdcxx::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  ::apache::thrift::stdcxx::shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  ::apache::thrift::stdcxx::shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}

