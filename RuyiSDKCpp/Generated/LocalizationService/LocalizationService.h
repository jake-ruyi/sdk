/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef LocalizationService_H
#define LocalizationService_H

#include <thrift/TDispatchProcessor.h>
#include <thrift/async/TConcurrentClientSyncInfo.h>
#include "LocalizationServiceSDKServices_types.h"

namespace Ruyi { namespace SDK { namespace LocalizationService {

#ifdef _MSC_VER
  #pragma warning( push )
  #pragma warning (disable : 4250 ) //inheriting methods via dominance 
#endif

class LocalizationServiceIf {
 public:
  virtual ~LocalizationServiceIf() {}

  /**
   * Switch language to specified one.
   * 
   * @param language Which language to switch to. Should be the name of language code. Eg. en-US, zh-CN
   * 
   * @param loadAllContext Whether or not to load all context of the language
   * 
   * @param removeOld Whether or not to remove old language
   */
  virtual bool SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld) = 0;

  /**
   * Get currently active language
   */
  virtual void GetCurrentLanguage(std::string& _return) = 0;

  /**
   * Switch a context of the language.
   * 
   * @param context Which context to switch to.
   * 
   * @param language Which language that the context belong to
   */
  virtual bool SwitchContext(const std::string& context, const std::string& language) = 0;

  /**
   * Get currently active context.
   */
  virtual void HintContext(std::string& _return) = 0;

  /**
   * Get a localization string.
   * Return: localization string.
   * 
   * @param key The key of the string
   * 
   * @param context The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.
   * 
   * @param language The language to search
   */
  virtual void GetString(std::string& _return, const std::string& key, const std::string& context, const std::string& language) = 0;

  /**
   * Get a set of localization string.
   * 
   * @param filter A regular expresion used to filter the strings
   * 
   * @param context The context that the string belong to. Null indicate find the first matching string throughout all contexts in the language.
   * 
   * @param language The language to search
   */
  virtual void GetStrings(std::map<std::string, std::string> & _return, const std::string& filter, const std::string& context, const std::string& language) = 0;

  /**
   * Get the file name/path in the language.
   * 
   * The search will go through the context and its sub context to find the file name. Eg. If file name is not found in context com.ruyi, then the search will go on to find it in com.ruyi.moduleA and com.ruyi.moduleB.
   * 
   * @param filename File name with the path to the language pack root.
   * 
   * @param isVirtualPath True to get the virtual path, false to get the exact path to the file.
   * 
   * @param context The context of the file. If null, then while use system context "com.ruyi"
   */
  virtual void GetFileName(std::string& _return, const std::string& filename, const bool isVirtualPath, const std::string& context) = 0;
};

class LocalizationServiceIfFactory {
 public:
  typedef LocalizationServiceIf Handler;

  virtual ~LocalizationServiceIfFactory() {}

  virtual LocalizationServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(LocalizationServiceIf* /* handler */) = 0;
};

class LocalizationServiceIfSingletonFactory : virtual public LocalizationServiceIfFactory {
 public:
  LocalizationServiceIfSingletonFactory(const ::apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf>& iface) : iface_(iface) {}
  virtual ~LocalizationServiceIfSingletonFactory() {}

  virtual LocalizationServiceIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(LocalizationServiceIf* /* handler */) {}

 protected:
  ::apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf> iface_;
};

class LocalizationServiceNull : virtual public LocalizationServiceIf {
 public:
  virtual ~LocalizationServiceNull() {}
  bool SwitchLanguage(const std::string& /* language */, const bool /* loadAllContext */, const bool /* removeOld */) {
    bool _return = false;
    return _return;
  }
  void GetCurrentLanguage(std::string& /* _return */) {
    return;
  }
  bool SwitchContext(const std::string& /* context */, const std::string& /* language */) {
    bool _return = false;
    return _return;
  }
  void HintContext(std::string& /* _return */) {
    return;
  }
  void GetString(std::string& /* _return */, const std::string& /* key */, const std::string& /* context */, const std::string& /* language */) {
    return;
  }
  void GetStrings(std::map<std::string, std::string> & /* _return */, const std::string& /* filter */, const std::string& /* context */, const std::string& /* language */) {
    return;
  }
  void GetFileName(std::string& /* _return */, const std::string& /* filename */, const bool /* isVirtualPath */, const std::string& /* context */) {
    return;
  }
};

typedef struct _LocalizationService_SwitchLanguage_args__isset {
  _LocalizationService_SwitchLanguage_args__isset() : language(false), loadAllContext(false), removeOld(false) {}
  bool language :1;
  bool loadAllContext :1;
  bool removeOld :1;
} _LocalizationService_SwitchLanguage_args__isset;

class LocalizationService_SwitchLanguage_args {
 public:

  LocalizationService_SwitchLanguage_args(const LocalizationService_SwitchLanguage_args&);
  LocalizationService_SwitchLanguage_args& operator=(const LocalizationService_SwitchLanguage_args&);
  LocalizationService_SwitchLanguage_args() : language(), loadAllContext(0), removeOld(0) {
  }

  virtual ~LocalizationService_SwitchLanguage_args() throw();
  std::string language;
  bool loadAllContext;
  bool removeOld;

  _LocalizationService_SwitchLanguage_args__isset __isset;

  void __set_language(const std::string& val);

  void __set_loadAllContext(const bool val);

  void __set_removeOld(const bool val);

  bool operator == (const LocalizationService_SwitchLanguage_args & rhs) const
  {
    if (!(language == rhs.language))
      return false;
    if (!(loadAllContext == rhs.loadAllContext))
      return false;
    if (!(removeOld == rhs.removeOld))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_SwitchLanguage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_SwitchLanguage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_SwitchLanguage_pargs {
 public:


  virtual ~LocalizationService_SwitchLanguage_pargs() throw();
  const std::string* language;
  const bool* loadAllContext;
  const bool* removeOld;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_SwitchLanguage_result__isset {
  _LocalizationService_SwitchLanguage_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_SwitchLanguage_result__isset;

class LocalizationService_SwitchLanguage_result {
 public:

  LocalizationService_SwitchLanguage_result(const LocalizationService_SwitchLanguage_result&);
  LocalizationService_SwitchLanguage_result& operator=(const LocalizationService_SwitchLanguage_result&);
  LocalizationService_SwitchLanguage_result() : success(0) {
  }

  virtual ~LocalizationService_SwitchLanguage_result() throw();
  bool success;

  _LocalizationService_SwitchLanguage_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const LocalizationService_SwitchLanguage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_SwitchLanguage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_SwitchLanguage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_SwitchLanguage_presult__isset {
  _LocalizationService_SwitchLanguage_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_SwitchLanguage_presult__isset;

class LocalizationService_SwitchLanguage_presult {
 public:


  virtual ~LocalizationService_SwitchLanguage_presult() throw();
  bool* success;

  _LocalizationService_SwitchLanguage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class LocalizationService_GetCurrentLanguage_args {
 public:

  LocalizationService_GetCurrentLanguage_args(const LocalizationService_GetCurrentLanguage_args&);
  LocalizationService_GetCurrentLanguage_args& operator=(const LocalizationService_GetCurrentLanguage_args&);
  LocalizationService_GetCurrentLanguage_args() {
  }

  virtual ~LocalizationService_GetCurrentLanguage_args() throw();

  bool operator == (const LocalizationService_GetCurrentLanguage_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const LocalizationService_GetCurrentLanguage_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetCurrentLanguage_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_GetCurrentLanguage_pargs {
 public:


  virtual ~LocalizationService_GetCurrentLanguage_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetCurrentLanguage_result__isset {
  _LocalizationService_GetCurrentLanguage_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetCurrentLanguage_result__isset;

class LocalizationService_GetCurrentLanguage_result {
 public:

  LocalizationService_GetCurrentLanguage_result(const LocalizationService_GetCurrentLanguage_result&);
  LocalizationService_GetCurrentLanguage_result& operator=(const LocalizationService_GetCurrentLanguage_result&);
  LocalizationService_GetCurrentLanguage_result() : success() {
  }

  virtual ~LocalizationService_GetCurrentLanguage_result() throw();
  std::string success;

  _LocalizationService_GetCurrentLanguage_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const LocalizationService_GetCurrentLanguage_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetCurrentLanguage_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetCurrentLanguage_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetCurrentLanguage_presult__isset {
  _LocalizationService_GetCurrentLanguage_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetCurrentLanguage_presult__isset;

class LocalizationService_GetCurrentLanguage_presult {
 public:


  virtual ~LocalizationService_GetCurrentLanguage_presult() throw();
  std::string* success;

  _LocalizationService_GetCurrentLanguage_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _LocalizationService_SwitchContext_args__isset {
  _LocalizationService_SwitchContext_args__isset() : context(false), language(false) {}
  bool context :1;
  bool language :1;
} _LocalizationService_SwitchContext_args__isset;

class LocalizationService_SwitchContext_args {
 public:

  LocalizationService_SwitchContext_args(const LocalizationService_SwitchContext_args&);
  LocalizationService_SwitchContext_args& operator=(const LocalizationService_SwitchContext_args&);
  LocalizationService_SwitchContext_args() : context(), language() {
  }

  virtual ~LocalizationService_SwitchContext_args() throw();
  std::string context;
  std::string language;

  _LocalizationService_SwitchContext_args__isset __isset;

  void __set_context(const std::string& val);

  void __set_language(const std::string& val);

  bool operator == (const LocalizationService_SwitchContext_args & rhs) const
  {
    if (!(context == rhs.context))
      return false;
    if (!(language == rhs.language))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_SwitchContext_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_SwitchContext_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_SwitchContext_pargs {
 public:


  virtual ~LocalizationService_SwitchContext_pargs() throw();
  const std::string* context;
  const std::string* language;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_SwitchContext_result__isset {
  _LocalizationService_SwitchContext_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_SwitchContext_result__isset;

class LocalizationService_SwitchContext_result {
 public:

  LocalizationService_SwitchContext_result(const LocalizationService_SwitchContext_result&);
  LocalizationService_SwitchContext_result& operator=(const LocalizationService_SwitchContext_result&);
  LocalizationService_SwitchContext_result() : success(0) {
  }

  virtual ~LocalizationService_SwitchContext_result() throw();
  bool success;

  _LocalizationService_SwitchContext_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const LocalizationService_SwitchContext_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_SwitchContext_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_SwitchContext_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_SwitchContext_presult__isset {
  _LocalizationService_SwitchContext_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_SwitchContext_presult__isset;

class LocalizationService_SwitchContext_presult {
 public:


  virtual ~LocalizationService_SwitchContext_presult() throw();
  bool* success;

  _LocalizationService_SwitchContext_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class LocalizationService_HintContext_args {
 public:

  LocalizationService_HintContext_args(const LocalizationService_HintContext_args&);
  LocalizationService_HintContext_args& operator=(const LocalizationService_HintContext_args&);
  LocalizationService_HintContext_args() {
  }

  virtual ~LocalizationService_HintContext_args() throw();

  bool operator == (const LocalizationService_HintContext_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const LocalizationService_HintContext_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_HintContext_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_HintContext_pargs {
 public:


  virtual ~LocalizationService_HintContext_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_HintContext_result__isset {
  _LocalizationService_HintContext_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_HintContext_result__isset;

class LocalizationService_HintContext_result {
 public:

  LocalizationService_HintContext_result(const LocalizationService_HintContext_result&);
  LocalizationService_HintContext_result& operator=(const LocalizationService_HintContext_result&);
  LocalizationService_HintContext_result() : success() {
  }

  virtual ~LocalizationService_HintContext_result() throw();
  std::string success;

  _LocalizationService_HintContext_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const LocalizationService_HintContext_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_HintContext_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_HintContext_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_HintContext_presult__isset {
  _LocalizationService_HintContext_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_HintContext_presult__isset;

class LocalizationService_HintContext_presult {
 public:


  virtual ~LocalizationService_HintContext_presult() throw();
  std::string* success;

  _LocalizationService_HintContext_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _LocalizationService_GetString_args__isset {
  _LocalizationService_GetString_args__isset() : key(false), context(false), language(false) {}
  bool key :1;
  bool context :1;
  bool language :1;
} _LocalizationService_GetString_args__isset;

class LocalizationService_GetString_args {
 public:

  LocalizationService_GetString_args(const LocalizationService_GetString_args&);
  LocalizationService_GetString_args& operator=(const LocalizationService_GetString_args&);
  LocalizationService_GetString_args() : key(), context(), language() {
  }

  virtual ~LocalizationService_GetString_args() throw();
  std::string key;
  std::string context;
  std::string language;

  _LocalizationService_GetString_args__isset __isset;

  void __set_key(const std::string& val);

  void __set_context(const std::string& val);

  void __set_language(const std::string& val);

  bool operator == (const LocalizationService_GetString_args & rhs) const
  {
    if (!(key == rhs.key))
      return false;
    if (!(context == rhs.context))
      return false;
    if (!(language == rhs.language))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetString_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetString_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_GetString_pargs {
 public:


  virtual ~LocalizationService_GetString_pargs() throw();
  const std::string* key;
  const std::string* context;
  const std::string* language;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetString_result__isset {
  _LocalizationService_GetString_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetString_result__isset;

class LocalizationService_GetString_result {
 public:

  LocalizationService_GetString_result(const LocalizationService_GetString_result&);
  LocalizationService_GetString_result& operator=(const LocalizationService_GetString_result&);
  LocalizationService_GetString_result() : success() {
  }

  virtual ~LocalizationService_GetString_result() throw();
  std::string success;

  _LocalizationService_GetString_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const LocalizationService_GetString_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetString_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetString_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetString_presult__isset {
  _LocalizationService_GetString_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetString_presult__isset;

class LocalizationService_GetString_presult {
 public:


  virtual ~LocalizationService_GetString_presult() throw();
  std::string* success;

  _LocalizationService_GetString_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _LocalizationService_GetStrings_args__isset {
  _LocalizationService_GetStrings_args__isset() : filter(false), context(false), language(false) {}
  bool filter :1;
  bool context :1;
  bool language :1;
} _LocalizationService_GetStrings_args__isset;

class LocalizationService_GetStrings_args {
 public:

  LocalizationService_GetStrings_args(const LocalizationService_GetStrings_args&);
  LocalizationService_GetStrings_args& operator=(const LocalizationService_GetStrings_args&);
  LocalizationService_GetStrings_args() : filter(), context(), language() {
  }

  virtual ~LocalizationService_GetStrings_args() throw();
  std::string filter;
  std::string context;
  std::string language;

  _LocalizationService_GetStrings_args__isset __isset;

  void __set_filter(const std::string& val);

  void __set_context(const std::string& val);

  void __set_language(const std::string& val);

  bool operator == (const LocalizationService_GetStrings_args & rhs) const
  {
    if (!(filter == rhs.filter))
      return false;
    if (!(context == rhs.context))
      return false;
    if (!(language == rhs.language))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetStrings_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetStrings_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_GetStrings_pargs {
 public:


  virtual ~LocalizationService_GetStrings_pargs() throw();
  const std::string* filter;
  const std::string* context;
  const std::string* language;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetStrings_result__isset {
  _LocalizationService_GetStrings_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetStrings_result__isset;

class LocalizationService_GetStrings_result {
 public:

  LocalizationService_GetStrings_result(const LocalizationService_GetStrings_result&);
  LocalizationService_GetStrings_result& operator=(const LocalizationService_GetStrings_result&);
  LocalizationService_GetStrings_result() {
  }

  virtual ~LocalizationService_GetStrings_result() throw();
  std::map<std::string, std::string>  success;

  _LocalizationService_GetStrings_result__isset __isset;

  void __set_success(const std::map<std::string, std::string> & val);

  bool operator == (const LocalizationService_GetStrings_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetStrings_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetStrings_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetStrings_presult__isset {
  _LocalizationService_GetStrings_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetStrings_presult__isset;

class LocalizationService_GetStrings_presult {
 public:


  virtual ~LocalizationService_GetStrings_presult() throw();
  std::map<std::string, std::string> * success;

  _LocalizationService_GetStrings_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _LocalizationService_GetFileName_args__isset {
  _LocalizationService_GetFileName_args__isset() : filename(false), isVirtualPath(false), context(false) {}
  bool filename :1;
  bool isVirtualPath :1;
  bool context :1;
} _LocalizationService_GetFileName_args__isset;

class LocalizationService_GetFileName_args {
 public:

  LocalizationService_GetFileName_args(const LocalizationService_GetFileName_args&);
  LocalizationService_GetFileName_args& operator=(const LocalizationService_GetFileName_args&);
  LocalizationService_GetFileName_args() : filename(), isVirtualPath(0), context() {
  }

  virtual ~LocalizationService_GetFileName_args() throw();
  std::string filename;
  bool isVirtualPath;
  std::string context;

  _LocalizationService_GetFileName_args__isset __isset;

  void __set_filename(const std::string& val);

  void __set_isVirtualPath(const bool val);

  void __set_context(const std::string& val);

  bool operator == (const LocalizationService_GetFileName_args & rhs) const
  {
    if (!(filename == rhs.filename))
      return false;
    if (!(isVirtualPath == rhs.isVirtualPath))
      return false;
    if (!(context == rhs.context))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetFileName_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetFileName_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class LocalizationService_GetFileName_pargs {
 public:


  virtual ~LocalizationService_GetFileName_pargs() throw();
  const std::string* filename;
  const bool* isVirtualPath;
  const std::string* context;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetFileName_result__isset {
  _LocalizationService_GetFileName_result__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetFileName_result__isset;

class LocalizationService_GetFileName_result {
 public:

  LocalizationService_GetFileName_result(const LocalizationService_GetFileName_result&);
  LocalizationService_GetFileName_result& operator=(const LocalizationService_GetFileName_result&);
  LocalizationService_GetFileName_result() : success() {
  }

  virtual ~LocalizationService_GetFileName_result() throw();
  std::string success;

  _LocalizationService_GetFileName_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const LocalizationService_GetFileName_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const LocalizationService_GetFileName_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const LocalizationService_GetFileName_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _LocalizationService_GetFileName_presult__isset {
  _LocalizationService_GetFileName_presult__isset() : success(false) {}
  bool success :1;
} _LocalizationService_GetFileName_presult__isset;

class LocalizationService_GetFileName_presult {
 public:


  virtual ~LocalizationService_GetFileName_presult() throw();
  std::string* success;

  _LocalizationService_GetFileName_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class LocalizationServiceClient : virtual public LocalizationServiceIf {
 public:
  LocalizationServiceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  LocalizationServiceClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld);
  void send_SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld);
  bool recv_SwitchLanguage();
  void GetCurrentLanguage(std::string& _return);
  void send_GetCurrentLanguage();
  void recv_GetCurrentLanguage(std::string& _return);
  bool SwitchContext(const std::string& context, const std::string& language);
  void send_SwitchContext(const std::string& context, const std::string& language);
  bool recv_SwitchContext();
  void HintContext(std::string& _return);
  void send_HintContext();
  void recv_HintContext(std::string& _return);
  void GetString(std::string& _return, const std::string& key, const std::string& context, const std::string& language);
  void send_GetString(const std::string& key, const std::string& context, const std::string& language);
  void recv_GetString(std::string& _return);
  void GetStrings(std::map<std::string, std::string> & _return, const std::string& filter, const std::string& context, const std::string& language);
  void send_GetStrings(const std::string& filter, const std::string& context, const std::string& language);
  void recv_GetStrings(std::map<std::string, std::string> & _return);
  void GetFileName(std::string& _return, const std::string& filename, const bool isVirtualPath, const std::string& context);
  void send_GetFileName(const std::string& filename, const bool isVirtualPath, const std::string& context);
  void recv_GetFileName(std::string& _return);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class LocalizationServiceProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  ::apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (LocalizationServiceProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_SwitchLanguage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetCurrentLanguage(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_SwitchContext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_HintContext(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetString(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetStrings(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_GetFileName(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  LocalizationServiceProcessor(::apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf> iface) :
    iface_(iface) {
    processMap_["SwitchLanguage"] = &LocalizationServiceProcessor::process_SwitchLanguage;
    processMap_["GetCurrentLanguage"] = &LocalizationServiceProcessor::process_GetCurrentLanguage;
    processMap_["SwitchContext"] = &LocalizationServiceProcessor::process_SwitchContext;
    processMap_["HintContext"] = &LocalizationServiceProcessor::process_HintContext;
    processMap_["GetString"] = &LocalizationServiceProcessor::process_GetString;
    processMap_["GetStrings"] = &LocalizationServiceProcessor::process_GetStrings;
    processMap_["GetFileName"] = &LocalizationServiceProcessor::process_GetFileName;
  }

  virtual ~LocalizationServiceProcessor() {}
};

class LocalizationServiceProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  LocalizationServiceProcessorFactory(const ::apache::thrift::stdcxx::shared_ptr< LocalizationServiceIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::apache::thrift::stdcxx::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::apache::thrift::stdcxx::shared_ptr< LocalizationServiceIfFactory > handlerFactory_;
};

class LocalizationServiceMultiface : virtual public LocalizationServiceIf {
 public:
  LocalizationServiceMultiface(std::vector<apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~LocalizationServiceMultiface() {}
 protected:
  std::vector<apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf> > ifaces_;
  LocalizationServiceMultiface() {}
  void add(::apache::thrift::stdcxx::shared_ptr<LocalizationServiceIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  bool SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SwitchLanguage(language, loadAllContext, removeOld);
    }
    return ifaces_[i]->SwitchLanguage(language, loadAllContext, removeOld);
  }

  void GetCurrentLanguage(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetCurrentLanguage(_return);
    }
    ifaces_[i]->GetCurrentLanguage(_return);
    return;
  }

  bool SwitchContext(const std::string& context, const std::string& language) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->SwitchContext(context, language);
    }
    return ifaces_[i]->SwitchContext(context, language);
  }

  void HintContext(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->HintContext(_return);
    }
    ifaces_[i]->HintContext(_return);
    return;
  }

  void GetString(std::string& _return, const std::string& key, const std::string& context, const std::string& language) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetString(_return, key, context, language);
    }
    ifaces_[i]->GetString(_return, key, context, language);
    return;
  }

  void GetStrings(std::map<std::string, std::string> & _return, const std::string& filter, const std::string& context, const std::string& language) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetStrings(_return, filter, context, language);
    }
    ifaces_[i]->GetStrings(_return, filter, context, language);
    return;
  }

  void GetFileName(std::string& _return, const std::string& filename, const bool isVirtualPath, const std::string& context) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->GetFileName(_return, filename, isVirtualPath, context);
    }
    ifaces_[i]->GetFileName(_return, filename, isVirtualPath, context);
    return;
  }

};

// The 'concurrent' client is a thread safe client that correctly handles
// out of order responses.  It is slower than the regular client, so should
// only be used when you need to share a connection among multiple threads
class LocalizationServiceConcurrentClient : virtual public LocalizationServiceIf {
 public:
  LocalizationServiceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  LocalizationServiceConcurrentClient(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  bool SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld);
  int32_t send_SwitchLanguage(const std::string& language, const bool loadAllContext, const bool removeOld);
  bool recv_SwitchLanguage(const int32_t seqid);
  void GetCurrentLanguage(std::string& _return);
  int32_t send_GetCurrentLanguage();
  void recv_GetCurrentLanguage(std::string& _return, const int32_t seqid);
  bool SwitchContext(const std::string& context, const std::string& language);
  int32_t send_SwitchContext(const std::string& context, const std::string& language);
  bool recv_SwitchContext(const int32_t seqid);
  void HintContext(std::string& _return);
  int32_t send_HintContext();
  void recv_HintContext(std::string& _return, const int32_t seqid);
  void GetString(std::string& _return, const std::string& key, const std::string& context, const std::string& language);
  int32_t send_GetString(const std::string& key, const std::string& context, const std::string& language);
  void recv_GetString(std::string& _return, const int32_t seqid);
  void GetStrings(std::map<std::string, std::string> & _return, const std::string& filter, const std::string& context, const std::string& language);
  int32_t send_GetStrings(const std::string& filter, const std::string& context, const std::string& language);
  void recv_GetStrings(std::map<std::string, std::string> & _return, const int32_t seqid);
  void GetFileName(std::string& _return, const std::string& filename, const bool isVirtualPath, const std::string& context);
  int32_t send_GetFileName(const std::string& filename, const bool isVirtualPath, const std::string& context);
  void recv_GetFileName(std::string& _return, const int32_t seqid);
 protected:
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  apache::thrift::stdcxx::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
  ::apache::thrift::async::TConcurrentClientSyncInfo sync_;
};

#ifdef _MSC_VER
  #pragma warning( pop )
#endif

}}} // namespace

#endif
