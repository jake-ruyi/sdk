/**
 * Autogenerated by Thrift Compiler (0.12.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Threading;
using System.Threading.Tasks;
using Thrift;
using Thrift.Collections;

using Thrift.Protocols;
using Thrift.Protocols.Entities;
using Thrift.Protocols.Utilities;
using Thrift.Transports;
using Thrift.Transports.Client;
using Thrift.Transports.Server;


namespace Ruyi.SDK.Speech
{
  public abstract partial class VoiceCommand : TAbstractBase
  {
    public abstract Task WriteAsync(TProtocol tProtocol, CancellationToken cancellationToken);
    public readonly bool Isset;
    public abstract object Data { get; }
    protected VoiceCommand(bool isset)
    {
      Isset = isset;
    }

    public class ___undefined : VoiceCommand
    {
      public override object Data { get { return null; } }
      public ___undefined() : base(false) {}

      public override Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
      {
        throw new TProtocolException( TProtocolException.INVALID_DATA, "Cannot persist an union type which is not set.");
      }

    }

    public class Filename : VoiceCommand
    {
      private string _data;
      public override object Data { get { return _data; } }
      public Filename(string data) : base(true)
      {
        this._data = data;
      }
      public override async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken) {
        oprot.IncrementRecursionDepth();
        try
        {
          var struc = new TStruct("VoiceCommand");
          await oprot.WriteStructBeginAsync(struc, cancellationToken);
          var field = new TField();
          field.Name = "Filename";
          field.Type = TType.String;
          field.ID = 1;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteStringAsync(_data, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
          await oprot.WriteFieldStopAsync(cancellationToken);
          await oprot.WriteStructEndAsync(cancellationToken);
        }
        finally
        {
          oprot.DecrementRecursionDepth();
        }
        }
      }

      public class RawData : VoiceCommand
      {
        private byte[] _data;
        public override object Data { get { return _data; } }
        public RawData(byte[] data) : base(true)
        {
          this._data = data;
        }
        public override async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken) {
          oprot.IncrementRecursionDepth();
          try
          {
            var struc = new TStruct("VoiceCommand");
            await oprot.WriteStructBeginAsync(struc, cancellationToken);
            var field = new TField();
            field.Name = "RawData";
            field.Type = TType.String;
            field.ID = 2;
            await oprot.WriteFieldBeginAsync(field, cancellationToken);
            await oprot.WriteBinaryAsync(_data, cancellationToken);
            await oprot.WriteFieldEndAsync(cancellationToken);
            await oprot.WriteFieldStopAsync(cancellationToken);
            await oprot.WriteStructEndAsync(cancellationToken);
          }
          finally
          {
            oprot.DecrementRecursionDepth();
          }
          }
        }

        public static async Task<VoiceCommand> ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
        {
          iprot.IncrementRecursionDepth();
          try
          {
            VoiceCommand retval;
            await iprot.ReadStructBeginAsync(cancellationToken);
            TField field = await iprot.ReadFieldBeginAsync(cancellationToken);
            if (field.Type == TType.Stop)
            {
              await iprot.ReadFieldEndAsync(cancellationToken);
              retval = new ___undefined();
            }
            else
            {
              switch (field.ID)
              {
                case 1:
                  if (field.Type == TType.String) {
                    string temp;
                    temp = await iprot.ReadStringAsync(cancellationToken);
                    retval = new Filename(temp);
                  } else { 
                   await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                    retval = new ___undefined();
                  }
                  break;
                case 2:
                  if (field.Type == TType.String) {
                    byte[] temp;
                    temp = await iprot.ReadBinaryAsync(cancellationToken);
                    retval = new RawData(temp);
                  } else { 
                   await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                    retval = new ___undefined();
                  }
                  break;
                default: 
                  await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
                  retval = new ___undefined();
                  break;
              }
              await iprot.ReadFieldEndAsync(cancellationToken);
              if ((await iprot.ReadFieldBeginAsync(cancellationToken)).Type != TType.Stop)
              {
                throw new TProtocolException(TProtocolException.INVALID_DATA);
              }
            }
            await iprot.ReadStructEndAsync(cancellationToken);
            return retval;
        }
        finally
        {
          iprot.DecrementRecursionDepth();
        }
        }

      }

    }
